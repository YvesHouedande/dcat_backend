Directory structure:
└── users/
    ├── controllers/
    │   ├── sync.controller.js
    │   └── users.controller.js
    ├── routes/
    │   └── users.routes.js
    ├── services/
    │   └── users.service.js
    ├── sql/
    │   ├── employes.sql
    │   └── fonctions.sql
    └── tests/

================================================
File: controllers/sync.controller.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonction } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');
const logger = require('../../../core/utils/logger');

module.exports = {
  syncUser: async (req, res) => {
    const token = req.kauth.grant.access_token;
    // const { email, firstName, lastName } = req.body;
    const { email } = req.body;


    // Validation email/token
    if (!token?.content?.email || !email) {
      logger.warn('Token ou email manquant', { token, email });
      return res.status(400).json({ error: "Token ou email invalide" });
    }

    if (token.content.email !== email) {
      logger.warn('IncohÃ©rence email/token', {
        tokenEmail: token.content.email,
        providedEmail: email,
        userId: token.content.sub
      });
      return res.status(400).json({ error: "Email ne correspond pas au token" });
    }


    try {
      // RÃ©cupÃ©ration de l'ID de la fonction Technicien
      const technicien = await db.select()
        .from(fonction)
        .where(eq(fonction.nom, 'Technicien'))
        .limit(1);
      console.log("RÃ©sultat recherche Technicien:", technicien);

      if (!technicien || technicien.length === 0) {
        throw new Error('La fonction Technicien n\'existe pas en base');
      }

      const fonctionId = technicien[0].id;

      // DonnÃ©es utilisateur
      const userData = {
        keycloak_id: token.content.sub,
        email: token.content.email,
        // nom: lastName || token.content.family_name || 'Non spÃ©cifiÃ©',
        // prenom: firstName || token.content.given_name || 'Non spÃ©cifiÃ©',
        status: 'actif',
        fonctionId: fonctionId,
        created_at: new Date(),
        updated_at: new Date()
      };

      // Upsert
      await db.insert(employes)
        .values(userData)
        .onConflictDoUpdate({
          target: employes.keycloak_id,
          set: {
            email: userData.email,
            nom: userData.nom,
            prenom: userData.prenom,
            fonctionId: fonctionId,
            updated_at: userData.updated_at
          }
        });

      res.status(204).end();
    } catch (error) {
      logger.error('Erreur de synchronisation', {
        error: error.message,
        userId: token.content.sub,
        email: token.content.email
      });

      if (error.message.includes('Technicien')) {
        res.status(400).json({ 
          error: "Configuration manquante",
          details: "La fonction Technicien doit Ãªtre crÃ©Ã©e en base de donnÃ©es"
        });
      } else {
        res.status(500).json({ 
          error: "Ã‰chec de la synchronisation",
          details: error.message
        });
      }
    }
  }
};


================================================
File: controllers/users.controller.js
================================================
ï»¿const logger = require('../../../core/utils/logger');
const userService = require('../services/users.service');

module.exports = {
  getAllUsers: async (req, res, next) => {
    try {
      const { page = 1, limit = 10 } = req.query;
      const users = await userService.getAllUsers(parseInt(page), parseInt(limit));
      
      logger.info(`RÃ©cupÃ©ration de ${users.length} utilisateurs`);
      res.json(users.map(user => ({
        ...user,
        fonction: user.fonction?.nom || 'Non dÃ©fini'
      })));
    } catch (error) {
      logger.error('Ã‰chec de rÃ©cupÃ©ration des utilisateurs:', error);
      next(error);
    }
  },


  getMyProfile: async (req, res) => {
  const token = req.kauth?.grant?.access_token;
  if (!token?.content?.sub) {
      return res.status(401).json({ error: "Token non fourni ou invalide" });
  }
  const { sub } = req.kauth.grant.access_token.content;

  try {
    const user = await userService.getUserByKeycloakId(sub);
    // console.log('User data:', user); // Debug log

    if (!user) {
      return res.status(404).json({ error: "Utilisateur non trouvÃ©" });
    }

    res.json({
      email: user.email,
      nom: user.nom,
      prenom: user.prenom,
      contact: user.contact,
      adresse: user.adresse,
      fonction: user.fonction?.nom || 'Non dÃ©fini'
    });
  } catch (error) {
    console.error('Error details:', error); // Log complet de l'erreur
    res.status(500).json({ 
      error: "Erreur serveur",
      details: error.message
    });
  }
},

  updateMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content;
    const updates = req.body;

    try {
      const allowedFields = ["adresse", "contact", "nom", "prenom"];
      const filteredUpdates = Object.keys(updates)
        .filter(key => allowedFields.includes(key))
        .reduce((obj, key) => ({ ...obj, [key]: updates[key] }), {});

      if (Object.keys(filteredUpdates).length === 0) {
        return res.status(400).json({ error: "Aucun champ modifiable fourni" });
      }

      logger.error('Test-------------------------',filteredUpdates);

      await userService.updateUserProfile(sub, filteredUpdates);
      res.status(204).end();
    } catch (error) {
      logger.error('Ã‰chec de la mise Ã  jour du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Ã‰chec de la mise Ã  jour" });
    }
  }
};


================================================
File: routes/users.routes.js
================================================
ï»¿const express = require('express');
const router = express.Router();
const { protect } = require('../../../core/auth/middleware');
const UsersController = require('../controllers/users.controller');
const SyncController = require('../controllers/sync.controller');


// Synchronisation Keycloak â†’ BD MÃ©tier
router.post('/sync', protect(), SyncController.syncUser);

// RÃ©cupÃ©ration du profil utilisateur
router.get('/me', protect([]), UsersController.getMyProfile);


// Mise Ã  jour du profil (ex: tÃ©lÃ©phone)
router.patch('/me', protect([]), UsersController.updateMyProfile);

// RÃ©cupÃ©ration de tous les utilisateurs (avec pagination)
router.get('/', protect([]), UsersController.getAllUsers);

module.exports = router;


================================================
File: services/users.service.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonction } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');

module.exports = {
  getUserByKeycloakId: async (keycloakId) => {
    const result = await db.select()
      .from(employes)
      .leftJoin(fonction, eq(employes.fonctionId, fonction.id)) 
      .where(eq(employes.keycloak_id, keycloakId))
      .limit(1);

    return result[0] ? {
      ...result[0].employes,
      fonction: result[0].fonction 
    } : null;
  },

  updateUserProfile: async (keycloakId, data) => {
    const allowedFields = ["contact", "adresse", "prenom", "nom"];
    const updates = Object.keys(data)
      .filter(key => allowedFields.includes(key))
      .reduce((obj, key) => ({ ...obj, [key]: data[key] }), {});

    await db.update(employes)
      .set(updates)
      .where(eq(employes.keycloak_id, keycloakId));
  },

  getAllUsers: async (page = 1, limit = 10) => {
    try {
      return await db.select({
        id: employes.id,
        email: employes.email,
        prenom: employes.prenom,
        nom: employes.nom,
        status: employes.status,
        // service: employes.service
      })
      .from(employes)
      .orderBy(employes.nom)
      .limit(limit)
      .offset((page - 1) * limit)
      .execute();
    } catch (error) {
      throw new Error(`Ã‰chec de rÃ©cupÃ©ration des utilisateurs: ${error.message}`);
    }
  },
};



