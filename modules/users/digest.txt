Directory structure:
└── users/
    ├── controllers/
    │   ├── sync.controller.js
    │   └── users.controller.js
    ├── routes/
    │   └── users.routes.js
    ├── services/
    │   └── users.service.js
    └── tests/

================================================
File: controllers/sync.controller.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonction } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');
const logger = require('../../../core/utils/logger');

module.exports = {
  syncUser: async (req, res) => {
    const token = req.kauth.grant.access_token;
    const { email, firstName, lastName } = req.body;

    // Validation email/token
    if (!token?.content?.email || !email) {
      logger.warn('Token ou email manquant', { token, email });
      return res.status(400).json({ error: "Token ou email invalide" });
    }

    if (token.content.email !== email) {
      logger.warn('IncohÃ©rence email/token', {
        tokenEmail: token.content.email,
        providedEmail: email,
        userId: token.content.sub
      });
      return res.status(400).json({ error: "Email ne correspond pas au token" });
    }

    try {
      // RÃ©cupÃ©ration de l'ID de la fonction Technicien
      const technicien = await db.select()
        .from(fonction)
        .where(eq(fonction.nom, 'Technicien'))
        .limit(1);
      console.log("RÃ©sultat recherche Technicien:", technicien);

      if (!technicien || technicien.length === 0) {
        throw new Error('La fonction Technicien n\'existe pas en base');
      }

      const fonctionId = technicien[0].id;

      // DonnÃ©es utilisateur
      const userData = {
        keycloak_id: token.content.sub,
        email: token.content.email,
        nom: lastName || token.content.family_name || 'Non spÃ©cifiÃ©',
        prenom: firstName || token.content.given_name || 'Non spÃ©cifiÃ©',
        status: 'actif',
        fonctionId: fonctionId,
        created_at: new Date(),
        updated_at: new Date()
      };

      // Upsert
      await db.insert(employes)
        .values(userData)
        .onConflictDoUpdate({
          target: employes.keycloak_id,
          set: {
            email: userData.email,
            nom: userData.nom,
            prenom: userData.prenom,
            fonctionId: fonctionId,
            updated_at: userData.updated_at
          }
        });

      res.status(204).end();
    } catch (error) {
      logger.error('Erreur de synchronisation', {
        error: error.message,
        userId: token.content.sub,
        email: token.content.email
      });

      if (error.message.includes('Technicien')) {
        res.status(400).json({ 
          error: "Configuration manquante",
          details: "La fonction Technicien doit Ãªtre crÃ©Ã©e en base de donnÃ©es"
        });
      } else {
        res.status(500).json({ 
          error: "Ã‰chec de la synchronisation",
          details: error.message
        });
      }
    }
  }
};


================================================
File: controllers/users.controller.js
================================================
ï»¿const logger = require('../../../core/utils/logger');
const userService = require('../services/users.service');

module.exports = {
  getAllUsers: async (req, res, next) => {
    try {
      const { page = 1, limit = 10 } = req.query;
      const users = await userService.getAllUsers(parseInt(page), parseInt(limit));
      
      logger.info(`RÃ©cupÃ©ration de ${users.length} utilisateurs`);
      res.json(users.map(user => ({
        ...user,
        fonction: user.fonction?.nom || 'Non dÃ©fini'
      })));
    } catch (error) {
      logger.error('Ã‰chec de rÃ©cupÃ©ration des utilisateurs:', error);
      next(error);
    }
  },

  getMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content;

    try {
      const user = await userService.getUserByKeycloakId(sub);
      if (!user) return res.status(404).json({ error: "Utilisateur non trouvÃ©" });

      res.json({
        email: user.email,
        nom: user.nom,
        prenom: user.prenom,
        service: user.service,
        fonction: user.fonction?.nom || 'Non dÃ©fini'
      });
    } catch (error) {
      logger.error('Erreur lors de la rÃ©cupÃ©ration du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Erreur serveur" });
    }
  },

  updateMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content;
    const updates = req.body;

    try {
      const allowedFields = ["tel", "adresse"];
      const filteredUpdates = Object.keys(updates)
        .filter(key => allowedFields.includes(key))
        .reduce((obj, key) => ({ ...obj, [key]: updates[key] }), {});

      if (Object.keys(filteredUpdates).length === 0) {
        return res.status(400).json({ error: "Aucun champ modifiable fourni" });
      }

      await userService.updateUserProfile(sub, filteredUpdates);
      res.status(204).end();
    } catch (error) {
      logger.error('Ã‰chec de la mise Ã  jour du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Ã‰chec de la mise Ã  jour" });
    }
  }
};


================================================
File: routes/users.routes.js
================================================
ï»¿//


const express = require('express');
const router = express.Router();
const { protect } = require('../../../core/auth/middleware');
const UsersController = require('../controllers/users.controller');
const SyncController = require('../controllers/sync.controller');

// Synchronisation Keycloak â†’ BD MÃ©tier
router.post('/sync', protect(), SyncController.syncUser);

// RÃ©cupÃ©ration du profil utilisateur
router.get('/me', protect(), UsersController.getMyProfile);

// Mise Ã  jour du profil (ex: tÃ©lÃ©phone)
router.patch('/me', protect(), UsersController.updateMyProfile);

// RÃ©cupÃ©ration de tous les utilisateurs (avec pagination)
// router.get('/', protect(['admin']), UsersController.getAllUsers);
router.get('/', protect(), UsersController.getAllUsers);


module.exports = router;


================================================
File: services/users.service.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonctions } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');

module.exports = {
  getUserByKeycloakId: async (keycloakId) => {
    return await db.query.employes.findFirst({
      where: eq(employes.keycloak_id, keycloakId),
      with: {
        fonction: true // Jointure avec la table fonctions
      }
    });
  },

  updateUserProfile: async (keycloakId, data) => {
    const allowedFields = ["tel", "adresse"];
    const updates = Object.keys(data)
      .filter(key => allowedFields.includes(key))
      .reduce((obj, key) => ({ ...obj, [key]: data[key] }), {});

    await db.update(employes)
      .set(updates)
      .where(eq(employes.keycloak_id, keycloakId));
  },

  getAllUsers: async (page = 1, limit = 10) => {
    try {
      return await db.query.employes.findMany({
        columns: {
          id: true,
          email: true,
          prenom: true,
          nom: true,
          status: true
        },
        with: {
          fonction: {
            columns: {
              nom: true
            }
          }
        },
        orderBy: [employes.nom],
        limit: limit,
        offset: (page - 1) * limit
      });
    } catch (error) {
      throw new Error(`Ã‰chec de rÃ©cupÃ©ration des utilisateurs: ${error.message}`);
    }
  }
};


