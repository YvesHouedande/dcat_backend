Directory structure:
└── auth/
    ├── keycloak.config.js
    ├── middleware.js
    └── setupKeycloak.js

================================================
File: keycloak.config.js
================================================
ï»¿const Keycloak = require('keycloak-connect');
const session = require('express-session');
const logger = require('../utils/logger');
require('dotenv').config();

const memoryStore = new session.MemoryStore();

const keycloakConfig = {
  realm: process.env.KEYCLOAK_REALM,
  'auth-server-url': process.env.KEYCLOAK_URL,
  'ssl-required': 'external',
  resource: process.env.KEYCLOAK_CLIENT_ID,
  'public-client': false,
  'confidential-port': 0,
  credentials: {
    secret: process.env.KEYCLOAK_CLIENT_SECRET
  }
};

logger.info('Keycloak Config:', {
  realm: keycloakConfig.realm,
  authServer: keycloakConfig['auth-server-url'],
  clientId: keycloakConfig.resource
});

const keycloak = new Keycloak(
  { store: memoryStore },
  keycloakConfig
);

module.exports = {
  keycloak,
  memoryStore,
  keycloakConfig
};


console.log('Configuration Keycloak chargÃ©e:', {
  realm: process.env.KEYCLOAK_REALM,
  url: process.env.KEYCLOAK_URL,
  clientId: process.env.KEYCLOAK_CLIENT_ID,
  hasSecret: !!process.env.KEYCLOAK_CLIENT_SECRET
});


================================================
File: middleware.js
================================================

const { keycloak, memoryStore } = require('./keycloak.config');
const logger = require('../utils/logger');
const { db } = require('../../core/database/config');
const { employes } = require('../../core/database/models');
const { eq } = require('drizzle-orm');
const { jwtVerify } = require('jose');
const { getKeycloakPublicKey } = require('./setupKeycloak');

// Initialisation Keycloak
const initKeycloak = () => {
  logger.info('Initializing Keycloak middleware');
  return keycloak.middleware({
    admin: '/admin',
    logout: '/logout'
  });
};

// Middleware de protection avec rÃ´les
const protect = (requiredRoles = []) => {
  return [
    keycloak.protect(),
    (req, res, next) => {
      const token = req.kauth.grant.access_token;
      if (requiredRoles.length && !requiredRoles.some(r => token.hasRole(r))) {
        return res.status(403).json({ error: 'Permissions insuffisantes' });
      }
      next();
    }
  ];
};

// Validation JWT directe
const validateJWT = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader) return res.status(401).json({ error: 'Token manquant' });

    const token = authHeader.split(' ')[1];
    const { payload } = await jwtVerify(token, await getKeycloakPublicKey());
    req.userToken = payload;
    next();
  } catch (error) {
    logger.error('Erreur validation JWT:', error);
    res.status(401).json({ error: 'Token invalide' });
  }
};

// Synchronisation utilisateur optimisÃ©e
const syncUserOnLogin = async (req, res, next) => {
  if (!req.kauth?.grant?.access_token?.content) {
    return next();
  }

  const keycloakUser = req.kauth.grant.access_token.content;
  
  if (!keycloakUser?.sub) {
    logger.warn('Token Keycloak invalide: sub manquant');
    return next();
  }

  try {
    // Solution avec UPSERT (INSERT ON CONFLICT UPDATE)
    await db.insert(employes)
      .values({
        keycloak_id: keycloakUser.sub,
        email: keycloakUser.email || `${keycloakUser.sub}@temp.dcat`,
        nom: keycloakUser.given_name || 'Ã€ complÃ©ter',
        prenom: keycloakUser.family_name || 'Ã€ complÃ©ter',
        status: 'actif',
        fonctionId: 1,
        contact: '',
        adresse: ''
      })
      .onConflictDoUpdate({
        target: employes.keycloak_id,
        set: { 
          email: keycloakUser.email,
          nom: keycloakUser.given_name || db.sql`excluded.nom`,
          prenom: keycloakUser.family_name || db.sql`excluded.prenom`,
          status: 'actif'
        }
      })
      .execute();

    logger.info(`Utilisateur synchronisÃ©: ${keycloakUser.sub}`);
    next();
  } catch (error) {
    logger.error('Erreur synchronisation utilisateur', {
      error: error.message,
      userId: keycloakUser.sub,
      stack: error.stack
    });
    next(error);
  }
};

// Middleware de dÃ©connexion complet
const handleLogout = async (req, res, next) => {
  try {
    if (!req.kauth?.grant) {
      return res.status(200).send('DÃ©connectÃ©');
    }

    // 1. RÃ©voquer le token Keycloak
    await keycloak.grantManager.revoke(req.kauth.grant);
    
    // 2. DÃ©truire la session
    req.session.destroy(err => {
      if (err) logger.error('Erreur destruction session:', err);
      
      // 3. Nettoyer les cookies
      res.clearCookie('connect.sid');
      res.clearCookie('keycloak_token');
      
      res.status(200).send('DÃ©connectÃ© avec succÃ¨s');
    });
  } catch (error) {
    logger.error('Erreur lors de la dÃ©connexion:', error);
    next(error);
  }
};

module.exports = {
  syncUserOnLogin,
  keycloak,
  memoryStore,
  initKeycloak,
  protect,
  validateJWT,
  handleLogout
};


================================================
File: setupKeycloak.js
================================================
const session = require('express-session');
const { memoryStore, keycloak } = require('./keycloak.config');
const { createRemoteJWKSet } = require('jose');
const { Issuer } = require('openid-client');

const sessionConfig = session({
  secret: process.env.SESSION_SECRET || 'your-strong-secret-here',
  resave: false,
  saveUninitialized: true,
  store: memoryStore
});

// Fonction pour obtenir les clÃ©s publiques Keycloak
async function getKeycloakPublicKey() {
  const keycloakIssuer = await Issuer.discover(
    `${keycloak.config['auth-server-url']}/realms/${keycloak.config.realm}`
  );
  
  const jwksUri = keycloakIssuer.metadata.jwks_uri;
  return createRemoteJWKSet(new URL(jwksUri));
}

module.exports = {
  sessionConfig,
  getKeycloakPublicKey // Exportez la nouvelle fonction
};

