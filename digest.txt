Directory structure:
└── dcat_backend/
    ├── README.md
    ├── Dockerfile
    ├── docker-compose.prod.yml
    ├── docker-compose.yml
    ├── drizzle.config.js
    ├── init.sql
    ├── package.json
    ├── server.js
    ├── core/
    │   ├── auth/
    │   │   ├── keycloak.config.js
    │   │   ├── middleware.js
    │   │   └── setupKeycloak.js
    │   ├── database/
    │   │   ├── config.js
    │   │   ├── db.config.js
    │   │   ├── migration.js
    │   │   ├── models.js
    │   │   ├── test-db.js
    │   │   └── migrations/
    │   │       ├── 0000_cloudy_fat_cobra.sql
    │   │       ├── 0001_worthless_venus.sql
    │   │       └── meta/
    │   │           ├── 0000_snapshot.json
    │   │           ├── 0001_snapshot.json
    │   │           └── _journal.json
    │   └── utils/
    │       ├── logger.js
    │       ├── swagger.js
    │       └── swagger.routes.js
    ├── init-db/
    │   └── nit-multiple-dbs.sh
    ├── keycloak-setup/
    │   ├── backend_cli_id.json
    │   ├── frontend_cli_id.json
    │   ├── keycloak-setup-back.js
    │   ├── keycloak-setup-front.js
    │   └── keycloak-setup.js
    ├── media/
    │   ├── documents/
    │   │   └── technique/
    │   │       └── interventions/
    │   │           └── je dois faire la presentation de la_1745573090108.txt
    │   └── images/
    │       └── stock_moyensgeneraux/
    │           └── produits/
    ├── modules/
    │   ├── Administration&Finance/
    │   │   ├── FinanceCompta/
    │   │   │   ├── controllers/
    │   │   │   │   ├── accounting.controller.js
    │   │   │   │   ├── demamd.controller.js
    │   │   │   │   ├── entity.controller.js
    │   │   │   │   └── partenaire.controller.js
    │   │   │   ├── routes/
    │   │   │   │   ├── accounting.routes.js
    │   │   │   │   ├── administration.routes.js
    │   │   │   │   ├── demand.route.js
    │   │   │   │   ├── entity.route.js
    │   │   │   │   └── partner.route.js
    │   │   │   └── services/
    │   │   │       ├── demand.service.js
    │   │   │       ├── entity.service.js
    │   │   │       └── partenaire.service.js
    │   │   ├── GestionAdministrative/
    │   │   │   ├── controllers/
    │   │   │   │   ├── contrat.controller.js
    │   │   │   │   ├── entite.controller.js
    │   │   │   │   ├── interlocuteur.controller.js
    │   │   │   │   ├── nature.controller.js
    │   │   │   │   └── partenaire.controller.js
    │   │   │   ├── routes/
    │   │   │   │   ├── contrat.route.js
    │   │   │   │   ├── entite.route.js
    │   │   │   │   ├── interlocuteur.route.js
    │   │   │   │   ├── nature.route.js
    │   │   │   │   └── partenaire.route.js
    │   │   │   └── services/
    │   │   │       ├── contrat.service.js
    │   │   │       ├── entite.service.js
    │   │   │       ├── interlocuteur.service.js
    │   │   │       ├── nature.service.js
    │   │   │       └── partenaire.service.js
    │   │   ├── RH/
    │   │   │   ├── controllers/
    │   │   │   │   └── demande.controller.js
    │   │   │   ├── routes/
    │   │   │   │   └── demande.route.js
    │   │   │   └── services/
    │   │   │       └── demande.service.js
    │   │   └── routes/
    │   │       └── Administration&Finance.routes.js
    │   ├── clients/
    │   │   ├── controllers/
    │   │   │   └── clients.controller.js
    │   │   └── routes/
    │   │       └── clients.routes.js
    │   ├── dashboard/
    │   │   ├── controllers/
    │   │   │   └── dashboard.controller.js
    │   │   └── routes/
    │   │       └── dashboard.routes.js
    │   ├── marketing_commercial/
    │   │   ├── controllers/
    │   │   │   ├── affiches.controller.js
    │   │   │   ├── clients.controller.js
    │   │   │   ├── commandes.controller.js
    │   │   │   ├── produits.controller.js
    │   │   │   └── services.controller.js
    │   │   ├── routes/
    │   │   │   ├── clients.routes.js
    │   │   │   ├── commandes.routes.js
    │   │   │   ├── marketing_commercial.route.js
    │   │   │   └── produits.routes.js
    │   │   └── services/
    │   │       ├── clients.service.js
    │   │       ├── commandes.service.js
    │   │       └── produits.service.js
    │   ├── moyens_generaux/
    │   │   ├── controllers/
    │   │   │   └── mouvementOutil.controller.js
    │   │   ├── routes/
    │   │   │   └── mouvementOutil.route.js
    │   │   └── services/
    │   │       └── mouvementOutil.service.js
    │   ├── stocks/
    │   │   ├── readme.md
    │   │   ├── controllers/
    │   │   │   ├── achat.controller.js
    │   │   │   ├── categorie.controller.js
    │   │   │   ├── commande.controller.js
    │   │   │   ├── exemplaire.controller.js
    │   │   │   ├── famille.controller.js
    │   │   │   ├── livraison.controller.js
    │   │   │   ├── marque.controller.js
    │   │   │   ├── modele.controller.js
    │   │   │   ├── produit.controller.js
    │   │   │   ├── sortiesExemplaire.controller.js
    │   │   │   ├── stocks.controller.js
    │   │   │   └── typesProduit.controller.js
    │   │   ├── routes/
    │   │   │   ├── achat.route.js
    │   │   │   ├── categorie.route.js
    │   │   │   ├── commande.route.js
    │   │   │   ├── exemplaire.routes.js
    │   │   │   ├── famille.routes.js
    │   │   │   ├── livraison.routes.js
    │   │   │   ├── marque.routes.js
    │   │   │   ├── modele.routes.js
    │   │   │   ├── produit.routes.js
    │   │   │   ├── sortiesExemplaire.route.js
    │   │   │   ├── stocks.routes.js
    │   │   │   └── typesProduit.routes.js
    │   │   ├── services/
    │   │   │   ├── achat.service.js
    │   │   │   ├── categorie.service.js
    │   │   │   ├── commande.service.js
    │   │   │   ├── exemplaire.service.js
    │   │   │   ├── famille.service.js
    │   │   │   ├── livraison.service.js
    │   │   │   ├── marque.service.js
    │   │   │   ├── modele.service.js
    │   │   │   ├── produit.service.js
    │   │   │   ├── sortiesExemplaire.service.js
    │   │   │   ├── stocks.service.js
    │   │   │   └── typesProduit.service.js
    │   │   ├── tests/
    │   │   │   └── stocks.mock.js
    │   │   └── utils/
    │   │       ├── drizzle-wrapper.js
    │   │       └── setup-triggers.js
    │   ├── technique/
    │   │   ├── controllers/
    │   │   │   ├── interventions.controller.js
    │   │   │   ├── projets.controller.js
    │   │   │   └── taches.controller.js
    │   │   ├── routes/
    │   │   │   ├── interventions.routes.js
    │   │   │   ├── projets.routes.js
    │   │   │   ├── taches.routes.js
    │   │   │   └── technique.routes.js
    │   │   └── services/
    │   │       ├── interventions.service.js
    │   │       ├── projets.service.js
    │   │       └── taches.service.js
    │   ├── users/
    │   │   ├── digest.txt
    │   │   ├── controllers/
    │   │   │   ├── sync.controller.js
    │   │   │   └── users.controller.js
    │   │   ├── routes/
    │   │   │   └── users.routes.js
    │   │   ├── services/
    │   │   │   └── users.service.js
    │   │   └── sql/
    │   │       ├── employes.sql
    │   │       └── fonctions.sql
    │   └── utils/
    │       └── middleware/
    │           └── uploadMiddleware.js
    └── .github/
        └── workflows/
            └── main.yml

================================================
File: README.md
================================================
[Non-text file]


================================================
File: Dockerfile
================================================
# Ã‰tape 1 : Builder les dÃ©pendances
FROM node:22-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev  # Installe uniquement les dÃ©pendances de production

# Ã‰tape 2 : Image finale
FROM node:22-alpine

WORKDIR /app

# Copie des dÃ©pendances et du code
COPY --from=builder /app/node_modules ./node_modules
COPY . .

# SÃ©curitÃ©
RUN chown -R node:node /app \
    && apk add --no-cache tini  # Pour gÃ©rer correctement les signaux
USER node

# Port exposÃ© (doit correspondre Ã  votre .env)
EXPOSE 2000

# Point d'entrÃ©e avec Tini pour Ã©viter les zombies
ENTRYPOINT ["/sbin/tini", "--"]

# Commande de dÃ©marrage (utilise la variable PORT depuis .env)
CMD node server.js




================================================
File: docker-compose.prod.yml
================================================
# services:
#   app:
#     build: .
#     container_name: dcat_backend
#     ports:
#       - "2000:2000"
#     env_file:
#       - .env
#     environment:
#       DB_HOST: postgres
#       DB_NAME: ${APP_DB_NAME:-app_db_name}
#       DB_USER: ${APP_DB_USER:-app_db_user}
#       DB_PASSWORD: ${APP_DB_PASSWORD:-app_db_password}
#     depends_on:
#       - postgres
#       - keycloak
      
#   postgres:
#     image: postgres:15-alpine
#     container_name: dcat_postgres
#     env_file: .env
#     environment:
#       POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-default_postgres_password}
#       POSTGRES_USER: postgres
#       POSTGRES_DB: postgres
#     volumes:
#       - postgres_data:/var/lib/postgresql/data
#       - ./init-db:/docker-entrypoint-initdb.d
#       - ./.env:/tmp/.env:ro
#     ports:
#       - "${DB_PORT:-5432}:5432"
#     healthcheck:
#       test: ["CMD-SHELL", "pg_isready -U postgres"]
#       interval: 5s
#       timeout: 5s
#       retries: 5

#   keycloak:
#     image: quay.io/keycloak/keycloak:26.1.4
#     container_name: keycloak
#     env_file: .env
#     environment:
#       KC_DB: postgres
#       KC_DB_URL: jdbc:postgresql://postgres:5432/${KEYCLOAK_DB_NAME:-keycloak_db}
#       KC_DB_USERNAME: ${KEYCLOAK_DB_USER:-keycloak_user}
#       KC_DB_PASSWORD: ${KEYCLOAK_DB_PASSWORD:-keycloak123}
#       KEYCLOAK_ADMIN: admin
#       KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin123}
#       KC_HOSTNAME: ${KC_HOSTNAME:-localhost}
#       KC_HTTP_ENABLED: "true"
#       KC_PROXY: edge
#     ports:
#       - "8080:8080"
#     depends_on:
#       postgres:
#         condition: service_healthy
#     command: ["start-dev"]

# volumes:
#   postgres_data:
# # networks:
# #   - dcat_network




version: '3.8'

services:
  app:
    build: .
    container_name: dcat_backend
    ports:
      - "2000:2000"
    env_file:
      - .env
    environment:
      DB_HOST: postgres
      DB_NAME: ${APP_DB_NAME:-app_db_name}
      DB_USER: ${APP_DB_USER:-app_db_user}
      DB_PASSWORD: ${APP_DB_PASSWORD:-app_db_password}
    depends_on:
      - postgres
      - keycloak
    networks:
      - dcat_network

  postgres:
    image: postgres:15-alpine
    container_name: dcat_postgres
    env_file: .env
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-default_postgres_password}
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db:/docker-entrypoint-initdb.d
      - ./.env:/tmp/.env:ro
    ports:
      - "${DB_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - dcat_network

  keycloak:
    image: quay.io/keycloak/keycloak:26.1.4
    container_name: keycloak
    env_file: .env
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/${KEYCLOAK_DB_NAME:-keycloak_db}
      KC_DB_USERNAME: ${KEYCLOAK_DB_USER:-keycloak_user}
      KC_DB_PASSWORD: ${KEYCLOAK_DB_PASSWORD:-keycloak123}
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin123}
      KC_HOSTNAME: ${KC_HOSTNAME:-localhost}
      KC_HTTPS_PORT: 443

      KC_HTTP_ENABLED: "false"
      KC_PROXY: edge
    ports:
      - "8080:8080"
    depends_on:
      postgres:
        condition: service_healthy
    command: ["start", "--hostname-strict=false", "--https-port=443"]
    # command: ["start-dev"]
    networks:
      - dcat_network

volumes:
  postgres_data:

networks:
  dcat_network:
    driver: bridge



================================================
File: docker-compose.yml
================================================
# services:
#   app:
#     build: .
#     container_name: dcat_backend
#     ports:
#       - "2000:2000"
#     env_file:
#       - .env
#     environment:
#       DB_HOST: postgres
#       DB_NAME: ${APP_DB_NAME:-app_db_name}
#       DB_USER: ${APP_DB_USER:-app_db_user}
#       DB_PASSWORD: ${APP_DB_PASSWORD:-app_db_password}
#     depends_on:
#       - postgres
#       - keycloak
      
#   postgres:
#     image: postgres:15-alpine
#     container_name: dcat_postgres
#     env_file: .env
#     environment:
#       POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-default_postgres_password}
#       POSTGRES_USER: postgres
#       POSTGRES_DB: postgres
#     volumes:
#       - postgres_data:/var/lib/postgresql/data
#       - ./init-db:/docker-entrypoint-initdb.d
#       - ./.env:/tmp/.env:ro
#     ports:
#       - "${DB_PORT:-5432}:5432"
#     healthcheck:
#       test: ["CMD-SHELL", "pg_isready -U postgres"]
#       interval: 5s
#       timeout: 5s
#       retries: 5

#   keycloak:
#     image: quay.io/keycloak/keycloak:26.1.4
#     container_name: keycloak
#     env_file: .env
#     environment:
#       KC_DB: postgres
#       KC_DB_URL: jdbc:postgresql://postgres:5432/${KEYCLOAK_DB_NAME:-keycloak_db}
#       KC_DB_USERNAME: ${KEYCLOAK_DB_USER:-keycloak_user}
#       KC_DB_PASSWORD: ${KEYCLOAK_DB_PASSWORD:-keycloak123}
#       KEYCLOAK_ADMIN: admin
#       KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin123}
#       KC_HOSTNAME: ${KC_HOSTNAME:-localhost}
#       KC_HTTP_ENABLED: "true"
#       KC_PROXY: edge
#     ports:
#       - "8080:8080"
#     depends_on:
#       postgres:
#         condition: service_healthy
#     command: ["start-dev"]

# volumes:
#   postgres_data:
# # networks:
# #   - dcat_network




version: '3.8'

services:
  app:
    build: .
    container_name: dcat_backend
    ports:
      - "2000:2000"
    env_file:
      - .env
    environment:
      DB_HOST: postgres
      DB_NAME: ${APP_DB_NAME:-app_db_name}
      DB_USER: ${APP_DB_USER:-app_db_user}
      DB_PASSWORD: ${APP_DB_PASSWORD:-app_db_password}
    depends_on:
      - postgres
      - keycloak
    networks:
      - dcat_network

  postgres:
    image: postgres:15-alpine
    container_name: dcat_postgres
    env_file: .env
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-default_postgres_password}
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db:/docker-entrypoint-initdb.d
      - ./.env:/tmp/.env:ro
    ports:
      - "${DB_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - dcat_network

  keycloak:
    image: quay.io/keycloak/keycloak:26.1.4
    container_name: keycloak
    env_file: .env
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/${KEYCLOAK_DB_NAME:-keycloak_db}
      KC_DB_USERNAME: ${KEYCLOAK_DB_USER:-keycloak_user}
      KC_DB_PASSWORD: ${KEYCLOAK_DB_PASSWORD:-keycloak123}
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin123}
      KC_HOSTNAME: ${KC_HOSTNAME:-localhost}
      # KC_HOSTNAME: ${KC_HOSTNAME_${NODE_ENV}}
      KC_HTTP_ENABLED: "true"
      KC_PROXY: edge
    ports:
      - "8080:8080"
    depends_on:
      postgres:
        condition: service_healthy
    command: ["start-dev"]
    networks:
      - dcat_network

volumes:
  postgres_data:

networks:
  dcat_network:
    driver: bridge



================================================
File: drizzle.config.js
================================================
require('dotenv').config();

module.exports = {
  schema: "./core/database/models.js",
  out: "./core/database/migrations",
  dialect: "postgresql", 
  dbCredentials: {
  url: `postgresql://${process.env.APP_DB_USER}:${process.env.APP_DB_PASSWORD}@${process.env.DB_HOST}:${process.env.DB_PORT}/${process.env.APP_DB_NAME}`
  },
  verbose: true,
  strict: true,
  ...(process.env.NODE_ENV === 'development' && {
    debug: true,
    migrationsTable: 'migrations_dev'
  })
};





================================================
File: init.sql
================================================
-- Utilisation des variables d'environnement via Docker
CREATE USER "${KEYCLOAK_DB_USER:-keycloak_user}" WITH PASSWORD '${KEYCLOAK_DB_PASSWORD:-keycloak123}';
CREATE DATABASE "${KEYCLOAK_DB_NAME:-keycloak_db}" OWNER "${KEYCLOAK_DB_USER:-keycloak_user}";

CREATE USER "${APP_DB_USER:-dcat_user}" WITH PASSWORD '${APP_DB_PASSWORD:-dcat123}';
CREATE DATABASE "${APP_DB_NAME:-dcat_db}" OWNER "${APP_DB_USER:-dcat_user}";


================================================
File: package.json
================================================
{
  "scripts": {
    "start": "nodemon server.js"
  },
  "dependencies": {
    "@keycloak/keycloak-admin-client": "^26.1.4",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "drizzle-kit": "^0.30.6",
    "drizzle-orm": "^0.41.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "helmet": "^8.1.0",
    "jose": "^6.0.10",
    "keycloak-connect": "^26.1.1",
    "multer": "^1.4.5-lts.2",
    "nodemon": "^3.1.9",
    "openid-client": "^6.4.1",
    "pg": "^8.14.1",
    "pg-promise": "^11.13.0",
    "postgres-js": "^0.1.0",
    "sequelize": "^6.37.7",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.17.0"
  }
}



================================================
File: server.js
================================================
ï»¿const express = require("express");
const path = require("path");
const helmet = require("helmet");
const { keycloak } = require("./core/auth/keycloak.config");
const { initKeycloak, protect } = require("./core/auth/middleware");
const logger = require("./core/utils/logger");
const swaggerRoutes = require('./core/utils/swagger.routes');

require("dotenv").config();

// Initialisation Express
const app = express();

// =============== MIDDLEWARES DE BASE ===============
app.use(helmet());
app.disable("x-powered-by");
app.use(express.json({ limit: "10kb" }));
app.use(express.urlencoded({ extended: true, limit: "10kb" }));

// =============== KEYCLOAK ===============
app.use(initKeycloak());

// =============== CHARGEMENT DES MODULES ===============
function loadModule(moduleName) {
  try {
    const modulePath = path.join(
      __dirname,
      "modules",
      moduleName,
      "routes",
      `${moduleName}.routes.js`
    );
    const router = require(modulePath);
    logger.info(`Module chargÃ©: ${moduleName}`);
    return router;
  } catch (error) {
    logger.error(`Ã‰chec du chargement du module ${moduleName}`, error);
    process.exit(1);
  }
}

// Swagger 
app.use('/api', swaggerRoutes);

// Chargement des modules
app.use("/api/stocks", loadModule("stocks"));
app.use("/api/users", loadModule("users"));
app.use("/api/administration", loadModule("Administration&Finance"));

// CHARGEMENT DES ENDPOINT DU MODULZ TECHNIQUES

app.use("/api/technique", loadModule("technique"));

// =============================================
// ROUTES PUBLIQUES
// =============================================

app.get("/health", (req, res) => {
  res.json({
    status: "OK",
    // auth: 'bearer-only',
    keycloak: {
      realm: keycloak.config.realm,
      clientId: keycloak.config.resource,
    },
  });
});

// Pour les fichiers
app.use("/media", express.static(path.join(process.cwd(), "media")));

// =============== ROUTES PROTÃ‰GÃ‰ES ===============
app.get("/api/protected", protect(), (req, res) => {
  res.json({
    message: "AccÃ¨s autorisÃ©",
    user: req.kauth.grant.access_token.content,
  });
});

// =============== GESTION DES ERREURS ===============
app.use((req, res) => {
  res.status(404).json({
    error: "Endpoint non trouvÃ©",
    path: req.path,
  });
});

app.use((err, req, res, next) => {
  const status = err.status || 500;
  logger.error({
    status,
    message: err.message,
    path: req.path,
    stack: process.env.NODE_ENV === "development" ? err.stack : undefined,
  });
  res.status(status).json({
    error: status === 500 ? "Erreur interne" : err.message,
  });
});

// =============================================
// DÃ‰MARRAGE DU SERVEUR
// =============================================
// const PORT = process.env.PORT || 3000;
const PORT = 2000;
app.listen(PORT, () => {
  logger.info(`Server running on port ${PORT}`);
  logger.info(`Keycloak configured for realm: ${keycloak.config.realm}`);
  logger.info("Available routes:");
  logger.info(`- GET  http://localhost:${PORT}/health`);
  logger.info(`- GET  http://localhost:${PORT}/api/technique`);
  logger.info(`- POST http://localhost:${PORT}/api/interventions (protected)`);
  logger.info(`- GET  http://localhost:${PORT}/api/stocks`);
  logger.info(
    `- POST http://localhost:${PORT}/api/stocks (protected, requires inventory-manager role)`
  );
  logger.info(`- GET  http://localhost:${PORT}/api/protected (protected)`);
  logger.info(`- ###################NODE_ENV:${process.env.NODE_ENV}########################`);

});



================================================
File: core/auth/keycloak.config.js
================================================
ï»¿const Keycloak = require('keycloak-connect');
const logger = require('../utils/logger');
require('dotenv').config();

// const keycloakConfig = {
//   realm: process.env.KEYCLOAK_REALM,
//   'auth-server-url': process.env.KEYCLOAK_URL,
//   'ssl-required': 'external',
//   resource: process.env.KEYCLOAK_CLIENT_ID,
//   'bearer-only': true,
//   'verify-token-audience': true,
//   credentials: {
//     secret: process.env.KEYCLOAK_CLIENT_SECRET
//   }
// };


const keycloakConfig = {
  realm: process.env.KEYCLOAK_REALM,
  'auth-server-url': process.env.KEYCLOAK_URL,
  'ssl-required': 'external',
  // resource: process.env.KEYCLOAK_CLIENT_ID,
  resource: process.env.KEYCLOAK_BACKEND_CLIENT_ID,
  'bearer-only': true,
  'confidential-port': 0, // Important pour les clients confidentiels
  'verify-token-audience': true,
  'use-resource-role-mappings': true, // Prend en compte les rÃ´les client
  credentials: {
    secret: process.env.KEYCLOAK_BACKEND_CLIENT_SECRET
  }
};

// Validation de la configuration
if (!process.env.KEYCLOAK_BACKEND_CLIENT_SECRET) {
  logger.error('Configuration Keycloak incomplÃ¨te : KEYCLOAK_CLIENT_SECRET manquant');
  process.exit(1);
}

const keycloak = new Keycloak({}, keycloakConfig);

module.exports = {
  keycloak,
  keycloakConfig
};


================================================
File: core/auth/middleware.js
================================================
const { keycloak } = require('./keycloak.config');
const { getKeycloakPublicKey } = require('./setupKeycloak');
const { jwtVerify } = require('jose');
const logger = require('../utils/logger');
const { db } = require('../../core/database/config');
const { employes } = require('../../core/database/models');
const { eq } = require('drizzle-orm');

// Middleware d'initialisation Keycloak
const initKeycloak = () => {
  logger.info('Middleware Keycloak initialisÃ© (mode bearer-only)');
  return keycloak.middleware();
};

// Protection de base
// const protect = (requiredRoles = []) => {
//   return [
//     keycloak.protect(),
//     async (req, res, next) => {
//       if (requiredRoles.length === 0) return next();
      
//       const token = req.kauth.grant.access_token;
//       const hasRole = requiredRoles.some(role => token.hasRole(role));
      
//       if (!hasRole) {
//         logger.warn(`AccÃ¨s refusÃ© - RÃ´les manquants`, {
//           user: token.content.sub,
//           requiredRoles,
//           actualRoles: token.content.realm_access?.roles
//         });
//         return res.status(403).json({ error: 'Permissions insuffisantes' });
//       }
//       next();
//     }
//   ];
// };




const protect = (requiredRoles = []) => {
  return [
    keycloak.protect(),
    async (req, res, next) => {
      if (requiredRoles.length === 0) return next();
      
      const token = req.kauth.grant.access_token;
      const roles = token.content.realm_access?.roles || [];
      
      const hasRole = requiredRoles.some(role => roles.includes(role));
      
      if (!hasRole) {
        logger.warn(`AccÃ¨s refusÃ© - RÃ´les manquants`, {
          user: token.content.sub,
          providedRoldes:requiredRoles,
          actualRoles: roles
        });
        return res.status(403).json({ error: 'Permissions insuffisantes' });
      }
      next();
    }
  ];
};




// const protect = (requiredRoles = []) => {
//   return [
//     keycloak.protect(),
//     async (req, res, next) => {
//       if (requiredRoles.length === 0) return next();
      
//       const token = req.kauth.grant.access_token;
      
//       // VÃ©rification amÃ©liorÃ©e des rÃ´les
//       const hasRole = requiredRoles.some(role => {
//         // VÃ©rifie d'abord les rÃ´les client
//         if (token.content.resource_access?.[keycloakConfig.resource]?.roles?.includes(role)) {
//           return true;
//         }
//         // Ensuite les rÃ´les realm
//         if (token.content.realm_access?.roles?.includes(role)) {
//           return true;
//         }
//         return false;
//       });

//       if (!hasRole) {
//         logger.warn(`AccÃ¨s refusÃ© - RÃ´les manquants`, {
//           user: token.content.sub,
//           requiredRoles,
//           clientRoles: token.content.resource_access?.[keycloakConfig.resource]?.roles,
//           realmRoles: token.content.realm_access?.roles
//         });
//         return res.status(403).json({ error: 'Permissions insuffisantes' });
//       }
//       next();
//     }
//   ];
// };

// Validation JWT autonome
const validateJWT = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ error: 'Authorization header manquant' });
  }

  try {
    const token = authHeader.split(' ')[1];
    const { payload } = await jwtVerify(token, await getKeycloakPublicKey());
    req.userToken = payload;
    next();
  } catch (error) {
    logger.error('Ã‰chec de validation JWT', error);
    res.status(401).json({ error: 'Token invalide' });
  }
};

module.exports = {
  initKeycloak,
  protect,
  validateJWT,
  keycloak
};



// const { keycloak } = require('./keycloak.config');

// // Middleware simplifiÃ© qui valide juste le token
// const protect = () => {
//   return keycloak.protect((token, request) => {
//     // Accepte tous les tokens valides
//     // Vous pouvez ajouter des vÃ©rifications basiques si besoin
//     if (!token.content.email_verified) {
//       return false; // Rejette si email non vÃ©rifiÃ©
//     }
//     return true;
//   });
// };

// // Middleware pour vÃ©rifier les rÃ´les (Ã  utiliser plus tard)
// const checkRoles = (requiredRoles = []) => {
//   return (req, res, next) => {
//     if (requiredRoles.length === 0) return next();
    
//     const token = req.kauth.grant.access_token;
//     const hasRole = requiredRoles.some(role =>
//       token.hasRole(role) ||
//       token.content.realm_access?.roles?.includes(role)
//     );

//     if (!hasRole) {
//       return res.status(403).json({ error: 'Permissions insuffisantes' });
//     }
//     next();
//   };
// };

// module.exports = {
//   initKeycloak: () => keycloak.middleware(),
//   protect,
//   checkRoles,
//   keycloak
// };


// const { getKeycloakPublicKey } = require('./setupKeycloak');
// const { jwtVerify } = require('jose');
// const logger = require('../utils/logger');

// // Validation JWT autonome simplifiÃ©e
// const validateJWT = async (req, res, next) => {
//   const authHeader = req.headers.authorization;
  
//   if (!authHeader?.startsWith('Bearer ')) {
//     return res.status(401).json({ error: 'Authorization header manquant ou invalide' });
//   }

//   try {
//     const token = authHeader.split(' ')[1];
//     const { payload } = await jwtVerify(token, await getKeycloakPublicKey());
    
//     // Stocke les infos du token dans la requÃªte
//     req.token = payload;
//     next();
//   } catch (error) {
//     logger.error('Ã‰chec de validation JWT', { 
//       error: error.message,
//       path: req.path 
//     });
    
//     const status = error.code === 'ERR_JWT_EXPIRED' ? 401 : 403;
//     res.status(status).json({ 
//       error: status === 401 ? 'Token expirÃ©' : 'Token invalide',
//       details: process.env.NODE_ENV === 'development' ? error.message : undefined
//     });
//   }
// };

// // Middleware pour vÃ©rification basique (sans rÃ´les)
// const protect = () => validateJWT;

// // Middleware pour vÃ©rification de rÃ´les (optionnel)
// const checkRoles = (requiredRoles = []) => {
//   return async (req, res, next) => {
//     await validateJWT(req, res, () => {
//       if (requiredRoles.length === 0) return next();
      
//       const hasRole = requiredRoles.some(role => 
//         req.token.resource_access?.[process.env.KEYCLOAK_CLIENT_ID]?.roles?.includes(role) ||
//         req.token.realm_access?.roles?.includes(role)
//       );

//       if (!hasRole) {
//         return res.status(403).json({ error: 'Permissions insuffisantes' });
//       }
//       next();
//     });
//   };
// };

// module.exports = {
//   validateJWT,
//   protect,
//   checkRoles
// };


================================================
File: core/auth/setupKeycloak.js
================================================
const { keycloak } = require('./keycloak.config');
const { createRemoteJWKSet } = require('jose');
const { Issuer } = require('openid-client');
const logger = require('../utils/logger');

async function getKeycloakPublicKey() {
  try {
    const issuer = await Issuer.discover(
      `${keycloak.config['auth-server-url']}/realms/${keycloak.config.realm}`
    );
    return createRemoteJWKSet(new URL(issuer.metadata.jwks_uri));
  } catch (error) {
    logger.error('Erreur de rÃ©cupÃ©ration des clÃ©s Keycloak', error);
    throw new Error('Service d\'authentification indisponible');
  }
}

module.exports = {
  getKeycloakPublicKey
};


================================================
File: core/database/config.js
================================================
const pg = require('pg');
const { drizzle } = require('drizzle-orm/node-postgres');
const schema = require('./models.js');
require('dotenv').config();

// Configuration du pool PostgreSQL
const pool = new pg.Pool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.APP_DB_USER,
  password: process.env.APP_DB_PASSWORD,
  database: process.env.APP_DB_NAME,
  ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false
});

// Test de connexion
pool.connect()
  .then(() => console.log('✅ Connected to PostgreSQL'))
  .catch(err => console.error('❌ PostgreSQL connection error:', err));

// Export en CommonJS
module.exports = {
  db: drizzle(pool, { schema }),
  pool
};


================================================
File: core/database/db.config.js
================================================
ï»¿module.exports = {
  HOST: process.env.DB_HOST || "postgres", 
  USER: process.env.DB_USER || "dcat_user",
  PASSWORD: process.env.DB_PASSWORD || "dcat_password",
  DB: process.env.DB_NAME || "dcat_db",
  dialect: "postgres",
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
};


================================================
File: core/database/migration.js
================================================
require("dotenv").config();
const { migrate } = require("drizzle-orm/node-postgres/migrator");
const { db } = require("./db.config");

(async () => {
  console.log("⏳ Migration en cours...");
  await migrate(db, { migrationsFolder: "backend/migrations" });
  console.log("✅ Migration terminée !");
  process.exit(0);
})();



================================================
File: core/database/models.js
================================================
const {
  pgTable,
  serial,
  varchar,
  integer,
  date,
  timestamp,
  decimal,
  boolean,
  text,
  time,
  primaryKey,
  foreignKey,
} = require("drizzle-orm/pg-core");

// Famille
const familles = pgTable("familles", {
  id_famille: serial("id_famille").primaryKey(),
  libelle_famille: varchar("libelle_famille", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Modele
const modeles = pgTable("modeles", {
  id_modele: serial("id_modele").primaryKey(),
  libelle_modele: varchar("libelle_modele", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Marque
const marques = pgTable("marques", {
  id_marque: serial("id_marque").primaryKey(),
  libelle_marque: varchar("libelle_marque", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Fonction
const fonctions = pgTable("fonctions", {
  id_fonction: serial("id_fonction").primaryKey(),
  nom_fonction: varchar("nom_fonction", { length: 50 }).unique(),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Employes
const employes = pgTable("employes", {
  id_employes: serial("id_employes").primaryKey(),
  keycloak_id: varchar("keycloak_id", { length: 100 }).unique(),
  nom_employes: varchar("nom_employes", { length: 50 }),
  prenom_employes: varchar("prenom_employes", { length: 75 }),
  email_employes: varchar("email_employes", { length: 100 }),
  contact_employes: varchar("contact_employes", { length: 50 }),
  adresse_employes: text("adresse_employes"),
  status_employes: varchar("status_employes", { length: 50 }),
  date_embauche_employes: date("date_embauche_employes"),
  password_employes: varchar("password_employes", { length: 255 }),
  date_de_naissance: date("date_de_naissance"),
  contrat: varchar("contrat", { length: 100 }),
  id_fonction: integer("id_fonction").references(() => fonctions.id_fonction),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Demande
const demandes = pgTable("demandes", {
  id_demandes: serial("id_demandes").primaryKey(),
  date_absence: date("date_absence"),
  status: varchar("status", { length: 50 }),
  date_retour: date("date_retour"),
  motif: text("motif"),
  type_demande: varchar("type_demande", { length: 50 }),
  durÃ©e: varchar("durÃ©e", { length: 50 }),
  heure_debut: time("heure_debut"),
  heure_fin: time("heure_fin"),
  id_employes: integer("id_employes").references(() => employes.id_employes),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Nature_document
const nature_documents = pgTable("nature_documents", {
  id_nature_document: serial("id_nature_document").primaryKey(),
  libelle: varchar("libelle", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// EntitÃ©
const entites = pgTable("entites", {
  id_entite: serial("id_entite").primaryKey(),
  denomination: varchar("denomination", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Client_en_ligne
const clients_en_ligne = pgTable("clients_en_ligne", {
  id_client: serial("id_client").primaryKey(),
  nom_complet: varchar("nom_complet", { length: 50 }),
  email: varchar("email", { length: 50 }).unique(),
  mot_de_passe: varchar("mot_de_passe", { length: 255 }),
  numero_de_telephone: varchar("numero_de_telephone", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Commande
const commandes = pgTable("commandes", {
  id_commande: serial("id_commande").primaryKey(),
  date_de_commande: date("date_de_commande"),
  etat_commande: varchar("etat_commande", { length: 50 }),
  date_livraison: date("date_livraison"),
  lieu_de_livraison: varchar("lieu_de_livraison", { length: 50 }),
  mode_de_paiement: varchar("mode_de_paiement", { length: 50 }),
  id_client: integer("id_client").references(() => clients_en_ligne.id_client),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Type_produit
const type_produits = pgTable("type_produits", {
  id_type_produit: serial("id_type_produit").primaryKey(),
  libelle: varchar("libelle", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// CatÃ©gorie
const categories = pgTable("categories", {
  id_categorie: serial("id_categorie").primaryKey(),
  libelle: varchar("libelle", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Projet
const projets = pgTable("projets", {
  id_projet: serial("id_projet").primaryKey(),
  nom_projet: varchar("nom_projet", { length: 50 }).notNull(),
  type_projet: varchar("type_projet", { length: 50 }).notNull(),
  devis_estimatif: decimal("devis_estimatif", {
    precision: 10,
    scale: 2,
  }),
  date_debut: date("date_debut"),
  date_fin: date("date_fin"),
  duree_prevu_projet: varchar("duree_prevu_projet", { length: 50 }),
  description_projet: text("description_projet"),
  etat: varchar("etat", { length: 50 }),
  lieu: varchar("lieu", { length: 50 }),
  responsable: varchar("responsable", { length: 50 }),
  site: varchar("site", { length: 50 }),
  id_famille: integer("id_famille").references(() => familles.id_famille),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Tache
const taches = pgTable("taches", {
  id_tache: serial("id_tache").primaryKey(),
  nom_tache: varchar("nom_tache", { length: 50 }),
  desc_tache: text("desc_tache"),
  statut: varchar("statut", { length: 50 }),
  date_debut: date("date_debut"),
  date_fin: date("date_fin"),
  priorite: varchar("priorite", { length: 50 }),
  id_projet: integer("id_projet").references(() => projets.id_projet),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Prestation
const prestations = pgTable("prestations", {
  id_prestation: serial("id_prestation").primaryKey(),
  date_de_maintenance: date("date_de_maintenance"),
  type_de_maintenance: varchar("type_de_maintenance", { length: 50 }),
  description: text("description"),
  responsable: varchar("responsable", { length: 50 }),
  pieces_remplacees: text("pieces_remplacees"),
  cout_maintenance: decimal("cout_maintenance", {
    precision: 10,
    scale: 2,
  }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Livrable
const livrables = pgTable("livrables", {
  id_livrable: serial("id_livrable").primaryKey(),
  libelle_livrable: varchar("libelle_livrable", { length: 100 }),
  date: date("date"),
  realisations: text("realisations"),
  reserves: text("reserves"),
  approbation: text("approbation"),
  recommandation: text("recommandation"),
  id_projet: integer("id_projet").references(() => projets.id_projet),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Moyens_de_travail
const moyens_de_travail = pgTable("moyens_de_travail", {
  id_moyens_de_travail: serial("id_moyens_de_travail").primaryKey(),
  denomination: varchar("denomination", { length: 50 }),
  date_acquisition: date("date_acquisition"),
  section: varchar("section", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Service
const services = pgTable("services", {
  id_service: serial("id_service").primaryKey(),
  titre_service: varchar("titre_service", { length: 50 }),
  image: varchar("image", { length: 255 }),
  description: text("description"),
  id_employes: integer("id_employes").references(() => employes.id_employes),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Affiche
const affiches = pgTable("affiches", {
  id_affiche: serial("id_affiche").primaryKey(),
  image: varchar("image", { length: 255 }),
  titre: varchar("titre", { length: 50 }),
  description: text("description"),
  id_employes: integer("id_employes").references(() => employes.id_employes),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Produit
const produits = pgTable("produits", {
  id_produit: serial("id_produit").primaryKey(), // ClÃ© primaire simple
  code_produit: varchar("code_produit", { length: 100 }).unique(),
  desi_produit: varchar("desi_produit", { length: 50 }),
  desc_produit: text("desc_produit"),
  image_produit: text("image_produit"),
  qte_produit: integer("qte_produit").default(0),
  emplacement_produit: text("emplacement"),
  caracteristiques_produit: text("caracteristiques"),
  prix_produit: decimal("prix_produit", {
    precision: 10,
    scale: 2,
  }),
  id_categorie: integer("id_categorie").references(
    () => categories.id_categorie
  ),
  id_type_produit: integer("id_type_produit").references(
    () => type_produits.id_type_produit
  ),
  id_modele: integer("id_modele").references(() => modeles.id_modele),
  id_famille: integer("id_famille").references(() => familles.id_famille),
  id_marque: integer("id_marque").references(() => marques.id_marque),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Partenaire
const partenaires = pgTable("partenaires", {
  id_partenaire: serial("id_partenaire").primaryKey(),
  nom_partenaire: varchar("nom_partenaire", { length: 50 }),
  telephone_partenaire: varchar("telephone_partenaire", {
    length: 50,
  }),
  email_partenaire: varchar("email_partenaire", { length: 100 }).unique(),
  specialite: varchar("specialite", { length: 50 }),
  localisation: varchar("localisation", { length: 50 }),
  type_partenaire: varchar("type_partenaire", { length: 50 }),
  statut: varchar("statut", { length: 50 }),
  id_entite: integer("id_entite").references(() => entites.id_entite),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Contrat
const contrats = pgTable("contrats", {
  id_contrat: serial("id_contrat").primaryKey(),
  nom_contrat: varchar("nom_contrat", { length: 50 }),
  duree_contrat: varchar("duree_contrat", { length: 50 }),
  date_debut: date("date_debut"),
  date_fin: date("date_fin"),
  reference: varchar("reference", { length: 50 }),
  type_de_contrat: varchar("type_de_contrat", { length: 50 }),
  statut: varchar("statut", { length: 50 }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Interlocuteur
const interlocuteurs = pgTable("interlocuteurs", {
  id_interlocuteur: serial("id_interlocuteur").primaryKey(),
  nom_interlocuteur: varchar("nom_interlocuteur", { length: 50 }),
  prenom_interlocuteur: varchar("prenom_interlocuteur", {
    length: 75,
  }),
  contact_interlocuteur: varchar("contact_interlocuteur", {
    length: 50,
  }),
  email_interlocuteur: varchar("email_interlocuteur", { length: 100 }).unique(),
  fonction_interlocuteur: varchar("fonction_interlocuteur", {
    length: 50,
  }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Maintenance
const maintenances = pgTable("maintenances", {
  id_maintenance: serial("id_maintenance").primaryKey(),
  recurrence: varchar("recurrence", { length: 50 }),
  operations: text("operations"),
  recommandations: text("recommandations"),
  type_maintenance: varchar("type_maintenance", { length: 50 }),
  autre_intervenant: varchar("autre_intervenant", { length: 50 }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Livraison
const livraisons = pgTable("livraisons", {
  id_livraison: serial("id_livraison").primaryKey(),
  reference_livraison: varchar("reference_livraison", { length: 75 }),
  frais_divers: decimal("frais_divers", { precision: 10, scale: 2 }),
  periode_achat: varchar("periode_achat", { length: 50 }),
  prix_achat: decimal("prix_achat", { precision: 10, scale: 2 }),
  prix_de_revient: decimal("prix_de_revient", {
    precision: 10,
    scale: 2,
  }),
  prix_de_vente: decimal("prix_de_vente", {
    precision: 10,
    scale: 2,
  }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Intervention
const interventions = pgTable("interventions", {
  id_intervention: serial("id_intervention").primaryKey(),
  date_intervention: date("date_intervention"),
  cause_defaillance: varchar("cause_defaillance", { length: 50 }),
  rapport_intervention: text("rapport_intervention"),
  type_intervention: varchar("type_intervention", { length: 50 }),
  type_defaillance: varchar("type_defaillance", { length: 50 }),
  duree: varchar("duree", { length: 50 }),
  lieu: varchar("lieu", { length: 100 }),
  statut_intervention: varchar("statut_intervention", { length: 50 }),
  recommandation: text("recommandation"),
  probleme_signale: varchar("probleme_signale", { length: 50 }),
  mode_intervention: varchar("mode_intervention", { length: 50 }),
  detail_cause: text("detail_cause"),
  type: varchar("type", { length: 50 }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  id_contrat: integer("id_contrat").references(() => contrats.id_contrat),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Documents
const documents = pgTable("documents", {
  id_documents: serial("id_documents").primaryKey(),
  libelle_document: varchar("libelle_document", { length: 100 }),
  classification_document: varchar("classification_document", {
    length: 50,
  }),
  date_document: varchar("date_document", { length: 50 }),
  lien_document: varchar("lien_document", { length: 255 }),
  etat_document: varchar("etat_document", { length: 50 }),
  id_livrable: integer("id_livrable").references(() => livrables.id_livrable),
  id_projet: integer("id_projet").references(() => projets.id_projet),
  id_demandes: integer("id_demandes").references(() => demandes.id_demandes),
  id_contrat: integer("id_contrat").references(() => contrats.id_contrat),
  id_employes: integer("id_employes").references(() => employes.id_employes),
  id_intervention: integer("id_intervention").references(
    () => interventions.id_intervention
  ),
  id_nature_document: integer("id_nature_document").references(
    () => nature_documents.id_nature_document
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Exemplaire_produit
const exemplaires = pgTable("exemplaires", {
  id_exemplaire: serial("id_exemplaire").primaryKey(),
  num_serie: varchar("num_serie", { length: 50 }),
  date_entree: date("date_entree"),
  etat_exemplaire: varchar("etat_exemplaire", { length: 75 }).default(
    "Disponible"
  ), //"Vendu", "Disponible", "Utilisation", "En maintenance", "Endommage", "Reserve"
  id_livraison: integer("id_livraison").references(
    () => livraisons.id_livraison
  ),
  id_produit: integer("id_produit").references(() => produits.id_produit), // RÃ©fÃ©rence simplifiÃ©e
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Sortie_exemplaire
const sortie_exemplaires = pgTable("sortie_exemplaires", {
  id_sortie_exemplaire: serial("id_sortie_exemplaire").primaryKey(),
  type_sortie: varchar("type_sortie", { length: 50 }),
  reference_id: integer("reference_id"),
  date_sortie: date("date_sortie"),
  id_exemplaire: integer("id_exemplaire").references(
    () => exemplaires.id_exemplaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Tables d'association

const partenaire_projets = pgTable(
  "partenaire_projets",
  {
    id_projet: integer("id_projet")
      .notNull()
      .references(() => projets.id_projet),
    id_partenaire: integer("id_partenaire")
      .notNull()
      .references(() => partenaires.id_partenaire),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_projet, table.id_partenaire] }),
  })
);

const intervention_employes = pgTable(
  "intervention_employes",
  {
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    id_intervention: integer("id_intervention")
      .notNull()
      .references(() => interventions.id_intervention),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_employes, table.id_intervention] }),
  })
);

const partenaire_commandes = pgTable(
  "partenaire_commandes",
  {
    id_partenaire: integer("id_partenaire")
      .notNull()
      .references(() => partenaires.id_partenaire),
    id_commande: integer("id_commande")
      .notNull()
      .references(() => commandes.id_commande),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_partenaire, table.id_commande] }),
  })
);

const employe_entrer_exemplaires = pgTable(
  "employe_entrer_exemplaires",
  {
    id_exemplaire: integer("id_exemplaire")
      .notNull()
      .references(() => exemplaires.id_exemplaire),
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    etat_apres: varchar("etat_apres", { length: 50 }).notNull(),
    date_de_retour: date("date_de_retour").notNull(),
    commentaire: text("commentaire"),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_exemplaire, table.id_employes] }),
  })
);

const employe_prestations = pgTable(
  "employe_prestations",
  {
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    id_prestation: integer("id_prestation")
      .notNull()
      .references(() => prestations.id_prestation),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_employes, table.id_prestation] }),
  })
);

const intervention_taches = pgTable(
  "intervention_taches",
  {
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    id_tache: integer("id_tache")
      .notNull()
      .references(() => taches.id_tache),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_employes, table.id_tache] }),
  })
);

const employe_sortir_exemplaires = pgTable(
  "employe_sortir_exemplaires",
  {
    id_exemplaire: integer("id_exemplaire")
      .notNull()
      .references(() => exemplaires.id_exemplaire),
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    but_usage: varchar("but_usage", { length: 50 }).notNull(),
    etat_avant: varchar("etat_avant", { length: 50 }).notNull(),
    date_de_sortie: date("date_de_sortie").notNull(),
    site_intervention: varchar("site_intervention", { length: 100 }).notNull(),
    commentaire: text("commentaire"),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_exemplaire, table.id_employes] }),
  })
);

const maintenance_employes = pgTable(
  "maintenance_employes",
  {
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    id_maintenance: integer("id_maintenance")
      .notNull()
      .references(() => maintenances.id_maintenance),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_employes, table.id_maintenance] }),
  })
);

const maintenance_moyens_travail = pgTable(
  "maintenance_moyens_travail",
  {
    id_moyens_de_travail: integer("id_moyens_de_travail")
      .notNull()
      .references(() => moyens_de_travail.id_moyens_de_travail),
    id_maintenance: integer("id_maintenance")
      .notNull()
      .references(() => maintenances.id_maintenance),
    date_maintenance: date("date_maintenance"),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({
      columns: [table.id_moyens_de_travail, table.id_maintenance],
    }),
  })
);

const commande_produits = pgTable(
  "commande_produits",
  {
    id_commande: integer("id_commande")
      .notNull()
      .references(() => commandes.id_commande),
    id_produit: integer("id_produit")
      .notNull()
      .references(() => produits.id_produit),
    quantite: integer("quantite"),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({
      columns: [table.id_commande, table.id_produit],
    }),
  })
);

module.exports = {
  familles,
  modeles,
  marques,
  fonctions,
  employes,
  demandes,
  nature_documents,
  entites,
  clients_en_ligne,
  commandes,
  type_produits,
  categories,
  projets,
  taches,
  prestations,
  livrables,
  moyens_de_travail,
  services,
  affiches,
  produits,
  partenaires,
  contrats,
  interlocuteurs,
  maintenances,
  livraisons,
  documents,
  interventions,
  exemplaires,
  sortie_exemplaires,
  partenaire_projets,
  intervention_employes,
  partenaire_commandes,
  employe_entrer_exemplaires,
  employe_prestations,
  intervention_taches,
  employe_sortir_exemplaires,
  maintenance_employes,
  maintenance_moyens_travail,
  commande_produits,
};



================================================
File: core/database/test-db.js
================================================
// test-db.js
const { db } = require('./config');
const { intervention } = require('./models');

(async () => {
  try {
    console.log("Testing database connection...");
    const result = await db.select().from(intervention).limit(1);
    console.log("Success! Found", result.length, "interventions");
  } catch (err) {
    console.error("Database test failed:", err);
  } finally {
    process.exit();
  }
})();


================================================
File: core/database/migrations/0000_cloudy_fat_cobra.sql
================================================
CREATE TABLE "familles" (
	"id_famille" serial PRIMARY KEY NOT NULL,
	"libelle_famille" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "modeles" (
	"id_modele" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "marques" (
	"id_marque" serial PRIMARY KEY NOT NULL,
	"libelle_marque" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "fonctions" (
	"id_fonction" serial PRIMARY KEY NOT NULL,
	"nom_fonction" varchar(50),
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "fonctions_nom_fonction_unique" UNIQUE("nom_fonction")
);
--> statement-breakpoint
CREATE TABLE "employes" (
	"id_employes" serial PRIMARY KEY NOT NULL,
	"keycloak_id" varchar(100),
	"nom_employes" varchar(50),
	"prenom_employes" varchar(75),
	"email_employes" varchar(100),
	"contact_employes" varchar(50),
	"adresse_employes" text,
	"status_employes" varchar(50),
	"date_embauche_employes" date,
	"password_employes" varchar(255),
	"date_de_naissance" date,
	"contrat" varchar(100),
	"id_fonction" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "employes_keycloak_id_unique" UNIQUE("keycloak_id")
);
--> statement-breakpoint
CREATE TABLE "demandes" (
	"id_demandes" serial PRIMARY KEY NOT NULL,
	"date_absence" date,
	"status" varchar(50),
	"date_retour" date,
	"motif" text,
	"type_demande" varchar(50),
	"durÃ©e" varchar(50),
	"heure_debut" time,
	"heure_fin" time,
	"id_employes" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "nature_documents" (
	"id_nature_document" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(50),
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "entites" (
	"id_entite" serial PRIMARY KEY NOT NULL,
	"denomination" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "clients_en_ligne" (
	"id_client" serial PRIMARY KEY NOT NULL,
	"nom_complet" varchar(50) NOT NULL,
	"email" varchar(50) NOT NULL,
	"mot_de_passe" varchar(255) NOT NULL,
	"numero_de_telephone" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "clients_en_ligne_email_unique" UNIQUE("email")
);
--> statement-breakpoint
CREATE TABLE "commandes" (
	"id_commande" serial PRIMARY KEY NOT NULL,
	"date_de_commande" timestamp NOT NULL,
	"etat_commande" varchar(50) NOT NULL,
	"date_livraison" timestamp,
	"lieu_de_livraison" varchar(50) NOT NULL,
	"mode_de_paiement" varchar(50) NOT NULL,
	"id_client" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "type_produits" (
	"id_type_produit" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "categories" (
	"id_categorie" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "projets" (
	"id_projet" serial PRIMARY KEY NOT NULL,
	"nom_projet" varchar(50) NOT NULL,
	"type_projet" varchar(50) NOT NULL,
	"devis_estimatif" numeric(10, 2) NOT NULL,
	"date_debut" date NOT NULL,
	"date_fin" date NOT NULL,
	"duree_prevu_projet" varchar(50) NOT NULL,
	"description_projet" text NOT NULL,
	"etat" varchar(50) NOT NULL,
	"lieu" varchar(50) NOT NULL,
	"responsable" varchar(50) NOT NULL,
	"site" varchar(50) NOT NULL,
	"id_famille" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "taches" (
	"id_tache" serial PRIMARY KEY NOT NULL,
	"nom_tache" varchar(50) NOT NULL,
	"desc_tache" text NOT NULL,
	"statut" varchar(50) NOT NULL,
	"date_debut" timestamp NOT NULL,
	"date_fin" timestamp,
	"priorite" varchar(50) NOT NULL,
	"id_projet" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "prestations" (
	"id_prestation" serial PRIMARY KEY NOT NULL,
	"date_de_maintenance" timestamp NOT NULL,
	"type_de_maintenance" varchar(50) NOT NULL,
	"description" text NOT NULL,
	"responsable" varchar(50) NOT NULL,
	"pieces_remplacees" text NOT NULL,
	"cout_maintenance" numeric(10, 2) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "livrables" (
	"id_livrable" serial PRIMARY KEY NOT NULL,
	"date" date NOT NULL,
	"realisations" text NOT NULL,
	"reserves" text,
	"approbation" boolean NOT NULL,
	"recommandation" text,
	"id_projet" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "moyens_de_travail" (
	"id_moyens_de_travail" serial PRIMARY KEY NOT NULL,
	"denomination" varchar(50) NOT NULL,
	"date_acquisition" date NOT NULL,
	"section" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "services" (
	"id_service" serial PRIMARY KEY NOT NULL,
	"titre_service" varchar(50) NOT NULL,
	"image" varchar(255) NOT NULL,
	"description" text NOT NULL,
	"id_employes" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "affiches" (
	"id_affiche" serial PRIMARY KEY NOT NULL,
	"image" varchar(255) NOT NULL,
	"titre" varchar(50) NOT NULL,
	"description" text NOT NULL,
	"id_employes" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "produits" (
	"id_produit" serial PRIMARY KEY NOT NULL,
	"code_produit" varchar(100) NOT NULL,
	"desi_produit" varchar(50) NOT NULL,
	"desc_produit" text NOT NULL,
	"image_produit" varchar(255) NOT NULL,
	"qte_produit" integer NOT NULL,
	"emplacement" varchar(50) NOT NULL,
	"id_categorie" integer NOT NULL,
	"id_type_produit" integer NOT NULL,
	"id_modele" integer NOT NULL,
	"id_famille" integer NOT NULL,
	"id_marque" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "produits_code_produit_unique" UNIQUE("code_produit")
);
--> statement-breakpoint
CREATE TABLE "partenaires" (
	"id_partenaire" serial PRIMARY KEY NOT NULL,
	"nom_partenaire" varchar(50) NOT NULL,
	"telephone_partenaire" varchar(50) NOT NULL,
	"email_partenaire" varchar(100) NOT NULL,
	"specialite" varchar(50) NOT NULL,
	"localisation" varchar(50) NOT NULL,
	"type_partenaire" varchar(50) NOT NULL,
	"statut" varchar(50) NOT NULL,
	"id_entite" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "partenaires_email_partenaire_unique" UNIQUE("email_partenaire")
);
--> statement-breakpoint
CREATE TABLE "contrats" (
	"id_contrat" serial PRIMARY KEY NOT NULL,
	"nom_contrat" varchar(50) NOT NULL,
	"duree_contrat" varchar(50) NOT NULL,
	"date_debut" date NOT NULL,
	"date_fin" date NOT NULL,
	"reference" varchar(50) NOT NULL,
	"type_de_contrat" varchar(50) NOT NULL,
	"statut" varchar(50) NOT NULL,
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "interlocuteurs" (
	"id_interlocuteur" serial PRIMARY KEY NOT NULL,
	"nom_interlocuteur" varchar(50) NOT NULL,
	"prenom_interlocuteur" varchar(75) NOT NULL,
	"contact_interlocuteur" varchar(50) NOT NULL,
	"email_interlocuteur" varchar(100) NOT NULL,
	"fonction_interlocuteur" varchar(50) NOT NULL,
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "interlocuteurs_email_interlocuteur_unique" UNIQUE("email_interlocuteur")
);
--> statement-breakpoint
CREATE TABLE "maintenances" (
	"id_maintenance" serial PRIMARY KEY NOT NULL,
	"recurrence" varchar(50) NOT NULL,
	"operations" text NOT NULL,
	"recommandations" text NOT NULL,
	"type_maintenance" varchar(50) NOT NULL,
	"autre_intervenant" varchar(50),
	"id_partenaire" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "livraisons" (
	"id_livraison" serial PRIMARY KEY NOT NULL,
	"frais_divers" numeric(10, 2),
	"periode_achat" varchar(50),
	"prix_achat" numeric(10, 2),
	"prix_de_revient" numeric(10, 2),
	"prix_de_vente" numeric(10, 2),
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "documents" (
	"id_documents" serial PRIMARY KEY NOT NULL,
	"libelle_document" varchar(100) NOT NULL,
	"classification_document" varchar(50) NOT NULL,
	"lien_document" varchar(255) NOT NULL,
	"etat_document" varchar(50) NOT NULL,
	"id_livrable" integer,
	"id_projet" integer,
	"id_demandes" integer,
	"id_contrat" integer,
	"id_employes" integer,
	"id_nature_document" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "interventions" (
	"id_intervention" serial PRIMARY KEY NOT NULL,
	"date_" timestamp NOT NULL,
	"cause_defaillance" varchar(50) NOT NULL,
	"rapport_intervention" text NOT NULL,
	"type_intervention" varchar(50) NOT NULL,
	"type_defaillance" varchar(50) NOT NULL,
	"duree" varchar(50) NOT NULL,
	"lieu" varchar(100) NOT NULL,
	"statut_intervention" varchar(50) NOT NULL,
	"recommandation" text NOT NULL,
	"probleme_signale" varchar(50) NOT NULL,
	"mode_intervention" varchar(50) NOT NULL,
	"detail_cause" text NOT NULL,
	"type" varchar(50) NOT NULL,
	"id_partenaire" integer NOT NULL,
	"id_contrat" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "exemplaires" (
	"id_exemplaire" serial PRIMARY KEY NOT NULL,
	"num_serie" varchar(50) NOT NULL,
	"prix_exemplaire" numeric(10, 2) NOT NULL,
	"date_entree" date NOT NULL,
	"etat_vente" boolean NOT NULL,
	"id_commande" integer,
	"id_livraison" integer NOT NULL,
	"id_produit" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "sortie_exemplaires" (
	"id_sortie_exemplaire" serial PRIMARY KEY NOT NULL,
	"type_sortie" varchar(50) NOT NULL,
	"reference_id" integer,
	"date_sortie" timestamp NOT NULL,
	"id_exemplaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "collaborer" (
	"id_projet" integer NOT NULL,
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "collaborer_id_projet_id_partenaire_pk" PRIMARY KEY("id_projet","id_partenaire")
);
--> statement-breakpoint
CREATE TABLE "intervention_employes" (
	"id_employes" integer NOT NULL,
	"id_intervention" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "intervention_employes_id_employes_id_intervention_pk" PRIMARY KEY("id_employes","id_intervention")
);
--> statement-breakpoint
CREATE TABLE "partenaire_commandes" (
	"id_partenaire" integer NOT NULL,
	"id_commande" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "partenaire_commandes_id_partenaire_id_commande_pk" PRIMARY KEY("id_partenaire","id_commande")
);
--> statement-breakpoint
CREATE TABLE "faire_entrer" (
	"id_exemplaire" integer NOT NULL,
	"id_employes" integer NOT NULL,
	"etat_apres" varchar(50) NOT NULL,
	"date_de_retour" timestamp NOT NULL,
	"commentaire" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "faire_entrer_id_exemplaire_id_employes_pk" PRIMARY KEY("id_exemplaire","id_employes")
);
--> statement-breakpoint
CREATE TABLE "effectuer" (
	"id_employes" integer NOT NULL,
	"id_prestation" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "effectuer_id_employes_id_prestation_pk" PRIMARY KEY("id_employes","id_prestation")
);
--> statement-breakpoint
CREATE TABLE "intervention_taches" (
	"id_employes" integer NOT NULL,
	"id_tache" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "intervention_taches_id_employes_id_tache_pk" PRIMARY KEY("id_employes","id_tache")
);
--> statement-breakpoint
CREATE TABLE "faire_sortir" (
	"id_exemplaire" integer NOT NULL,
	"id_employes" integer NOT NULL,
	"but_usage" varchar(50) NOT NULL,
	"etat_avant" varchar(50) NOT NULL,
	"date_de_sortie" timestamp NOT NULL,
	"site_intervention" varchar(100) NOT NULL,
	"commentaire" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "faire_sortir_id_exemplaire_id_employes_pk" PRIMARY KEY("id_exemplaire","id_employes")
);
--> statement-breakpoint
CREATE TABLE "maintenance_employes" (
	"id_employes" integer NOT NULL,
	"id_maintenance" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "maintenance_employes_id_employes_id_maintenance_pk" PRIMARY KEY("id_employes","id_maintenance")
);
--> statement-breakpoint
CREATE TABLE "maintenance_moyens_travail" (
	"id_moyens_de_travail" integer NOT NULL,
	"id_maintenance" integer NOT NULL,
	"date_maintenance" timestamp NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk" PRIMARY KEY("id_moyens_de_travail","id_maintenance")
);
--> statement-breakpoint
ALTER TABLE "employes" ADD CONSTRAINT "employes_id_fonction_fonctions_id_fonction_fk" FOREIGN KEY ("id_fonction") REFERENCES "public"."fonctions"("id_fonction") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "demandes" ADD CONSTRAINT "demandes_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "commandes" ADD CONSTRAINT "commandes_id_client_clients_en_ligne_id_client_fk" FOREIGN KEY ("id_client") REFERENCES "public"."clients_en_ligne"("id_client") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "projets" ADD CONSTRAINT "projets_id_famille_familles_id_famille_fk" FOREIGN KEY ("id_famille") REFERENCES "public"."familles"("id_famille") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "taches" ADD CONSTRAINT "taches_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "livrables" ADD CONSTRAINT "livrables_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "services" ADD CONSTRAINT "services_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "affiches" ADD CONSTRAINT "affiches_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_categorie_categories_id_categorie_fk" FOREIGN KEY ("id_categorie") REFERENCES "public"."categories"("id_categorie") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_type_produit_type_produits_id_type_produit_fk" FOREIGN KEY ("id_type_produit") REFERENCES "public"."type_produits"("id_type_produit") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_modele_modeles_id_modele_fk" FOREIGN KEY ("id_modele") REFERENCES "public"."modeles"("id_modele") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_famille_familles_id_famille_fk" FOREIGN KEY ("id_famille") REFERENCES "public"."familles"("id_famille") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_marque_marques_id_marque_fk" FOREIGN KEY ("id_marque") REFERENCES "public"."marques"("id_marque") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "partenaires" ADD CONSTRAINT "partenaires_id_entite_entites_id_entite_fk" FOREIGN KEY ("id_entite") REFERENCES "public"."entites"("id_entite") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "contrats" ADD CONSTRAINT "contrats_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "interlocuteurs" ADD CONSTRAINT "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenances" ADD CONSTRAINT "maintenances_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "livraisons" ADD CONSTRAINT "livraisons_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_livrable_livrables_id_livrable_fk" FOREIGN KEY ("id_livrable") REFERENCES "public"."livrables"("id_livrable") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_demandes_demandes_id_demandes_fk" FOREIGN KEY ("id_demandes") REFERENCES "public"."demandes"("id_demandes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_contrat_contrats_id_contrat_fk" FOREIGN KEY ("id_contrat") REFERENCES "public"."contrats"("id_contrat") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_nature_document_nature_documents_id_nature_document_fk" FOREIGN KEY ("id_nature_document") REFERENCES "public"."nature_documents"("id_nature_document") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "interventions" ADD CONSTRAINT "interventions_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "interventions" ADD CONSTRAINT "interventions_id_contrat_contrats_id_contrat_fk" FOREIGN KEY ("id_contrat") REFERENCES "public"."contrats"("id_contrat") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaires" ADD CONSTRAINT "exemplaires_id_commande_commandes_id_commande_fk" FOREIGN KEY ("id_commande") REFERENCES "public"."commandes"("id_commande") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaires" ADD CONSTRAINT "exemplaires_id_livraison_livraisons_id_livraison_fk" FOREIGN KEY ("id_livraison") REFERENCES "public"."livraisons"("id_livraison") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaires" ADD CONSTRAINT "exemplaires_id_produit_produits_id_produit_fk" FOREIGN KEY ("id_produit") REFERENCES "public"."produits"("id_produit") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sortie_exemplaires" ADD CONSTRAINT "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk" FOREIGN KEY ("id_exemplaire") REFERENCES "public"."exemplaires"("id_exemplaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "collaborer" ADD CONSTRAINT "collaborer_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "collaborer" ADD CONSTRAINT "collaborer_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention_employes" ADD CONSTRAINT "intervention_employes_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention_employes" ADD CONSTRAINT "intervention_employes_id_intervention_interventions_id_intervention_fk" FOREIGN KEY ("id_intervention") REFERENCES "public"."interventions"("id_intervention") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "partenaire_commandes" ADD CONSTRAINT "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "partenaire_commandes" ADD CONSTRAINT "partenaire_commandes_id_commande_commandes_id_commande_fk" FOREIGN KEY ("id_commande") REFERENCES "public"."commandes"("id_commande") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "faire_entrer" ADD CONSTRAINT "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk" FOREIGN KEY ("id_exemplaire") REFERENCES "public"."exemplaires"("id_exemplaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "faire_entrer" ADD CONSTRAINT "faire_entrer_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "effectuer" ADD CONSTRAINT "effectuer_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "effectuer" ADD CONSTRAINT "effectuer_id_prestation_prestations_id_prestation_fk" FOREIGN KEY ("id_prestation") REFERENCES "public"."prestations"("id_prestation") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention_taches" ADD CONSTRAINT "intervention_taches_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention_taches" ADD CONSTRAINT "intervention_taches_id_tache_taches_id_tache_fk" FOREIGN KEY ("id_tache") REFERENCES "public"."taches"("id_tache") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "faire_sortir" ADD CONSTRAINT "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk" FOREIGN KEY ("id_exemplaire") REFERENCES "public"."exemplaires"("id_exemplaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "faire_sortir" ADD CONSTRAINT "faire_sortir_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenance_employes" ADD CONSTRAINT "maintenance_employes_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenance_employes" ADD CONSTRAINT "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk" FOREIGN KEY ("id_maintenance") REFERENCES "public"."maintenances"("id_maintenance") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenance_moyens_travail" ADD CONSTRAINT "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk" FOREIGN KEY ("id_moyens_de_travail") REFERENCES "public"."moyens_de_travail"("id_moyens_de_travail") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenance_moyens_travail" ADD CONSTRAINT "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk" FOREIGN KEY ("id_maintenance") REFERENCES "public"."maintenances"("id_maintenance") ON DELETE no action ON UPDATE no action;


================================================
File: core/database/migrations/0001_worthless_venus.sql
================================================
ALTER TABLE "exemplaires" ADD COLUMN "etat_exemplaire" varchar(75) NOT NULL;--> statement-breakpoint
ALTER TABLE "exemplaires" DROP COLUMN "etat_vente";


================================================
File: core/database/migrations/meta/0000_snapshot.json
================================================
{
  "id": "32e964f9-448d-4e96-b687-83b35d419eff",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.familles": {
      "name": "familles",
      "schema": "",
      "columns": {
        "id_famille": {
          "name": "id_famille",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_famille": {
          "name": "libelle_famille",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.modeles": {
      "name": "modeles",
      "schema": "",
      "columns": {
        "id_modele": {
          "name": "id_modele",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.marques": {
      "name": "marques",
      "schema": "",
      "columns": {
        "id_marque": {
          "name": "id_marque",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_marque": {
          "name": "libelle_marque",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.fonctions": {
      "name": "fonctions",
      "schema": "",
      "columns": {
        "id_fonction": {
          "name": "id_fonction",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_fonction": {
          "name": "nom_fonction",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "fonctions_nom_fonction_unique": {
          "name": "fonctions_nom_fonction_unique",
          "nullsNotDistinct": false,
          "columns": [
            "nom_fonction"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employes": {
      "name": "employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "keycloak_id": {
          "name": "keycloak_id",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "nom_employes": {
          "name": "nom_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prenom_employes": {
          "name": "prenom_employes",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": false
        },
        "email_employes": {
          "name": "email_employes",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "contact_employes": {
          "name": "contact_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "adresse_employes": {
          "name": "adresse_employes",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status_employes": {
          "name": "status_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_embauche_employes": {
          "name": "date_embauche_employes",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "password_employes": {
          "name": "password_employes",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "date_de_naissance": {
          "name": "date_de_naissance",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "contrat": {
          "name": "contrat",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "id_fonction": {
          "name": "id_fonction",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employes_id_fonction_fonctions_id_fonction_fk": {
          "name": "employes_id_fonction_fonctions_id_fonction_fk",
          "tableFrom": "employes",
          "tableTo": "fonctions",
          "columnsFrom": [
            "id_fonction"
          ],
          "columnsTo": [
            "id_fonction"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "employes_keycloak_id_unique": {
          "name": "employes_keycloak_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "keycloak_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.demandes": {
      "name": "demandes",
      "schema": "",
      "columns": {
        "id_demandes": {
          "name": "id_demandes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_absence": {
          "name": "date_absence",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_retour": {
          "name": "date_retour",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "motif": {
          "name": "motif",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type_demande": {
          "name": "type_demande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "durÃ©e": {
          "name": "durÃ©e",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "heure_debut": {
          "name": "heure_debut",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "heure_fin": {
          "name": "heure_fin",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "demandes_id_employes_employes_id_employes_fk": {
          "name": "demandes_id_employes_employes_id_employes_fk",
          "tableFrom": "demandes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.nature_documents": {
      "name": "nature_documents",
      "schema": "",
      "columns": {
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.entites": {
      "name": "entites",
      "schema": "",
      "columns": {
        "id_entite": {
          "name": "id_entite",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.clients_en_ligne": {
      "name": "clients_en_ligne",
      "schema": "",
      "columns": {
        "id_client": {
          "name": "id_client",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_complet": {
          "name": "nom_complet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mot_de_passe": {
          "name": "mot_de_passe",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "numero_de_telephone": {
          "name": "numero_de_telephone",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "clients_en_ligne_email_unique": {
          "name": "clients_en_ligne_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.commandes": {
      "name": "commandes",
      "schema": "",
      "columns": {
        "id_commande": {
          "name": "id_commande",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_commande": {
          "name": "date_de_commande",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "etat_commande": {
          "name": "etat_commande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_livraison": {
          "name": "date_livraison",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "lieu_de_livraison": {
          "name": "lieu_de_livraison",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mode_de_paiement": {
          "name": "mode_de_paiement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_client": {
          "name": "id_client",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "commandes_id_client_clients_en_ligne_id_client_fk": {
          "name": "commandes_id_client_clients_en_ligne_id_client_fk",
          "tableFrom": "commandes",
          "tableTo": "clients_en_ligne",
          "columnsFrom": [
            "id_client"
          ],
          "columnsTo": [
            "id_client"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.type_produits": {
      "name": "type_produits",
      "schema": "",
      "columns": {
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.categories": {
      "name": "categories",
      "schema": "",
      "columns": {
        "id_categorie": {
          "name": "id_categorie",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.projets": {
      "name": "projets",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_projet": {
          "name": "nom_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_projet": {
          "name": "type_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "devis_estimatif": {
          "name": "devis_estimatif",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "duree_prevu_projet": {
          "name": "duree_prevu_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description_projet": {
          "name": "description_projet",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "etat": {
          "name": "etat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "site": {
          "name": "site",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "projets_id_famille_familles_id_famille_fk": {
          "name": "projets_id_famille_familles_id_famille_fk",
          "tableFrom": "projets",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.taches": {
      "name": "taches",
      "schema": "",
      "columns": {
        "id_tache": {
          "name": "id_tache",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_tache": {
          "name": "nom_tache",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "desc_tache": {
          "name": "desc_tache",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "priorite": {
          "name": "priorite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "taches_id_projet_projets_id_projet_fk": {
          "name": "taches_id_projet_projets_id_projet_fk",
          "tableFrom": "taches",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.prestations": {
      "name": "prestations",
      "schema": "",
      "columns": {
        "id_prestation": {
          "name": "id_prestation",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_maintenance": {
          "name": "date_de_maintenance",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "type_de_maintenance": {
          "name": "type_de_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "pieces_remplacees": {
          "name": "pieces_remplacees",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "cout_maintenance": {
          "name": "cout_maintenance",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livrables": {
      "name": "livrables",
      "schema": "",
      "columns": {
        "id_livrable": {
          "name": "id_livrable",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "realisations": {
          "name": "realisations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "reserves": {
          "name": "reserves",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "approbation": {
          "name": "approbation",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livrables_id_projet_projets_id_projet_fk": {
          "name": "livrables_id_projet_projets_id_projet_fk",
          "tableFrom": "livrables",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.moyens_de_travail": {
      "name": "moyens_de_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_acquisition": {
          "name": "date_acquisition",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "section": {
          "name": "section",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.services": {
      "name": "services",
      "schema": "",
      "columns": {
        "id_service": {
          "name": "id_service",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "titre_service": {
          "name": "titre_service",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "services_id_employes_employes_id_employes_fk": {
          "name": "services_id_employes_employes_id_employes_fk",
          "tableFrom": "services",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.affiches": {
      "name": "affiches",
      "schema": "",
      "columns": {
        "id_affiche": {
          "name": "id_affiche",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "titre": {
          "name": "titre",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "affiches_id_employes_employes_id_employes_fk": {
          "name": "affiches_id_employes_employes_id_employes_fk",
          "tableFrom": "affiches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.produits": {
      "name": "produits",
      "schema": "",
      "columns": {
        "id_produit": {
          "name": "id_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "code_produit": {
          "name": "code_produit",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "desi_produit": {
          "name": "desi_produit",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "desc_produit": {
          "name": "desc_produit",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "image_produit": {
          "name": "image_produit",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "qte_produit": {
          "name": "qte_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "emplacement": {
          "name": "emplacement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_categorie": {
          "name": "id_categorie",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_modele": {
          "name": "id_modele",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_marque": {
          "name": "id_marque",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "produits_id_categorie_categories_id_categorie_fk": {
          "name": "produits_id_categorie_categories_id_categorie_fk",
          "tableFrom": "produits",
          "tableTo": "categories",
          "columnsFrom": [
            "id_categorie"
          ],
          "columnsTo": [
            "id_categorie"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_type_produit_type_produits_id_type_produit_fk": {
          "name": "produits_id_type_produit_type_produits_id_type_produit_fk",
          "tableFrom": "produits",
          "tableTo": "type_produits",
          "columnsFrom": [
            "id_type_produit"
          ],
          "columnsTo": [
            "id_type_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_modele_modeles_id_modele_fk": {
          "name": "produits_id_modele_modeles_id_modele_fk",
          "tableFrom": "produits",
          "tableTo": "modeles",
          "columnsFrom": [
            "id_modele"
          ],
          "columnsTo": [
            "id_modele"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_famille_familles_id_famille_fk": {
          "name": "produits_id_famille_familles_id_famille_fk",
          "tableFrom": "produits",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_marque_marques_id_marque_fk": {
          "name": "produits_id_marque_marques_id_marque_fk",
          "tableFrom": "produits",
          "tableTo": "marques",
          "columnsFrom": [
            "id_marque"
          ],
          "columnsTo": [
            "id_marque"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "produits_code_produit_unique": {
          "name": "produits_code_produit_unique",
          "nullsNotDistinct": false,
          "columns": [
            "code_produit"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaires": {
      "name": "partenaires",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_partenaire": {
          "name": "nom_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "telephone_partenaire": {
          "name": "telephone_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email_partenaire": {
          "name": "email_partenaire",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "specialite": {
          "name": "specialite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "localisation": {
          "name": "localisation",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_partenaire": {
          "name": "type_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_entite": {
          "name": "id_entite",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaires_id_entite_entites_id_entite_fk": {
          "name": "partenaires_id_entite_entites_id_entite_fk",
          "tableFrom": "partenaires",
          "tableTo": "entites",
          "columnsFrom": [
            "id_entite"
          ],
          "columnsTo": [
            "id_entite"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "partenaires_email_partenaire_unique": {
          "name": "partenaires_email_partenaire_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_partenaire"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contrats": {
      "name": "contrats",
      "schema": "",
      "columns": {
        "id_contrat": {
          "name": "id_contrat",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_contrat": {
          "name": "nom_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "duree_contrat": {
          "name": "duree_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "reference": {
          "name": "reference",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_de_contrat": {
          "name": "type_de_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contrats_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "contrats_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "contrats",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interlocuteurs": {
      "name": "interlocuteurs",
      "schema": "",
      "columns": {
        "id_interlocuteur": {
          "name": "id_interlocuteur",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_interlocuteur": {
          "name": "nom_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "prenom_interlocuteur": {
          "name": "prenom_interlocuteur",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": true
        },
        "contact_interlocuteur": {
          "name": "contact_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email_interlocuteur": {
          "name": "email_interlocuteur",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "fonction_interlocuteur": {
          "name": "fonction_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interlocuteurs",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "interlocuteurs_email_interlocuteur_unique": {
          "name": "interlocuteurs_email_interlocuteur_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_interlocuteur"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenances": {
      "name": "maintenances",
      "schema": "",
      "columns": {
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "recurrence": {
          "name": "recurrence",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "operations": {
          "name": "operations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "recommandations": {
          "name": "recommandations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type_maintenance": {
          "name": "type_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "autre_intervenant": {
          "name": "autre_intervenant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenances_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "maintenances_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "maintenances",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livraisons": {
      "name": "livraisons",
      "schema": "",
      "columns": {
        "id_livraison": {
          "name": "id_livraison",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "frais_divers": {
          "name": "frais_divers",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "periode_achat": {
          "name": "periode_achat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_achat": {
          "name": "prix_achat",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_revient": {
          "name": "prix_de_revient",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_vente": {
          "name": "prix_de_vente",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livraisons_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "livraisons_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "livraisons",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.documents": {
      "name": "documents",
      "schema": "",
      "columns": {
        "id_documents": {
          "name": "id_documents",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_document": {
          "name": "libelle_document",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "classification_document": {
          "name": "classification_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lien_document": {
          "name": "lien_document",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_document": {
          "name": "etat_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_livrable": {
          "name": "id_livrable",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_demandes": {
          "name": "id_demandes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "documents_id_livrable_livrables_id_livrable_fk": {
          "name": "documents_id_livrable_livrables_id_livrable_fk",
          "tableFrom": "documents",
          "tableTo": "livrables",
          "columnsFrom": [
            "id_livrable"
          ],
          "columnsTo": [
            "id_livrable"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_projet_projets_id_projet_fk": {
          "name": "documents_id_projet_projets_id_projet_fk",
          "tableFrom": "documents",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_demandes_demandes_id_demandes_fk": {
          "name": "documents_id_demandes_demandes_id_demandes_fk",
          "tableFrom": "documents",
          "tableTo": "demandes",
          "columnsFrom": [
            "id_demandes"
          ],
          "columnsTo": [
            "id_demandes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_contrat_contrats_id_contrat_fk": {
          "name": "documents_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "documents",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_employes_employes_id_employes_fk": {
          "name": "documents_id_employes_employes_id_employes_fk",
          "tableFrom": "documents",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_nature_document_nature_documents_id_nature_document_fk": {
          "name": "documents_id_nature_document_nature_documents_id_nature_document_fk",
          "tableFrom": "documents",
          "tableTo": "nature_documents",
          "columnsFrom": [
            "id_nature_document"
          ],
          "columnsTo": [
            "id_nature_document"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interventions": {
      "name": "interventions",
      "schema": "",
      "columns": {
        "id_intervention": {
          "name": "id_intervention",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_": {
          "name": "date_",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "cause_defaillance": {
          "name": "cause_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "rapport_intervention": {
          "name": "rapport_intervention",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type_intervention": {
          "name": "type_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_defaillance": {
          "name": "type_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "duree": {
          "name": "duree",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "statut_intervention": {
          "name": "statut_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "probleme_signale": {
          "name": "probleme_signale",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mode_intervention": {
          "name": "mode_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "detail_cause": {
          "name": "detail_cause",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interventions_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interventions_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interventions",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "interventions_id_contrat_contrats_id_contrat_fk": {
          "name": "interventions_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "interventions",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.exemplaires": {
      "name": "exemplaires",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "num_serie": {
          "name": "num_serie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "prix_exemplaire": {
          "name": "prix_exemplaire",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "date_entree": {
          "name": "date_entree",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "etat_vente": {
          "name": "etat_vente",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_livraison": {
          "name": "id_livraison",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_produit": {
          "name": "id_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "exemplaires_id_commande_commandes_id_commande_fk": {
          "name": "exemplaires_id_commande_commandes_id_commande_fk",
          "tableFrom": "exemplaires",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_livraison_livraisons_id_livraison_fk": {
          "name": "exemplaires_id_livraison_livraisons_id_livraison_fk",
          "tableFrom": "exemplaires",
          "tableTo": "livraisons",
          "columnsFrom": [
            "id_livraison"
          ],
          "columnsTo": [
            "id_livraison"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_produit_produits_id_produit_fk": {
          "name": "exemplaires_id_produit_produits_id_produit_fk",
          "tableFrom": "exemplaires",
          "tableTo": "produits",
          "columnsFrom": [
            "id_produit"
          ],
          "columnsTo": [
            "id_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.sortie_exemplaires": {
      "name": "sortie_exemplaires",
      "schema": "",
      "columns": {
        "id_sortie_exemplaire": {
          "name": "id_sortie_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "type_sortie": {
          "name": "type_sortie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "reference_id": {
          "name": "reference_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "date_sortie": {
          "name": "date_sortie",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "sortie_exemplaires",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.collaborer": {
      "name": "collaborer",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "collaborer_id_projet_projets_id_projet_fk": {
          "name": "collaborer_id_projet_projets_id_projet_fk",
          "tableFrom": "collaborer",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "collaborer_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "collaborer_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "collaborer",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "collaborer_id_projet_id_partenaire_pk": {
          "name": "collaborer_id_projet_id_partenaire_pk",
          "columns": [
            "id_projet",
            "id_partenaire"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_employes": {
      "name": "intervention_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_intervention": {
          "name": "id_intervention",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_employes_id_employes_employes_id_employes_fk": {
          "name": "intervention_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_employes_id_intervention_interventions_id_intervention_fk": {
          "name": "intervention_employes_id_intervention_interventions_id_intervention_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "interventions",
          "columnsFrom": [
            "id_intervention"
          ],
          "columnsTo": [
            "id_intervention"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_employes_id_employes_id_intervention_pk": {
          "name": "intervention_employes_id_employes_id_intervention_pk",
          "columns": [
            "id_employes",
            "id_intervention"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaire_commandes": {
      "name": "partenaire_commandes",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "partenaire_commandes_id_commande_commandes_id_commande_fk": {
          "name": "partenaire_commandes_id_commande_commandes_id_commande_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "partenaire_commandes_id_partenaire_id_commande_pk": {
          "name": "partenaire_commandes_id_partenaire_id_commande_pk",
          "columns": [
            "id_partenaire",
            "id_commande"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.faire_entrer": {
      "name": "faire_entrer",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "etat_apres": {
          "name": "etat_apres",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_retour": {
          "name": "date_de_retour",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "faire_entrer",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "faire_entrer_id_employes_employes_id_employes_fk": {
          "name": "faire_entrer_id_employes_employes_id_employes_fk",
          "tableFrom": "faire_entrer",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "faire_entrer_id_exemplaire_id_employes_pk": {
          "name": "faire_entrer_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.effectuer": {
      "name": "effectuer",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_prestation": {
          "name": "id_prestation",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "effectuer_id_employes_employes_id_employes_fk": {
          "name": "effectuer_id_employes_employes_id_employes_fk",
          "tableFrom": "effectuer",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "effectuer_id_prestation_prestations_id_prestation_fk": {
          "name": "effectuer_id_prestation_prestations_id_prestation_fk",
          "tableFrom": "effectuer",
          "tableTo": "prestations",
          "columnsFrom": [
            "id_prestation"
          ],
          "columnsTo": [
            "id_prestation"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "effectuer_id_employes_id_prestation_pk": {
          "name": "effectuer_id_employes_id_prestation_pk",
          "columns": [
            "id_employes",
            "id_prestation"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_taches": {
      "name": "intervention_taches",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_tache": {
          "name": "id_tache",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_taches_id_employes_employes_id_employes_fk": {
          "name": "intervention_taches_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_taches_id_tache_taches_id_tache_fk": {
          "name": "intervention_taches_id_tache_taches_id_tache_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "taches",
          "columnsFrom": [
            "id_tache"
          ],
          "columnsTo": [
            "id_tache"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_taches_id_employes_id_tache_pk": {
          "name": "intervention_taches_id_employes_id_tache_pk",
          "columns": [
            "id_employes",
            "id_tache"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.faire_sortir": {
      "name": "faire_sortir",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "but_usage": {
          "name": "but_usage",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_avant": {
          "name": "etat_avant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_sortie": {
          "name": "date_de_sortie",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "site_intervention": {
          "name": "site_intervention",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "faire_sortir",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "faire_sortir_id_employes_employes_id_employes_fk": {
          "name": "faire_sortir_id_employes_employes_id_employes_fk",
          "tableFrom": "faire_sortir",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "faire_sortir_id_exemplaire_id_employes_pk": {
          "name": "faire_sortir_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_employes": {
      "name": "maintenance_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_employes_id_employes_employes_id_employes_fk": {
          "name": "maintenance_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_employes_id_employes_id_maintenance_pk": {
          "name": "maintenance_employes_id_employes_id_maintenance_pk",
          "columns": [
            "id_employes",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_moyens_travail": {
      "name": "maintenance_moyens_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "date_maintenance": {
          "name": "date_maintenance",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "moyens_de_travail",
          "columnsFrom": [
            "id_moyens_de_travail"
          ],
          "columnsTo": [
            "id_moyens_de_travail"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk",
          "columns": [
            "id_moyens_de_travail",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
File: core/database/migrations/meta/0001_snapshot.json
================================================
{
  "id": "5d9a7c7a-2c2d-41c3-bb75-5f22ab0d0204",
  "prevId": "32e964f9-448d-4e96-b687-83b35d419eff",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.familles": {
      "name": "familles",
      "schema": "",
      "columns": {
        "id_famille": {
          "name": "id_famille",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_famille": {
          "name": "libelle_famille",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.modeles": {
      "name": "modeles",
      "schema": "",
      "columns": {
        "id_modele": {
          "name": "id_modele",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.marques": {
      "name": "marques",
      "schema": "",
      "columns": {
        "id_marque": {
          "name": "id_marque",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_marque": {
          "name": "libelle_marque",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.fonctions": {
      "name": "fonctions",
      "schema": "",
      "columns": {
        "id_fonction": {
          "name": "id_fonction",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_fonction": {
          "name": "nom_fonction",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "fonctions_nom_fonction_unique": {
          "name": "fonctions_nom_fonction_unique",
          "nullsNotDistinct": false,
          "columns": [
            "nom_fonction"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employes": {
      "name": "employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "keycloak_id": {
          "name": "keycloak_id",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "nom_employes": {
          "name": "nom_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prenom_employes": {
          "name": "prenom_employes",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": false
        },
        "email_employes": {
          "name": "email_employes",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "contact_employes": {
          "name": "contact_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "adresse_employes": {
          "name": "adresse_employes",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status_employes": {
          "name": "status_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_embauche_employes": {
          "name": "date_embauche_employes",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "password_employes": {
          "name": "password_employes",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "date_de_naissance": {
          "name": "date_de_naissance",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "contrat": {
          "name": "contrat",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "id_fonction": {
          "name": "id_fonction",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employes_id_fonction_fonctions_id_fonction_fk": {
          "name": "employes_id_fonction_fonctions_id_fonction_fk",
          "tableFrom": "employes",
          "tableTo": "fonctions",
          "columnsFrom": [
            "id_fonction"
          ],
          "columnsTo": [
            "id_fonction"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "employes_keycloak_id_unique": {
          "name": "employes_keycloak_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "keycloak_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.demandes": {
      "name": "demandes",
      "schema": "",
      "columns": {
        "id_demandes": {
          "name": "id_demandes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_absence": {
          "name": "date_absence",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_retour": {
          "name": "date_retour",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "motif": {
          "name": "motif",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type_demande": {
          "name": "type_demande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "durÃ©e": {
          "name": "durÃ©e",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "heure_debut": {
          "name": "heure_debut",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "heure_fin": {
          "name": "heure_fin",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "demandes_id_employes_employes_id_employes_fk": {
          "name": "demandes_id_employes_employes_id_employes_fk",
          "tableFrom": "demandes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.nature_documents": {
      "name": "nature_documents",
      "schema": "",
      "columns": {
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.entites": {
      "name": "entites",
      "schema": "",
      "columns": {
        "id_entite": {
          "name": "id_entite",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.clients_en_ligne": {
      "name": "clients_en_ligne",
      "schema": "",
      "columns": {
        "id_client": {
          "name": "id_client",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_complet": {
          "name": "nom_complet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mot_de_passe": {
          "name": "mot_de_passe",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "numero_de_telephone": {
          "name": "numero_de_telephone",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "clients_en_ligne_email_unique": {
          "name": "clients_en_ligne_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.commandes": {
      "name": "commandes",
      "schema": "",
      "columns": {
        "id_commande": {
          "name": "id_commande",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_commande": {
          "name": "date_de_commande",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "etat_commande": {
          "name": "etat_commande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_livraison": {
          "name": "date_livraison",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "lieu_de_livraison": {
          "name": "lieu_de_livraison",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mode_de_paiement": {
          "name": "mode_de_paiement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_client": {
          "name": "id_client",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "commandes_id_client_clients_en_ligne_id_client_fk": {
          "name": "commandes_id_client_clients_en_ligne_id_client_fk",
          "tableFrom": "commandes",
          "tableTo": "clients_en_ligne",
          "columnsFrom": [
            "id_client"
          ],
          "columnsTo": [
            "id_client"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.type_produits": {
      "name": "type_produits",
      "schema": "",
      "columns": {
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.categories": {
      "name": "categories",
      "schema": "",
      "columns": {
        "id_categorie": {
          "name": "id_categorie",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.projets": {
      "name": "projets",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_projet": {
          "name": "nom_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_projet": {
          "name": "type_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "devis_estimatif": {
          "name": "devis_estimatif",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "duree_prevu_projet": {
          "name": "duree_prevu_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description_projet": {
          "name": "description_projet",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "etat": {
          "name": "etat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "site": {
          "name": "site",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "projets_id_famille_familles_id_famille_fk": {
          "name": "projets_id_famille_familles_id_famille_fk",
          "tableFrom": "projets",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.taches": {
      "name": "taches",
      "schema": "",
      "columns": {
        "id_tache": {
          "name": "id_tache",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_tache": {
          "name": "nom_tache",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "desc_tache": {
          "name": "desc_tache",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "priorite": {
          "name": "priorite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "taches_id_projet_projets_id_projet_fk": {
          "name": "taches_id_projet_projets_id_projet_fk",
          "tableFrom": "taches",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.prestations": {
      "name": "prestations",
      "schema": "",
      "columns": {
        "id_prestation": {
          "name": "id_prestation",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_maintenance": {
          "name": "date_de_maintenance",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "type_de_maintenance": {
          "name": "type_de_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "pieces_remplacees": {
          "name": "pieces_remplacees",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "cout_maintenance": {
          "name": "cout_maintenance",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livrables": {
      "name": "livrables",
      "schema": "",
      "columns": {
        "id_livrable": {
          "name": "id_livrable",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "realisations": {
          "name": "realisations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "reserves": {
          "name": "reserves",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "approbation": {
          "name": "approbation",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livrables_id_projet_projets_id_projet_fk": {
          "name": "livrables_id_projet_projets_id_projet_fk",
          "tableFrom": "livrables",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.moyens_de_travail": {
      "name": "moyens_de_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_acquisition": {
          "name": "date_acquisition",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "section": {
          "name": "section",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.services": {
      "name": "services",
      "schema": "",
      "columns": {
        "id_service": {
          "name": "id_service",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "titre_service": {
          "name": "titre_service",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "services_id_employes_employes_id_employes_fk": {
          "name": "services_id_employes_employes_id_employes_fk",
          "tableFrom": "services",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.affiches": {
      "name": "affiches",
      "schema": "",
      "columns": {
        "id_affiche": {
          "name": "id_affiche",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "titre": {
          "name": "titre",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "affiches_id_employes_employes_id_employes_fk": {
          "name": "affiches_id_employes_employes_id_employes_fk",
          "tableFrom": "affiches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.produits": {
      "name": "produits",
      "schema": "",
      "columns": {
        "id_produit": {
          "name": "id_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "code_produit": {
          "name": "code_produit",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "desi_produit": {
          "name": "desi_produit",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "desc_produit": {
          "name": "desc_produit",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "image_produit": {
          "name": "image_produit",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "qte_produit": {
          "name": "qte_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "emplacement": {
          "name": "emplacement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_categorie": {
          "name": "id_categorie",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_modele": {
          "name": "id_modele",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_marque": {
          "name": "id_marque",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "produits_id_categorie_categories_id_categorie_fk": {
          "name": "produits_id_categorie_categories_id_categorie_fk",
          "tableFrom": "produits",
          "tableTo": "categories",
          "columnsFrom": [
            "id_categorie"
          ],
          "columnsTo": [
            "id_categorie"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_type_produit_type_produits_id_type_produit_fk": {
          "name": "produits_id_type_produit_type_produits_id_type_produit_fk",
          "tableFrom": "produits",
          "tableTo": "type_produits",
          "columnsFrom": [
            "id_type_produit"
          ],
          "columnsTo": [
            "id_type_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_modele_modeles_id_modele_fk": {
          "name": "produits_id_modele_modeles_id_modele_fk",
          "tableFrom": "produits",
          "tableTo": "modeles",
          "columnsFrom": [
            "id_modele"
          ],
          "columnsTo": [
            "id_modele"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_famille_familles_id_famille_fk": {
          "name": "produits_id_famille_familles_id_famille_fk",
          "tableFrom": "produits",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_marque_marques_id_marque_fk": {
          "name": "produits_id_marque_marques_id_marque_fk",
          "tableFrom": "produits",
          "tableTo": "marques",
          "columnsFrom": [
            "id_marque"
          ],
          "columnsTo": [
            "id_marque"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "produits_code_produit_unique": {
          "name": "produits_code_produit_unique",
          "nullsNotDistinct": false,
          "columns": [
            "code_produit"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaires": {
      "name": "partenaires",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_partenaire": {
          "name": "nom_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "telephone_partenaire": {
          "name": "telephone_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email_partenaire": {
          "name": "email_partenaire",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "specialite": {
          "name": "specialite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "localisation": {
          "name": "localisation",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_partenaire": {
          "name": "type_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_entite": {
          "name": "id_entite",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaires_id_entite_entites_id_entite_fk": {
          "name": "partenaires_id_entite_entites_id_entite_fk",
          "tableFrom": "partenaires",
          "tableTo": "entites",
          "columnsFrom": [
            "id_entite"
          ],
          "columnsTo": [
            "id_entite"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "partenaires_email_partenaire_unique": {
          "name": "partenaires_email_partenaire_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_partenaire"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contrats": {
      "name": "contrats",
      "schema": "",
      "columns": {
        "id_contrat": {
          "name": "id_contrat",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_contrat": {
          "name": "nom_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "duree_contrat": {
          "name": "duree_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "reference": {
          "name": "reference",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_de_contrat": {
          "name": "type_de_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contrats_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "contrats_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "contrats",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interlocuteurs": {
      "name": "interlocuteurs",
      "schema": "",
      "columns": {
        "id_interlocuteur": {
          "name": "id_interlocuteur",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_interlocuteur": {
          "name": "nom_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "prenom_interlocuteur": {
          "name": "prenom_interlocuteur",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": true
        },
        "contact_interlocuteur": {
          "name": "contact_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email_interlocuteur": {
          "name": "email_interlocuteur",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "fonction_interlocuteur": {
          "name": "fonction_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interlocuteurs",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "interlocuteurs_email_interlocuteur_unique": {
          "name": "interlocuteurs_email_interlocuteur_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_interlocuteur"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenances": {
      "name": "maintenances",
      "schema": "",
      "columns": {
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "recurrence": {
          "name": "recurrence",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "operations": {
          "name": "operations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "recommandations": {
          "name": "recommandations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type_maintenance": {
          "name": "type_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "autre_intervenant": {
          "name": "autre_intervenant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenances_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "maintenances_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "maintenances",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livraisons": {
      "name": "livraisons",
      "schema": "",
      "columns": {
        "id_livraison": {
          "name": "id_livraison",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "frais_divers": {
          "name": "frais_divers",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "periode_achat": {
          "name": "periode_achat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_achat": {
          "name": "prix_achat",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_revient": {
          "name": "prix_de_revient",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_vente": {
          "name": "prix_de_vente",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livraisons_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "livraisons_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "livraisons",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.documents": {
      "name": "documents",
      "schema": "",
      "columns": {
        "id_documents": {
          "name": "id_documents",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_document": {
          "name": "libelle_document",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "classification_document": {
          "name": "classification_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lien_document": {
          "name": "lien_document",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_document": {
          "name": "etat_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_livrable": {
          "name": "id_livrable",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_demandes": {
          "name": "id_demandes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "documents_id_livrable_livrables_id_livrable_fk": {
          "name": "documents_id_livrable_livrables_id_livrable_fk",
          "tableFrom": "documents",
          "tableTo": "livrables",
          "columnsFrom": [
            "id_livrable"
          ],
          "columnsTo": [
            "id_livrable"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_projet_projets_id_projet_fk": {
          "name": "documents_id_projet_projets_id_projet_fk",
          "tableFrom": "documents",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_demandes_demandes_id_demandes_fk": {
          "name": "documents_id_demandes_demandes_id_demandes_fk",
          "tableFrom": "documents",
          "tableTo": "demandes",
          "columnsFrom": [
            "id_demandes"
          ],
          "columnsTo": [
            "id_demandes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_contrat_contrats_id_contrat_fk": {
          "name": "documents_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "documents",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_employes_employes_id_employes_fk": {
          "name": "documents_id_employes_employes_id_employes_fk",
          "tableFrom": "documents",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_nature_document_nature_documents_id_nature_document_fk": {
          "name": "documents_id_nature_document_nature_documents_id_nature_document_fk",
          "tableFrom": "documents",
          "tableTo": "nature_documents",
          "columnsFrom": [
            "id_nature_document"
          ],
          "columnsTo": [
            "id_nature_document"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interventions": {
      "name": "interventions",
      "schema": "",
      "columns": {
        "id_intervention": {
          "name": "id_intervention",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_": {
          "name": "date_",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "cause_defaillance": {
          "name": "cause_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "rapport_intervention": {
          "name": "rapport_intervention",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type_intervention": {
          "name": "type_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_defaillance": {
          "name": "type_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "duree": {
          "name": "duree",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "statut_intervention": {
          "name": "statut_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "probleme_signale": {
          "name": "probleme_signale",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mode_intervention": {
          "name": "mode_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "detail_cause": {
          "name": "detail_cause",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interventions_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interventions_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interventions",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "interventions_id_contrat_contrats_id_contrat_fk": {
          "name": "interventions_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "interventions",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.exemplaires": {
      "name": "exemplaires",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "num_serie": {
          "name": "num_serie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "prix_exemplaire": {
          "name": "prix_exemplaire",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "date_entree": {
          "name": "date_entree",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "etat_exemplaire": {
          "name": "etat_exemplaire",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_livraison": {
          "name": "id_livraison",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_produit": {
          "name": "id_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "exemplaires_id_commande_commandes_id_commande_fk": {
          "name": "exemplaires_id_commande_commandes_id_commande_fk",
          "tableFrom": "exemplaires",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_livraison_livraisons_id_livraison_fk": {
          "name": "exemplaires_id_livraison_livraisons_id_livraison_fk",
          "tableFrom": "exemplaires",
          "tableTo": "livraisons",
          "columnsFrom": [
            "id_livraison"
          ],
          "columnsTo": [
            "id_livraison"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_produit_produits_id_produit_fk": {
          "name": "exemplaires_id_produit_produits_id_produit_fk",
          "tableFrom": "exemplaires",
          "tableTo": "produits",
          "columnsFrom": [
            "id_produit"
          ],
          "columnsTo": [
            "id_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.sortie_exemplaires": {
      "name": "sortie_exemplaires",
      "schema": "",
      "columns": {
        "id_sortie_exemplaire": {
          "name": "id_sortie_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "type_sortie": {
          "name": "type_sortie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "reference_id": {
          "name": "reference_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "date_sortie": {
          "name": "date_sortie",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "sortie_exemplaires",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.collaborer": {
      "name": "collaborer",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "collaborer_id_projet_projets_id_projet_fk": {
          "name": "collaborer_id_projet_projets_id_projet_fk",
          "tableFrom": "collaborer",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "collaborer_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "collaborer_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "collaborer",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "collaborer_id_projet_id_partenaire_pk": {
          "name": "collaborer_id_projet_id_partenaire_pk",
          "columns": [
            "id_projet",
            "id_partenaire"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_employes": {
      "name": "intervention_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_intervention": {
          "name": "id_intervention",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_employes_id_employes_employes_id_employes_fk": {
          "name": "intervention_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_employes_id_intervention_interventions_id_intervention_fk": {
          "name": "intervention_employes_id_intervention_interventions_id_intervention_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "interventions",
          "columnsFrom": [
            "id_intervention"
          ],
          "columnsTo": [
            "id_intervention"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_employes_id_employes_id_intervention_pk": {
          "name": "intervention_employes_id_employes_id_intervention_pk",
          "columns": [
            "id_employes",
            "id_intervention"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaire_commandes": {
      "name": "partenaire_commandes",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "partenaire_commandes_id_commande_commandes_id_commande_fk": {
          "name": "partenaire_commandes_id_commande_commandes_id_commande_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "partenaire_commandes_id_partenaire_id_commande_pk": {
          "name": "partenaire_commandes_id_partenaire_id_commande_pk",
          "columns": [
            "id_partenaire",
            "id_commande"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.faire_entrer": {
      "name": "faire_entrer",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "etat_apres": {
          "name": "etat_apres",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_retour": {
          "name": "date_de_retour",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "faire_entrer",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "faire_entrer_id_employes_employes_id_employes_fk": {
          "name": "faire_entrer_id_employes_employes_id_employes_fk",
          "tableFrom": "faire_entrer",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "faire_entrer_id_exemplaire_id_employes_pk": {
          "name": "faire_entrer_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.effectuer": {
      "name": "effectuer",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_prestation": {
          "name": "id_prestation",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "effectuer_id_employes_employes_id_employes_fk": {
          "name": "effectuer_id_employes_employes_id_employes_fk",
          "tableFrom": "effectuer",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "effectuer_id_prestation_prestations_id_prestation_fk": {
          "name": "effectuer_id_prestation_prestations_id_prestation_fk",
          "tableFrom": "effectuer",
          "tableTo": "prestations",
          "columnsFrom": [
            "id_prestation"
          ],
          "columnsTo": [
            "id_prestation"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "effectuer_id_employes_id_prestation_pk": {
          "name": "effectuer_id_employes_id_prestation_pk",
          "columns": [
            "id_employes",
            "id_prestation"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_taches": {
      "name": "intervention_taches",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_tache": {
          "name": "id_tache",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_taches_id_employes_employes_id_employes_fk": {
          "name": "intervention_taches_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_taches_id_tache_taches_id_tache_fk": {
          "name": "intervention_taches_id_tache_taches_id_tache_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "taches",
          "columnsFrom": [
            "id_tache"
          ],
          "columnsTo": [
            "id_tache"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_taches_id_employes_id_tache_pk": {
          "name": "intervention_taches_id_employes_id_tache_pk",
          "columns": [
            "id_employes",
            "id_tache"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.faire_sortir": {
      "name": "faire_sortir",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "but_usage": {
          "name": "but_usage",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_avant": {
          "name": "etat_avant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_sortie": {
          "name": "date_de_sortie",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "site_intervention": {
          "name": "site_intervention",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "faire_sortir",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "faire_sortir_id_employes_employes_id_employes_fk": {
          "name": "faire_sortir_id_employes_employes_id_employes_fk",
          "tableFrom": "faire_sortir",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "faire_sortir_id_exemplaire_id_employes_pk": {
          "name": "faire_sortir_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_employes": {
      "name": "maintenance_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_employes_id_employes_employes_id_employes_fk": {
          "name": "maintenance_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_employes_id_employes_id_maintenance_pk": {
          "name": "maintenance_employes_id_employes_id_maintenance_pk",
          "columns": [
            "id_employes",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_moyens_travail": {
      "name": "maintenance_moyens_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "date_maintenance": {
          "name": "date_maintenance",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "moyens_de_travail",
          "columnsFrom": [
            "id_moyens_de_travail"
          ],
          "columnsTo": [
            "id_moyens_de_travail"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk",
          "columns": [
            "id_moyens_de_travail",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
File: core/database/migrations/meta/_journal.json
================================================
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1745405309311,
      "tag": "0000_cloudy_fat_cobra",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "7",
      "when": 1745409313787,
      "tag": "0001_worthless_venus",
      "breakpoints": true
    }
  ]
}


================================================
File: core/utils/logger.js
================================================
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

// Fonction pour formatter les messages d'erreur
logger.formatError = (error) => {
  if (error instanceof Error) {
    return {
      message: error.message,
      stack: error.stack,
      ...error
    };
  }
  return error;
};

module.exports = logger;


================================================
File: core/utils/swagger.js
================================================
// const swaggerJSDoc = require('swagger-jsdoc');

// const swaggerDefinition = {
//   openapi: '3.0.0',
//   info: {
//     title: 'API Documentation',
//     version: '1.0.0',
//     description: 'Documentation de l\'API',
//   },
//   servers: [
//     {
//       url: 'http://localhost:2000',
//       description: 'Serveur de dÃ©veloppement',
//     },
//   ],
//   tags: [
//     {
//       name: 'Utilisateurs',
//       description: 'Endpoints pour les utilisateurs',
//     },
//     {
//       name: 'Stocks',
//       description: 'Endpoints pour les stocks',
//     },
//     // Ajoutez d'autres tags pour les autres modules
//   ],
// };

// const options = {
//   swaggerDefinition,
//   apis: ['./modules/**/routes/*.js', './modules/**/controllers/*.js'],
// };

// const swaggerSpec = swaggerJSDoc(options);

// module.exports = swaggerSpec;



const swaggerJSDoc = require('swagger-jsdoc');

const serverUrl = process.env.NODE_ENV === 'production' ? process.env.SERVER_URL_production : process.env.SERVER_URL_development;

const swaggerDefinition = {
  openapi: '3.0.0',
  info: {
    title: 'API',
    version: '1.0.0',
    description: 'API Documentation',
  },
  servers: [
    {
      url: serverUrl,
    },
  ],
  // ...
};

const options = {
  swaggerDefinition,
  apis: ['./routes/*.js'],
};

const swaggerSpec = swaggerJSDoc(options);

module.exports = swaggerSpec;



================================================
File: core/utils/swagger.routes.js
================================================
const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./swagger');

const router = express.Router();

router.use('/docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

module.exports = router;



================================================
File: init-db/nit-multiple-dbs.sh
================================================
#!/bin/bash
set -e

# Charge les variables depuis le fichier montÃ©
source /tmp/.env

# Debug: Affiche les variables chargÃ©es
echo "KEYCLOAK_DB_USER: $KEYCLOAK_DB_USER" >&2
echo "APP_DB_USER: $APP_DB_USER" >&2

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
    CREATE USER "$KEYCLOAK_DB_USER" WITH PASSWORD '$KEYCLOAK_DB_PASSWORD';
    CREATE DATABASE "$KEYCLOAK_DB_NAME" OWNER "$KEYCLOAK_DB_USER";
    
    CREATE USER "$APP_DB_USER" WITH PASSWORD '$APP_DB_PASSWORD';
    CREATE DATABASE "$APP_DB_NAME" OWNER "$APP_DB_USER";
EOSQL


================================================
File: keycloak-setup/backend_cli_id.json
================================================
{
  "clientId": "backend_cli_id",
  "name": "",
  "description": "",
  "surrogateAuthRequired": false,
  "enabled": true,
  "alwaysDisplayInConsole": false,
  "clientAuthenticatorType": "client-secret",
  "redirectUris": [
    "http://localhost:2000/*"
  ],
  "webOrigins": [
    "*"
  ],
  "notBefore": 0,
  "bearerOnly": true,
  "consentRequired": false,
  "standardFlowEnabled": true,
  "implicitFlowEnabled": false,
  "directAccessGrantsEnabled": true,
  "serviceAccountsEnabled": true,
  "publicClient": false,
  "frontchannelLogout": false,
  "protocol": "openid-connect",
  "attributes": {
    "realm_client": "false",
    "oidc.ciba.grant.enabled": "false",
    "backchannel.logout.session.required": "true",
    "post.logout.redirect.uris": "+",
    "oauth2.device.authorization.grant.enabled": "false",
    "backchannel.logout.revoke.offline.tokens": "false",
    "exclude.session.state.from.auth.response": "false"
  },
  "authenticationFlowBindingOverrides": {},
  "fullScopeAllowed": true,
  "nodeReRegistrationTimeout": -1,
  "defaultClientScopes": [
    "web-origins",
    "service_account",
    "acr",
    "profile",
    "roles",
    "basic",
    "email"
  ],
  "optionalClientScopes": [
    "address",
    "phone",
    "organization",
    "offline_access",
    "microprofile-jwt"
  ],
  "access": {
    "view": true,
    "configure": true,
    "manage": true
  }
}


================================================
File: keycloak-setup/frontend_cli_id.json
================================================
{
  "clientId": "frontend_cli_id",
  "surrogateAuthRequired": false,
  "enabled": true,
  "alwaysDisplayInConsole": false,
  "clientAuthenticatorType": "client-secret",
  "redirectUris": [
    "http://localhost:2000/*",
    "undefined/*",
    "http://localhost:5173/*"
  ],
  "webOrigins": [
    "*"
  ],
  "notBefore": 0,
  "bearerOnly": false,
  "consentRequired": false,
  "standardFlowEnabled": true,
  "implicitFlowEnabled": false,
  "directAccessGrantsEnabled": true,
  "serviceAccountsEnabled": false,
  "publicClient": true,
  "frontchannelLogout": false,
  "protocol": "openid-connect",
  "attributes": {
    "realm_client": "false",
    "post.logout.redirect.uris": "+",
    "exclude.session.state.from.auth.response": "false"
  },
  "authenticationFlowBindingOverrides": {},
  "fullScopeAllowed": true,
  "nodeReRegistrationTimeout": -1,
  "protocolMappers": [
    {
      "name": "backend-audience",
      "protocol": "openid-connect",
      "protocolMapper": "oidc-audience-mapper",
      "consentRequired": false,
      "config": {
        "included.client.audience": "backend_cli_id",
        "id.token.claim": "true",
        "lightweight.claim": "false",
        "access.token.claim": "true",
        "introspection.token.claim": "true"
      }
    }
  ],
  "defaultClientScopes": [
    "web-origins",
    "acr",
    "profile",
    "roles",
    "basic",
    "email"
  ],
  "optionalClientScopes": [
    "address",
    "phone",
    "organization",
    "offline_access",
    "microprofile-jwt"
  ],
  "access": {
    "view": true,
    "configure": true,
    "manage": true
  }
}


================================================
File: keycloak-setup/keycloak-setup-back.js
================================================
require('dotenv').config({ path: '../.env' }); // Charge le fichier .env à la racine

const KeycloakAdminClient = require('@keycloak/keycloak-admin-client').default;
const logger = require('../core/utils/logger');

// Configuration validation
const REQUIRED_ENV_VARS = [
  'KEYCLOAK_URL',
  'KEYCLOAK_ADMIN',
  'KEYCLOAK_ADMIN_PASSWORD',
  'KEYCLOAK_REALM',
  'KEYCLOAK_CLIENT_ID',
  'KEYCLOAK_CLIENT_SECRET'
];

// Verify all required variables are present
for (const envVar of REQUIRED_ENV_VARS) {
  if (!process.env[envVar]) {
    logger.error(`❌ Missing environment variable: ${envVar}`);
    process.exit(1);
  }
}

const keycloakConfig = {
  baseUrl: process.env.KEYCLOAK_URL,
  realmName: 'master'
};

const adminClient = new KeycloakAdminClient(keycloakConfig);

async function setupKeycloak() {
  try {
    logger.info('🔑 Authenticating to Keycloak...');
    
    await adminClient.auth({
      username: process.env.KEYCLOAK_ADMIN,
      password: process.env.KEYCLOAK_ADMIN_PASSWORD,
      grantType: 'password',
      clientId: 'admin-cli'
    });

    logger.info('✅ Successfully authenticated');

    // Realm setup
    logger.info(`🔄 Checking realm ${process.env.KEYCLOAK_REALM}...`);
    const realmExists = (await adminClient.realms.find())
      .some(r => r.realm === process.env.KEYCLOAK_REALM);

    if (!realmExists) {
      await adminClient.realms.create({
        realm: process.env.KEYCLOAK_REALM,
        enabled: true,
        displayName: `${process.env.KEYCLOAK_REALM} Realm`,
        loginTheme: "keycloak",
        accountTheme: "keycloak"
      });
      logger.info(`✨ Created realm: ${process.env.KEYCLOAK_REALM}`);
    } else {
      logger.info(`ℹ️ Realm ${process.env.KEYCLOAK_REALM} already exists`);
    }

    // Client setup
    logger.info(`🔍 Checking client ${process.env.KEYCLOAK_CLIENT_ID}...`);
    const clients = await adminClient.clients.find({
      realm: process.env.KEYCLOAK_REALM,
      clientId: process.env.KEYCLOAK_CLIENT_ID
    });

    if (clients.length === 0) {
      await adminClient.clients.create({
        realm: process.env.KEYCLOAK_REALM,
        clientId: process.env.KEYCLOAK_CLIENT_ID,
        secret: process.env.KEYCLOAK_CLIENT_SECRET,
        redirectUris: [process.env.KEYCLOAK_CALLBACK_URL || 'http://localhost:2000/*'],
        webOrigins: ['*'],
        publicClient: false,
        // standardFlowEnabled: true,
        // directAccessGrantsEnabled: true,
        // serviceAccountsEnabled: true,
        // authorizationServicesEnabled: true,
        enabled: true,
        protocol: 'openid-connect',
        attributes: {
          'post.logout.redirect.uris': '+',
          'exclude.session.state.from.auth.response': 'false'
        }
      });
      logger.info(`🎯 Created client: ${process.env.KEYCLOAK_CLIENT_ID}`);
    } else {
      logger.info(`ℹ️ Client ${process.env.KEYCLOAK_CLIENT_ID} already exists`);
    }

    logger.info('🏁 Keycloak setup completed successfully');
  } catch (error) {
    logger.error('💥 Keycloak setup failed:', error);
    process.exit(1);
  }
}

// Execute setup
setupKeycloak();


================================================
File: keycloak-setup/keycloak-setup-front.js
================================================
require('dotenv').config({ path: '../.env' });

const KeycloakAdminClient = require('@keycloak/keycloak-admin-client').default;

// Configuration avec valeurs par défaut
const config = {
  url: process.env.VITE_KEYCLOAK_URL || process.env.KEYCLOAK_URL || 'http://localhost:8080',
  realm: process.env.VITE_KEYCLOAK_REALM || 'dcat_realm', // On utilise le realm existant
  clientId: 'frontend_cli_id',
  adminUser: process.env.KEYCLOAK_ADMIN || 'admin',
  adminPass: process.env.KEYCLOAK_ADMIN_PASSWORD || 'admin',
  appUser: process.env.APP_USER || 'frontend_user',
  appPassword: process.env.APP_PASSWORD || 'frontend_password123',
  appEmail: process.env.APP_EMAIL || 'frontend.user@example.com'
};

console.log('⚙️ Configuration utilisée :');
console.log(config);

const adminClient = new KeycloakAdminClient({
  baseUrl: config.url,
  realmName: 'master',
});

async function setupKeycloak() {
  try {
    // 1. Authentification admin
    console.log('🔐 Connexion à Keycloak...');
    await adminClient.auth({
      username: config.adminUser,
      password: config.adminPass,
      grantType: 'password',
      clientId: 'admin-cli',
    });
    console.log('✅ Connecté avec succès');

    // 2. Vérification/création du realm si nécessaire
    console.log(`🔄 Vérification du realm ${config.realm}...`);
    const realmExists = (await adminClient.realms.find()).some(r => r.realm === config.realm);
    
    if (!realmExists) {
      await adminClient.realms.create({
        realm: config.realm,
        enabled: true,
        sslRequired: process.env.NODE_ENV === 'production' ? 'external' : 'none',
        loginTheme: 'keycloak'
      });
      console.log(`🆕 Realm créé : ${config.realm}`);
    } else {
      console.log(`ℹ️ Realm existant : ${config.realm}`);
    }

    // 3. Création du client frontend
    console.log(`🔍 Vérification du client ${config.clientId}...`);
    const clients = await adminClient.clients.find({
      realm: config.realm,
      clientId: config.clientId
    });

    if (clients.length === 0) {
      await adminClient.clients.create({
        realm: config.realm,
        clientId: config.clientId,
        publicClient: true,
        redirectUris: [
          'http://localhost:2000/*',
          'http://localhost:5173/*',
          `${process.env.APP_URL}/*` || ''
        ].filter(Boolean),
        webOrigins: ['*'],
        standardFlowEnabled: true,
        directAccessGrantsEnabled: true,
        enabled: true,
        attributes: {
          'post.logout.redirect.uris': '+',
          'exclude.session.state.from.auth.response': 'false'
        }
      });
      console.log(`🆕 Client frontend créé : ${config.clientId}`);
    } else {
      console.log(`ℹ️ Client frontend existant : ${config.clientId}`);
    }

    // 4. Création du rôle 'frontend_user' spécifique
    // console.log(`👔 Création du rôle 'frontend_user'...`);
    // try {
    //   await adminClient.roles.create({
    //     realm: config.realm,
    //     // name: 'frontend_user'
    //   });
    //   console.log(`🆕 Rôle 'frontend_user' créé`);
    // } catch (roleError) {
    //   if (roleError.response?.status !== 409) {
    //     throw roleError;
    //   }
    //   console.log(`ℹ️ Rôle 'frontend_user' existe déjà`);
    // }

    // 5. Création de l'utilisateur frontend spécifique
    console.log(`👤 Création de l'utilisateur ${config.appUser}...`);
    const users = await adminClient.users.find({
      realm: config.realm,
      username: config.appUser
    });

    if (users.length === 0) {
      const newUser = await adminClient.users.create({
        realm: config.realm,
        username: config.appUser,
        email: config.appEmail,
        enabled: true,
        credentials: [{
          type: 'password',
          value: config.appPassword,
          temporary: false
        }]
      });

      // Assignation du rôle spécifique
      // const role = await adminClient.roles.findOneByName({
      //   realm: config.realm,
      //   name: 'frontend_user'
      // });
      
      // await adminClient.users.addRealmRoleMappings({
      //   realm: config.realm,
      //   id: newUser.id,
      //   roles: [{
      //     id: role.id,
      //     name: role.name
      //   }]
      // });

      console.log(`🆕 Utilisateur frontend créé : ${config.appUser}`);
      console.log(`🔑 Identifiants : ${config.appUser}/${config.appPassword}`);
      // console.log(`🎯 Rôle attribué : frontend_user`);
    } else {
      console.log(`ℹ️ Utilisateur existant : ${config.appUser}`);
    }

    console.log('🎉 Configuration frontend terminée avec succès !');
    console.log(`🌐 URL du realm: ${config.url}/realms/${config.realm}`);
    console.log(`🔑 Client ID: ${config.clientId}`);

  } catch (error) {
    console.error('💥 Erreur lors de la configuration:', error.response?.data || error.message);
    process.exit(1);
  }
}

setupKeycloak();


================================================
File: keycloak-setup/keycloak-setup.js
================================================
// require('dotenv').config({ path: '../.env' });

// const KeycloakAdminClient = require('@keycloak/keycloak-admin-client').default;

// // Configuration validation
// const REQUIRED_ENV_VARS = [
//   'KEYCLOAK_URL',
//   'KEYCLOAK_ADMIN',
//   'KEYCLOAK_ADMIN_PASSWORD',
//   'KEYCLOAK_REALM',
//   'KEYCLOAK_BACKEND_CLIENT_ID',
//   'KEYCLOAK_BACKEND_CLIENT_SECRET',
//   'KEYCLOAK_FRONTEND_CLIENT_ID',
//   'KEYCLOAK_FRONTEND_CALLBACK_URL'
// ];

// // Verify all required variables are present
// for (const envVar of REQUIRED_ENV_VARS) {
//   if (!process.env[envVar]) {
//     console.error(`❌ Missing environment variable: ${envVar}`);
//     process.exit(1);
//   }
// }

// const keycloakConfig = {
//   baseUrl: process.env.KEYCLOAK_URL,
//   realmName: 'master'
// };

// const adminClient = new KeycloakAdminClient(keycloakConfig);

// const clients = [
//   {
//     clientId: process.env.KEYCLOAK_BACKEND_CLIENT_ID,
//     secret: process.env.KEYCLOAK_BACKEND_CLIENT_SECRET,
//     redirectUris: [],
//     webOrigins: [],
//     publicClient: false,
//     enabled: true,
//     protocol: 'openid-connect'
//   },
//   {
//     clientId: process.env.KEYCLOAK_FRONTEND_CLIENT_ID,
//     redirectUris: [process.env.KEYCLOAK_FRONTEND_CALLBACK_URL],
//     webOrigins: ['*'],
//     publicClient: true,
//     standardFlowEnabled: true,
//     enabled: true,
//     protocol: 'openid-connect'
//   }
// ];

// const roles = [
//   'gestion_adminitartive',
//   'finance',
//   'comptabilté',
//   'rh',
//   'stock_refference',
//   'stock_entree_sortie',
//   'stock_achat',
//   'gestion_intervention_projet',
//   'outil_reference',
//   'outils_entre_sortie_retour',
//   'maintenance_prestation',
//   'marketing',
// ];

// async function setupKeycloak() {
//   try {
//     console.info('🔑 Authenticating to Keycloak...');
    
//     await adminClient.auth({
//       username: process.env.KEYCLOAK_ADMIN,
//       password: process.env.KEYCLOAK_ADMIN_PASSWORD,
//       grantType: 'password',
//       clientId: 'admin-cli'
//     });

//     console.info('✅ Successfully authenticated');

//     // Realm setup
//     console.info(`🔄 Checking realm ${process.env.KEYCLOAK_REALM}...`);
//     const realmExists = (await adminClient.realms.find())
//       .some(r => r.realm === process.env.KEYCLOAK_REALM);

//     if (!realmExists) {
//       await adminClient.realms.create({
//         realm: process.env.KEYCLOAK_REALM,
//         enabled: true,
//         displayName: `${process.env.KEYCLOAK_REALM} Realm`,
//         loginTheme: "keycloak",
//         accountTheme: "keycloak"
//       });
//       console.info(`✨ Created realm: ${process.env.KEYCLOAK_REALM}`);
//     } else {
//       console.info(`ℹ️ Realm ${process.env.KEYCLOAK_REALM} already exists`);
//     }

//     // Clients setup
//     for (const client of clients) {
//       console.info(`🔍 Checking client ${client.clientId}...`);
//       const clientExists = (await adminClient.clients.find({
//         realm: process.env.KEYCLOAK_REALM,
//         clientId: client.clientId
//       })).length > 0;

//       if (!clientExists) {
//         await adminClient.clients.create({
//           realm: process.env.KEYCLOAK_REALM,
//           ...client
//         });
//         console.info(`🎯 Created client: ${client.clientId}`);
//       } else {
//         console.info(`ℹ️ Client ${client.clientId} already exists`);
//       }
//     }

//     // Roles setup
//     for (const role of roles) {
//       console.info(`🔍 Checking role ${role}...`);
//       const roleExists = await adminClient.roles.findOneByName({
//         realm: process.env.KEYCLOAK_REALM,
//         name: role
//       });

//       if (!roleExists) {
//         await adminClient.roles.create({
//           realm: process.env.KEYCLOAK_REALM,
//           name: role
//         });
//         console.info(`🎯 Created role: ${role}`);
//       } else {
//         console.info(`ℹ️ Role ${role} already exists`);
//       }
//     }

//     console.info('🏁 Keycloak setup completed successfully');
//   } catch (error) {
//     console.error('💥 Keycloak setup failed:', error);
//     process.exit(1);
//   }
// }

// // Execute setup
// setupKeycloak();


require('dotenv').config({ path: '../.env' });

const KeycloakAdminClient = require('@keycloak/keycloak-admin-client').default;
const fs = require('fs');
const path = require('path');

// Configuration validation
const REQUIRED_ENV_VARS = [
  'KEYCLOAK_URL',
  'KEYCLOAK_ADMIN',
  'KEYCLOAK_ADMIN_PASSWORD',
  'KEYCLOAK_REALM'
];

// Verify all required variables are present
for (const envVar of REQUIRED_ENV_VARS) {
  if (!process.env[envVar]) {
    console.error(`❌ Missing environment variable: ${envVar}`);
    process.exit(1);
  }
}

const keycloakConfig = {
  baseUrl: process.env.KEYCLOAK_URL,
  realmName: 'master'
};

const adminClient = new KeycloakAdminClient(keycloakConfig);

const clients = [
  {
    file: 'backend_cli_id.json',
    type: 'backend'
  },
  {
    file: 'frontend_cli_id.json',
    type: 'frontend'
  }
];

const roles = [
  'gestion_adminitartive',
  'finance',
  'comptabilté',
  'rh',
  'stock_refference',
  'stock_entree_sortie',
  'stock_achat',
  'gestion_intervention_projet',
  'outil_reference',
  'outils_entre_sortie_retour',
  'maintenance_prestation',
  'marketing',
];

async function setupKeycloak() {
  try {
    console.info('🔑 Authenticating to Keycloak...');
    
    await adminClient.auth({
      username: process.env.KEYCLOAK_ADMIN,
      password: process.env.KEYCLOAK_ADMIN_PASSWORD,
      grantType: 'password',
      clientId: 'admin-cli'
    });

    console.info('✅ Successfully authenticated');

    // Realm setup
    console.info(`🔄 Checking realm ${process.env.KEYCLOAK_REALM}...`);
    const realmExists = (await adminClient.realms.find())
      .some(r => r.realm === process.env.KEYCLOAK_REALM);

    if (!realmExists) {
      await adminClient.realms.create({
        realm: process.env.KEYCLOAK_REALM,
        enabled: true,
        displayName: `${process.env.KEYCLOAK_REALM} Realm`,
        loginTheme: "keycloak",
        accountTheme: "keycloak"
      });
      console.info(`✨ Created realm: ${process.env.KEYCLOAK_REALM}`);
    } else {
      console.info(`ℹ️ Realm ${process.env.KEYCLOAK_REALM} already exists`);
    }

    // Clients setup
    for (const client of clients) {
      const clientConfig = JSON.parse(fs.readFileSync(path.join(__dirname, client.file), 'utf8'));
      console.info(`🔍 Checking client ${clientConfig.clientId}...`);
      const clientExists = (await adminClient.clients.find({
        realm: process.env.KEYCLOAK_REALM,
        clientId: clientConfig.clientId
      })).length > 0;

      if (!clientExists) {
        await adminClient.clients.create({
          realm: process.env.KEYCLOAK_REALM,
          ...clientConfig
        });
        console.info(`🎯 Created client: ${clientConfig.clientId}`);
      } else {
        console.info(`ℹ️ Client ${clientConfig.clientId} already exists`);
      }
    }

    // Roles setup
    for (const role of roles) {
      console.info(`🔍 Checking role ${role}...`);
      const roleExists = await adminClient.roles.findOneByName({
        realm: process.env.KEYCLOAK_REALM,
        name: role
      });

      if (!roleExists) {
        await adminClient.roles.create({
          realm: process.env.KEYCLOAK_REALM,
          name: role
        });
        console.info(`🎯 Created role: ${role}`);
      } else {
        console.info(`ℹ️ Role ${role} already exists`);
      }
    }

    console.info('🏁 Keycloak setup completed successfully');
  } catch (error) {
    console.error('💥 Keycloak setup failed:', error);
    process.exit(1);
  }
}

// Execute setup
setupKeycloak();




================================================
File: media/documents/technique/interventions/je dois faire la presentation de la_1745573090108.txt
================================================
soro vient



================================================
File: modules/Administration&Finance/FinanceCompta/controllers/accounting.controller.js
================================================
ï»¿


================================================
File: modules/Administration&Finance/FinanceCompta/controllers/demamd.controller.js
================================================
const demandService = require('../services/demand.service')
const logger = require('../../../core/utils/logger')

const createDemande = async (req, res) => {
    try{
        const demande = await demandService.createDemande(req.body)
        res.status(201).json(demande)
        logger.info(`Demande created successfully: ${demande.id}`)
    }catch(error){
        logger.error(error)
        res.status(500).json({message: 'Error creating demande'})
    }
    
}

const getDemandes = async (req, res) => {
    try{
        const demandes = await demandService.getDemandes()
        res.status(200).json(demandes)
        logger.info(`Demandes fetched successfully`)
    }catch(error){
        logger.error(error)
        res.status(500).json({message: 'Error fetching demandes'})
    }
}


const getDemandeById = async (req, res) => {
    try{
        const demande = await demandService.getDemandeById(req.params.id)
        res.status(200).json(demande)
        logger.info(`Demande fetched successfully: ${demande.id}`)
    }catch(error){
            logger.error(error)
        res.status(500).json({message: 'Error fetching demande'})
    }
}           

const updateDemande = async (req, res) => {
    try{
        const demande = await demandService.updateDemande(req.params.id, req.body)
        res.status(200).json(demande)
        logger.info(`Demande updated successfully: ${demande.id}`)
    }catch(error){
        logger.error(error)
        res.status(500).json({message: 'Error updating demande'})
    }
}   

const deleteDemande = async (req, res) => {
    try{
        await demandService.deleteDemande(req.params.id)
        res.status(200).json({message: 'Demande deleted successfully'})
        logger.info(`Demande deleted successfully: ${req.params.id}`)
    }catch(error){
        logger.error(error)
        res.status(500).json({message: 'Error deleting demande'})
    }
}   

module.exports = {
    createDemande,
    getDemandes,
    getDemandeById,
    updateDemande,
    deleteDemande
}






================================================
File: modules/Administration&Finance/FinanceCompta/controllers/entity.controller.js
================================================
const entityService = require('../services/entity.service')
const logger = require('../../../core/utils/logger')

const createEntite=async(req,res)=>{
    try {
        const entite = await entityService.createEntite(req.body)
        res.status(201).json(entite)
    } catch (error) {
        logger.error(error)
        res.status(500).json({message:"Erreur lors de la crÃ©ation de l'entitÃ©"})
    }
}

const getEntites=async(req,res)=>{
    try {
        const entites = await entityService.getEntites()
        console.log('EntitÃ©s rÃ©cupÃ©rÃ©es:', entites);
        res.status(200).json(entites)
    } catch (error) {
        logger.error(error)
        res.status(500).json({message:"Erreur lors de la rÃ©cupÃ©ration des entitÃ©s"})
    }
}

const getEntiteById=async(req,res)=>{
    try {
        const id = req.params.id;
        if (!id || isNaN(id)) {
            return res.status(400).json({error: "ID invalide"});
        }
        
        const entite = await entityService.getEntiteById(id)
        if (!entite) {
            return res.status(404).json({message:"EntitÃ© non trouvÃ©e"})
        }
        res.status(200).json(entite)
    } catch (error) {
        logger.error('Error in getEntiteById:', error)
        res.status(500).json({
            message:"Erreur lors de la rÃ©cupÃ©ration de l'entitÃ©",
            error: error.message
        })
    }
}

const updateEntite=async(req,res)=>{
    try {
        const id = req.params.id;
        if (!id || isNaN(id)) {
            return res.status(400).json({error: "ID invalide"});
        }

        const entite = await entityService.updateEntite(id, req.body)
        if (!entite) {
            return res.status(404).json({message:"EntitÃ© non trouvÃ©e"})
        }
        res.status(200).json(entite)
    } catch (error) {
        logger.error(error)
        res.status(500).json({message:"Erreur lors de la mise Ã  jour de l'entitÃ©"})
    }
}       

const deleteEntite=async(req,res)=>{    
    try {
        const id = req.params.id;
        if (!id || isNaN(id)) {
            return res.status(400).json({error: "ID invalide"});
        }

        await entityService.deleteEntite(id)
        res.status(200).json({message:"EntitÃ© supprimÃ©e avec succÃ¨s"})
    } catch (error) {
        logger.error(error)
        res.status(500).json({message:"Erreur lors de la suppression de l'entitÃ©"})
    }       
}

module.exports={
    createEntite,
    getEntites,
    getEntiteById,
    updateEntite,
    deleteEntite
}


================================================
File: modules/Administration&Finance/FinanceCompta/controllers/partenaire.controller.js
================================================
const partenaireService = require("../services/partenaire.service");

const createPartenaire = async (req, res) => {
  try {
    const result = await partenaireService.createPartenaire(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getPartenaires = async (req, res) => {
  try {
    const result = await partenaireService.getPartenaires();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getPartenaireById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await partenaireService.getPartenaireById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updatePartenaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await partenaireService.updatePartenaire(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deletePartenaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await partenaireService.deletePartenaire(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createPartenaire,
  getPartenaires,
  getPartenaireById,
  updatePartenaire,
  deletePartenaire,
};



================================================
File: modules/Administration&Finance/FinanceCompta/routes/accounting.routes.js
================================================
ï»¿


================================================
File: modules/Administration&Finance/FinanceCompta/routes/administration.routes.js
================================================
const express = require("express");
const router = express.Router();
const entiteRoutes = require("./entity.route");
const partnerRoutes = require("./partner.route");
const demandRoutes = require("./demand.route");
// CRUD Routes
router.use("/entites", entiteRoutes);
router.use("/partners", partnerRoutes);
router.use("/demandes", demandRoutes);

module.exports = router;



================================================
File: modules/Administration&Finance/FinanceCompta/routes/demand.route.js
================================================
const express = require('express')
const router = express.Router()
const demandController = require('../controllers/demamd.controller')

router.post('/', demandController.createDemande)
router.get('/', demandController.getDemandes)
router.get('/:id', demandController.getDemandeById)
router.put('/:id', demandController.updateDemande)
router.delete('/:id', demandController.deleteDemande)

module.exports = router



================================================
File: modules/Administration&Finance/FinanceCompta/routes/entity.route.js
================================================
const express = require('express'); 
const router = express.Router();
const entityController = require('../controllers/entity.controller');

router.post('/', entityController.createEntite);
router.get('/', entityController.getEntites);
router.get('/:id', entityController.getEntiteById);
router.put('/:id', entityController.updateEntite);
router.delete('/:id', entityController.deleteEntite);

module.exports = router;



================================================
File: modules/Administration&Finance/FinanceCompta/routes/partner.route.js
================================================
const express = require('express');
const router = express.Router();
const controller = require('../controllers/partenaire.controller');

router.post("/", controller.createPartenaire);
router.get("/", controller.getPartenaires);
router.get("/:id", controller.getPartenaireById);
router.put("/:id", controller.updatePartenaire);
router.delete("/:id", controller.deletePartenaire);

module.exports = router;



================================================
File: modules/Administration&Finance/FinanceCompta/services/demand.service.js
================================================
const {db} = require('../../../core/database/config')
const {demande} = require('../../../core/database/models')
const {eq} = require('drizzle-orm')

const createDemande = async (data) => {
    const [newDemande] = await db.insert(demande).values(data).returning()
    return newDemande
}

const getDemandes = async () => {
    const demandes = await db.select().from(demande)
    return demandes
}   

const getDemandeById = async (id) => {
    const [foundDemande] = await db.select().from(demande).where(eq(demande.id, id))
    return foundDemande
}

const updateDemande = async (id, data) => {
    const [updatedDemande] = await db.update(demande).set(data).where(eq(demande.id, id)).returning()
    return updatedDemande
}

const deleteDemande = async (id) => {
    await db.delete(demande).where(eq(demande.id, id))
}

module.exports = {
    createDemande,
    getDemandes,
    getDemandeById,
    updateDemande,
    deleteDemande
}




================================================
File: modules/Administration&Finance/FinanceCompta/services/entity.service.js
================================================
const {entite: entiteModel} = require('../../../core/database/models')
const {db} = require('../../../core/database/config')
const {eq} = require('drizzle-orm')

const createEntite=async(data)=>{
    const [newEntite]=await db.insert(entiteModel).values(data).returning()
    return newEntite
}

const getEntites=async()=>{
    const entites=await db.select().from(entiteModel)
    return entites
}

const getEntiteById=async(id)=>{
    const [foundEntite]=await db.select().from(entiteModel).where(eq(entiteModel.id,id))
    return foundEntite
}

const updateEntite=async(id,data)=>{
    const [updatedEntite]=await db.update(entiteModel).set(data).where(eq(entiteModel.id,id)).returning()
    return updatedEntite
}

const deleteEntite=async(id)=>{
    await db.delete(entiteModel).where(eq(entiteModel.id,id))
}

module.exports={
    createEntite,
    getEntites,
    getEntiteById,
    updateEntite,
    deleteEntite
}



================================================
File: modules/Administration&Finance/FinanceCompta/services/partenaire.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require('../../../core/database/config')
const { partenaire } = require("../../../core/database/models");

const createPartenaire=async(data)=>{
    const [result]=await db.insert(partenaire).values(data).returning()
    return result
}

const getPartenaires=async()=>{
    return await db.select().from(partenaire);

}

const getPartenaireById=async(id)=>{
    const [result]=await db.select().from(partenaire).where(eq(partenaire.id,id))
    return result
}

const updatePartenaire=async(id,data)=>{
    const [result]=await db.update(partenaire).set(data).where(eq(partenaire.id,id)).returning()
    return result
}

const deletePartenaire=async(id)=>{
    const [result]=await db.delete(partenaire).where(eq(partenaire.id,id)).returning()
    return result
}

module.exports={
    createPartenaire,
    getPartenaires, 
    getPartenaireById,
    updatePartenaire,
    deletePartenaire
}


================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/contrat.controller.js
================================================
const contratService = require('../services/contrat.service');

const createContrat = async (req, res) => {
    try {   
        const contrat = await contratService.createContrat(req.body);
        res.status(201).json(contrat);
    }
    catch (error) {
        console.error("Error creating contrat:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const getContrats = async (req, res) => {
    try {
        const contrats = await contratService.getContrats();
        res.status(200).json(contrats);
    } catch (error) {
        console.error("Error fetching contrats:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const getContratbyPartenaire = async (req, res) => {
    try {
        const { id } = req.params;
        const contrat = await contratService.getContratsbyPartenaire(id);
        if (!contrat) {
            return res.status(404).json({ message: "Contrat not found" });
        }
        res.status(200).json(contrat);
    } catch (error) {
        console.error("Error fetching contrat by partenaire:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const updateContrat = async (req, res) => {
    try {
        const { id } = req.params;
        const updatedContrat = await contratService.updateContrat(id, req.body);
        if (!updatedContrat) {
            return res.status(404).json({ message: "Contrat not found" });
        }
        res.status(200).json(updatedContrat);
    } catch (error) {
        console.error("Error updating contrat:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const deleteContrat = async (req, res) => {
    try {
        const { id } = req.params;
        const deletedContrat = await contratService.deleteContrat(id);
        if (!deletedContrat) {
            return res.status(404).json({ message: "Contrat not found" });
        }
        res.status(200).json(deletedContrat);
    } catch (error) {
        console.error("Error deleting contrat:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}


module.exports = {
    createContrat,
    getContrats,
    getContratbyPartenaire,
    updateContrat,
    deleteContrat
}


================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/entite.controller.js
================================================
const entiteService = require('../services/entite.service');

const createEntite = async (req, res) => {
    try {   
        const entite = await entiteService.createEntite(req.body);
        res
        .status(201)
        .json(entite);
    }
    catch (error) {
        console.error("Error creating entite:", error);
        res
        .status(500)
        .json({ message: "Internal server error" });
    }
}

const getEntites = async (req, res) => {
    try {
        const entites = await entiteService.getEntites();
        res
        .status(200)
        .json(entites);
    } catch (error) {
        console.error("Error fetching entites:", error);
        res
        .status(500)
        .json({ message: "Internal server error" });
    }
}

const updateEntite = async (req, res) => {
    try {
        const { id } = req.params;
        const updatedEntite = await entiteService.updateEntite(id, req.body);
        if (!updatedEntite) {
            return res.status(404).json({ message: "Entite not found" });
        }
        res.status(200).json(updatedEntite);
    } catch (error) {
        console.error("Error updating entite:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}
const deleteEntite = async (req, res) => {
    try {
        const { id } = req.params;
        const deletedEntite = await entiteService.deleteEntite(id);
        if (!deletedEntite) {
            return res.status(404).json({ message: "Entite not found" });
        }
        res.status(200).json(deletedEntite);
    } catch (error) {
        console.error("Error deleting entite:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

module.exports = {
    createEntite,
    getEntites,
    updateEntite,
    deleteEntite
}


================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/interlocuteur.controller.js
================================================
const interlocuteurService = require('../services/interlocuteur.service');

const createInterlocuteur = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.createInterlocuteur(req.body);
        res.status(201).json(interlocuteur);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const getInterlocuteurs = async (req, res) => {
    try {
        const interlocuteurs = await interlocuteurService.getInterlocuteurs();
        res.status(200).json(interlocuteurs);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const getInterlocuteurbyPartenaire = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.getInterlocuteurbyPartenaire(req.params.id);
        if (!interlocuteur) {
            return res.status(404).json({ message: 'Interlocuteur not found' });
        }
        res.status(200).json(interlocuteur);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const updateInterlocuteur = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.updateInterlocuteur(req.params.id, req.body);
        if (!interlocuteur) {
            return res.status(404).json({ message: 'Interlocuteur not found' });
        }
        res.status(200).json(interlocuteur);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const deleteInterlocuteur = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.deleteInterlocuteur(req.params.id);
        if (!interlocuteur) {
            return res.status(404).json({ message: 'Interlocuteur not found' });
        }
        res.status(200).json({ message: 'Interlocuteur deleted successfully' });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

module.exports = {
    createInterlocuteur,
    getInterlocuteurs,
    getInterlocuteurbyPartenaire,
    updateInterlocuteur,
    deleteInterlocuteur
}


================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/nature.controller.js
================================================
const natureService = require('../services/nature.service');

const createNature = async (req, res) => {
    try {
        const data = req.body;
        const result = await natureService.createNature(data);
        res.status(201).json(result);
    } catch (error) {
        console.error("Error creating nature:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const getAllNatures = async (req, res) => {
    try {
        const result = await natureService.getAllNatures();
        res.status(200).json(result);
    } catch (error) {
        console.error("Error fetching natures:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const getNaturebyId = async (req, res) => {
    try {
        const id = req.params.id;
        const result = await natureService.getNaturebyId(id);
        if (result.length === 0) {
            return res.status(404).json({ message: "Nature not found" });
        }
        res.status(200).json(result[0]);
    } catch (error) {
        console.error("Error fetching nature by ID:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const updateNature = async (req, res) => {
    try {
        const id = req.params.id;
        const data = req.body;
        const result = await natureService.updateNature(id, data);
        if (result.length === 0) {
            return res.status(404).json({ message: "Nature not found" });
        }
        res.status(200).json(result[0]);
    } catch (error) {
        console.error("Error updating nature:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const deleteNature = async (req, res) => {
    try {
        const id = req.params.id;
        const result = await natureService.deleteNature(id);
        if (result.length === 0) {
            return res.status(404).json({ message: "Nature not found" });
        }
        res.status(200).json({ message: "Nature deleted successfully" });
    } catch (error) {
        console.error("Error deleting nature:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}


module.exports = {
    createNature,
    getAllNatures,
    getNaturebyId,
    updateNature,
    deleteNature
}



================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/partenaire.controller.js
================================================
// const partenaireService = require("../services/partenaire.service");

// const createPartenaire = async (req, res) => {
//   try {
//     const result = await partenaireService.createPartenaire(req.body);
//     return res.status(201).json(result);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// const getPartenaires = async (req, res) => {
//   try {
//     const result = await partenaireService.getPartenaires();
//     return res.status(200).json(result || []);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// const getPartenaireById = async (req, res) => {
//   try {
//     const id = parseInt(req.params.id);
//     if (isNaN(id)) {
//       return res.status(400).json({ error: "ID invalide" });
//     }
//     const result = await partenaireService.getPartenaireById(Number(id));
//     return res.json(result);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// const updatePartenaire = async (req, res) => {
//   try {
//     const id = parseInt(req.params.id);
//     if (isNaN(id)) {
//       return res.status(400).json({ error: "ID invalide" });
//     }
//     const result = await partenaireService.updatePartenaire(id);
//     return res.json(result);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// const deletePartenaire = async (req, res) => {
//   try {
//     const id = parseInt(req.params.id);
//     if (isNaN(id)) {
//       return res.status(400).json({ error: "ID invalide" });
//     }
//     const result = await partenaireService.deletePartenaire(id);
//     return res.json(result);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// module.exports = {
//   createPartenaire,
//   getPartenaires,
//   getPartenaireById,
//   updatePartenaire,
//   deletePartenaire,
// };

const partenaireService = require("../services/partenaire.service");

const createPartenaire = async (req, res) => {
  try {
    const result = await partenaireService.createPartenaire(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

const getPartenaires = async (req, res) => {
  try {
    const result = await partenaireService.getPartenaires();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

const getPartenairebyType = async (req,res) =>{
  try{
    const type = req.params.type;
    const result = await partenaireService.getPartenaireByType(type);
    return res.status(200).json(result || []);
  }
  catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

const updatePartenaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await partenaireService.updatePartenaire(id, req.body);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

const deletePartenaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await partenaireService.deletePartenaire(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

module.exports = {
  createPartenaire,
  getPartenaires,
  getPartenairebyType,
  updatePartenaire,
  deletePartenaire,
};



================================================
File: modules/Administration&Finance/GestionAdministrative/routes/contrat.route.js
================================================
const contratcontroller = require('../controllers/contrat.controller');
const express = require('express');
const router = express.Router();

router.post("/", contratcontroller.createContrat);
router.get("/", contratcontroller.getContrats);
router.get("/:id", contratcontroller.getContratbyPartenaire);
router.put("/:id", contratcontroller.updateContrat);
router.delete("/:id", contratcontroller.deleteContrat);

module.exports = router;


================================================
File: modules/Administration&Finance/GestionAdministrative/routes/entite.route.js
================================================
const entiteController = require('../controllers/entite.controller');
const express = require('express');
const router = express.Router();


router.post('/', entiteController.createEntite);
router.get('/', entiteController.getEntites);
router.put('/:id', entiteController.updateEntite);
router.delete('/:id', entiteController.deleteEntite);
module.exports = router;



================================================
File: modules/Administration&Finance/GestionAdministrative/routes/interlocuteur.route.js
================================================
const interlocuteurController = require('../controllers/interlocuteur.controller');
const express = require('express');
const router = express.Router();

router.post("/", interlocuteurController.createInterlocuteur);
router.get("/", interlocuteurController.getInterlocuteurs);
router.get("/:id", interlocuteurController.getInterlocuteurbyPartenaire);
router.put("/:id", interlocuteurController.updateInterlocuteur);
router.delete("/:id", interlocuteurController.deleteInterlocuteur);

module.exports = router;




================================================
File: modules/Administration&Finance/GestionAdministrative/routes/nature.route.js
================================================
const natureController = require('../controllers/nature.controller');
const express = require('express');
const router = express.Router();


router.post('/', natureController.createNature);
router.get('/', natureController.getAllNatures);
router.get('/:id', natureController.getNaturebyId);
router.put('/:id', natureController.updateNature);
router.delete('/:id', natureController.deleteNature);


module.exports = router;


================================================
File: modules/Administration&Finance/GestionAdministrative/routes/partenaire.route.js
================================================
const express = require('express');
const router = express.Router();
const controller = require('../controllers/partenaire.controller');

router.post("/", controller.createPartenaire);
router.get("/", controller.getPartenaires);
router.get("/:type", controller.getPartenairebyType);
router.put("/:id", controller.updatePartenaire);
router.delete("/:id", controller.deletePartenaire);

module.exports = router;



================================================
File: modules/Administration&Finance/GestionAdministrative/services/contrat.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config")
const {contrats} = require("../../../../core/database/models")

const createContrat=async(data)=>{
    const [result]=await db.insert(contrats).values(data).returning()
    return result
}

const getContrats=async()=>{
    return await db.select().from(contrats);
}

const getContratsbyPartenaire=async(id)=>{
    const [result]=await db.select().from(contrats).where(eq(contrats.id_partenaire,id))
    return result
}

const updateContrat=async(id,data)=>{
    const [result]=await db.update(contrats).set(data).where(eq(contrats.id_contrat,id)).returning()
    return result
}

const deleteContrat=async(id)=>{
    const [result]=await db.delete(contrats).where(eq(contrats.id_contrat,id)).returning()
    return result
}

module.export={
    createContrat,
    getContrats, 
    getContratsbyPartenaire,
    updateContrat,
    deleteContrat
}


================================================
File: modules/Administration&Finance/GestionAdministrative/services/entite.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config")
const {entites} = require("../../../../core/database/models")

const createEntite=async(data)=>{
    const [result]=await db
    .insert(entites)
    .values(data)
    .returning()
    return result
}   

const getEntites=async()=>{
    return await db
    .select()
    .from(entites);
}

const getEntiteById=async(id)=>{
    const [result]=await db
    .select()
    .from(entites)
    .where(eq(entites.id_entite,id))
    return result
}

const updateEntite=async(id,data)=>{
    const [result]=await db
    .update(entites)
    .set({...data,updated_at:new Date()})
    .where(eq(entites.id_entite,id)).returning()
    return result
}

const deleteEntite=async(id)=>{ 
    const [result]=await db
    .delete(entites)
    .where(eq(entites.id_entite,id))
    .returning()
    return result
}

module.exports={
    createEntite,
    getEntites, 
    getEntiteById, 
    updateEntite,
    deleteEntite
}


================================================
File: modules/Administration&Finance/GestionAdministrative/services/interlocuteur.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config");
const {interlocuteurs} = require("../../../../core/database/models");

const createInterlocuteur = async (data) => {
    const [result] = await db.insert(interlocuteurs).values(data).returning();
    return result;
}

const getInterlocuteurs = async () => {
    return await db.select().from(interlocuteurs);
}

const getInterlocuteurbyPartenaire = async (id) => {
    const [result] = await db.select().from(interlocuteur).where(eq(interlocuteurs.id_partenaire, id));
    return result;
}

const updateInterlocuteur = async (id, data) => {
    const [result] = await db.update(interlocuteurs).set(data).where(eq(interlocuteurs.id_interlocuteur, id)).returning();
    return result;
}

const deleteInterlocuteur = async (id) => {
    const [result] = await db.delete(interlocuteurs).where(eq(interlocuteurs.id_interlocuteur, id)).returning();
    return result;
}

module.exports = {
    createInterlocuteur,
    getInterlocuteurs,
    getInterlocuteurbyPartenaire,
    updateInterlocuteur,
    deleteInterlocuteur
}


================================================
File: modules/Administration&Finance/GestionAdministrative/services/nature.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config")
const {nature_documents} = require("../../../../core/database/models")

const createNature = async (data) => {
    try {
        const result = await db
        .insert(nature_documents)
        .values(data)
        .returning();
        return result;
    } catch (error) {
        console.error("Error creating nature:", error);
        throw error;
    }
}

const getAllNatures = async () => {
    try {
        const result = await db
        .select()
        .from(nature_documents)
        return result;
    } catch (error) {
        console.error("Error fetching natures:", error);
        throw error;
    }
}

const getNaturebyId = async (id) => {
    try {
        const result = await db
        .select()
        .from(nature_documents)
        .where(eq(nature_documents.id, id))
        return result;
    } catch (error) {
        console.error("Error fetching nature by ID:", error);
        throw error;
    }
}

const updateNature = async (id, data) => {
    try {
        const result = await db
        .update(nature_documents)
        .set(data)
        .where(eq(nature_documents.id_nature_document, id))
        .returning();
        return result;
    } catch (error) {
        console.error("Error updating nature:", error);
        throw error;
    }
}

const deleteNature = async (id) => {
    try {
        const result = await db
        .delete(nature_documents)
        .where(eq(nature_documents.id_nature_document, id))
        .returning();
        return result;
    } catch (error) {
        console.error("Error deleting nature:", error);
        throw error;
    }
}

module.exports = {
    createNature,
    getAllNatures,
    getNaturebyId,
    updateNature,
    deleteNature
}


================================================
File: modules/Administration&Finance/GestionAdministrative/services/partenaire.service.js
================================================
// const { eq } = require("drizzle-orm");
// const {db} = require('../../../core/database/config')
// const { partenaire } = require("../../../core/database/models");

// const createPartenaire=async(data)=>{
//     const [result]=await db.insert(partenaire).values(data).returning()
//     return result
// }

// const getPartenaires=async()=>{
//     return await db.select().from(partenaire);

// }

// const getPartenaireById=async(id)=>{
//     const [result]=await db.select().from(partenaire).where(eq(partenaire.id,id))
//     return result
// }

// const updatePartenaire=async(id,data)=>{
//     const [result]=await db.update(partenaire).set(data).where(eq(partenaire.id,id)).returning()
//     return result
// }

// const deletePartenaire=async(id)=>{
//     const [result]=await db.delete(partenaire).where(eq(partenaire.id,id)).returning()
//     return result
// }

// module.exports={
//     createPartenaire,
//     getPartenaires, 
//     getPartenaireById,
//     updatePartenaire,
//     deletePartenaire
// }

const { eq } = require("drizzle-orm");
const { db } = require("../../../../core/database/config");
const { partenaires } = require("../../../../core/database/models");

const createPartenaire = async (data) => {
  const [result] = await db.insert(partenaires).values(data).returning();
  return result;
}

const getPartenaires = async () => {
  return await db.select().from(partenaires);
}

const getPartenaireById = async (id) => {
  const [result] = await db.select().from(partenaires).where(eq(partenaires.id_partenaire, id));
  return result;
}

const updatePartenaire = async (id, data) => {
  const [result] = await db
  .update(partenaires)
  .set({...data, updated_at: new Date() })
  .where(eq(partenaires.id_partenaire, id)).returning();
  return result;
}

const deletePartenaire = async (id) => {
  const [result] = await db.delete(partenaires).where(eq(partenaires.id_partenaire, id)).returning();
  return result;
}

module.exports = {
  createPartenaire,
  getPartenaires,
  getPartenaireById,
  updatePartenaire,
  deletePartenaire
}


================================================
File: modules/Administration&Finance/RH/controllers/demande.controller.js
================================================
const demandeService = require('../services/demande.service');

const createDemande = async (req, res) => {
    try {
        const data = req.body;
        const result = await demandeService.createDemande(data);
        res.status(201).json(result);
    } catch (error) {
        console.error("Error creating demande:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const getAllDemandes = async (req, res) => {
    try {
        const result = await demandeService.getAllDemandes();
        res.status(200).json(result);
    } catch (error) {
        console.error("Error fetching demandes:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const getDemandeByType = async (req, res) => {
    try {
        const { type } = req.params;
        const result = await demandeService.getDemandeByType(type);
        res.status(200).json(result);
    } catch (error) {
        console.error("Error fetching demande by type:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const updateDemande = async (req, res) => {
    try {
        const { id } = req.params;
        const data = req.body;
        const result = await demandeService.updateDemande(id, data);
        res.status(200).json(result);
    } catch (error) {
        console.error("Error updating demande:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const deleteDemande = async (req, res) => {
    try {
        const { id } = req.params;
        const result = await demandeService.deleteDemande(id);
        res.status(200).json(result);
    } catch (error) {
        console.error("Error deleting demande:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

module.exports = {
    createDemande,
    getAllDemandes,
    getDemandeByType,
    updateDemande,
    deleteDemande
};


================================================
File: modules/Administration&Finance/RH/routes/demande.route.js
================================================
const demandeController = require('../controllers/demande.controller');
const express = require('express');
const router = express.Router();

router.post('/', demandeController.createDemande);
router.get('/', demandeController.getAllDemandes);
router.get('/:type', demandeController.getDemandeByType);
router.put('/:id', demandeController.updateDemande);
router.delete('/:id', demandeController.deleteDemande);

module.exports = router;


================================================
File: modules/Administration&Finance/RH/services/demande.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config")
const {demandes} = require("../../../../core/database/models")

const createDemande = async (data) => {
    try {
        const result = await db
        .insert(demandes)
        .values(data)
        .returning();
        return result;
    } catch (error) {
        console.error("Error creating demande:", error);
        throw error;
    }
}

const getAllDemandes = async () => {
    try {
        const result = await db
        .select()
        .from(demandes)
        return result;
    } catch (error) {
        console.error("Error fetching demandes:", error);
        throw error;
    }
}

const getdemandeBytype = async (type) => {
    try {
        const result = await db
        .select()
        .from(demandes)
        .where(eq(demandes.type_demande, type))
        return result;
    } catch (error) {
        console.error("Error fetching demande by type:", error);
        throw error;
    }
}

const updateDemande = async (id, data) => {
    try {
        const result = await db
        .update(demandes)
        .set(data)
        .where(eq(demandes.id_demandes, id))
        .returning();
        return result;
    } catch (error) {
        console.error("Error updating demande:", error);
        throw error;
    }
}

const deleteDemande = async (id) => {
    try {
        const result = await db
        .delete(demandes)
        .where(eq(demandes.id_demandes, id))
        .returning();
        return result;
    } catch (error) {
        console.error("Error deleting demande:", error);
        throw error;
    }
}

module.exports = {
    createDemande,
    getAllDemandes,
    getdemandeBytype,
    updateDemande,
    deleteDemande
}


================================================
File: modules/Administration&Finance/routes/Administration&Finance.routes.js
================================================
const express = require("express");
const router = express.Router();
const interlocuteurRoutes = require("../GestionAdministrative/routes/interlocuteur.route");
const partenaireRoutes = require("../GestionAdministrative/routes/partenaire.route");
const contratRoutes = require("../GestionAdministrative/routes/contrat.route");
const natureRoutes = require("../GestionAdministrative/routes/nature.route");
const entiteRoutes = require("../GestionAdministrative/routes/entite.route");
const demandeRoutes = require("../RH/routes/demande.route")


router.use("/interlocuteurs", interlocuteurRoutes);
router.use("/partenaires", partenaireRoutes);
router.use("/contrats", contratRoutes);
router.use("/natures", natureRoutes);
router.use("/entites", entiteRoutes);
router.use("/demandes", demandeRoutes);

module.exports = router;



================================================
File: modules/clients/controllers/clients.controller.js
================================================
ï»¿const db = require('../../core/database');
const Model = db.models.Clients;

exports.getAll = async (req, res) => {
    try {
        const data = await Model.findAll();
        res.json(data);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.create = async (req, res) => {
    try {
        const newItem = await Model.create(req.body);
        res.status(201).json(newItem);
    } catch (error) {
        res.status(400).json({ message: error.message });
    }
};

// Ajoutez ici les autres mÃƒÂ©thodes CRUD...



================================================
File: modules/clients/routes/clients.routes.js
================================================
ï»¿


================================================
File: modules/dashboard/controllers/dashboard.controller.js
================================================
ï»¿


================================================
File: modules/dashboard/routes/dashboard.routes.js
================================================
ï»¿


================================================
File: modules/marketing_commercial/controllers/affiches.controller.js
================================================



================================================
File: modules/marketing_commercial/controllers/clients.controller.js
================================================



================================================
File: modules/marketing_commercial/controllers/commandes.controller.js
================================================



================================================
File: modules/marketing_commercial/controllers/produits.controller.js
================================================



================================================
File: modules/marketing_commercial/controllers/services.controller.js
================================================



================================================
File: modules/marketing_commercial/routes/clients.routes.js
================================================



================================================
File: modules/marketing_commercial/routes/commandes.routes.js
================================================



================================================
File: modules/marketing_commercial/routes/marketing_commercial.route.js
================================================



================================================
File: modules/marketing_commercial/routes/produits.routes.js
================================================



================================================
File: modules/marketing_commercial/services/clients.service.js
================================================



================================================
File: modules/marketing_commercial/services/commandes.service.js
================================================



================================================
File: modules/marketing_commercial/services/produits.service.js
================================================



================================================
File: modules/moyens_generaux/controllers/mouvementOutil.controller.js
================================================



================================================
File: modules/moyens_generaux/routes/mouvementOutil.route.js
================================================



================================================
File: modules/moyens_generaux/services/mouvementOutil.service.js
================================================



================================================
File: modules/stocks/readme.md
================================================
## Gestion des erreurs de migration Drizzle ORM

Si vous rencontrez l'erreur suivante lors de l'exécution de :

```sh
npx drizzle-kit migrate
```

```sh
error: password authentication failed for user "dcat_user"
    at D:\dcat_backend\node_modules\pg-pool\index.js:45:11
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async PgDialect.migrate (D:\dcat_backend\node_modules\src\pg-core\dialect.ts:85:3)
    at async migrate (D:\dcat_backend\node_modules\src\node-postgres\migrator.ts:10:2) {
  length: 105,
  severity: 'FATAL',
  code: '28P01',
```

### Solution :

Assurez-vous que les fichiers suivants utilisent bien le format de fin de ligne `LF` et non `CRLF` :

- `init-db/init-multiple-dbs.sh`
- `.env`

Pour convertir ces fichiers sous Linux/macOS :

```sh
dos2unix init-db/init-multiple-dbs.sh .env
```

Sous Windows, utilisez un éditeur de texte comme VS Code et modifiez le format de fin de ligne en `LF`.

# États des Exemplaires de Produit

Les exemplaires de produits peuvent se trouver dans différents états en fonction de leur disponibilité, utilisation, ou condition. Voici une description de chaque état possible :

## 1. **Vendu**

- **Description** : L'exemplaire a été acheté par un client et n'est plus disponible à la vente.
- **Utilisation** : Ce statut est attribué après qu'un client a finalisé l'achat d'un exemplaire.

## 2. **Disponible**

- **Description** : L'exemplaire est en stock et prêt à être vendu ou expédié. Il peut être acheté immédiatement par un client.
- **Utilisation** : Quand un exemplaire est prêt à la vente, il est marqué comme "disponible".

## 3. **Utilisation**

- **Description** : L'exemplaire est en cours d'utilisation pour un projet par un employé.

## 4. **En maintenance**

- **Description** : L'exemplaire est temporairement hors service pour des réparations ou un entretien.
- **Utilisation** : Ce statut est utilisé lorsqu'un produit nécessite une intervention technique ou un entretien pour fonctionner correctement.

## 5. **Endommage**

- **Description** : L'exemplaire a subi des dommages physiques et ne peut plus être vendu dans son état actuel.
- **Utilisation** : Ce statut est utilisé lorsque le produit est cassé ou endommagé de manière irréparable ou non vendable.

## 6. **Reserve**

- **Description** : L'exemplaire est réservé pour un client ou une commande, mais l'achat n'a pas encore été finalisé.
- **Utilisation** : Un exemplaire est marqué comme "réservé" lorsqu'il est mis de côté pour une commande en attente de validation.

---

Chaque état permet de gérer l'exemplaire en fonction de son statut actuel dans le cycle de vie du produit, afin de garantir une gestion efficace et une communication claire sur la disponibilité des produits.

# Gestion des Produits : Équipements vs Outils

Dans ce module, les produits sont classés en deux grandes catégories grâce à la table `type_produit` :

- **Équipements** : produits destinés à être **vendus**.
- **Outils** : produits destinés à être **utilisés** par les employés sur le terrain.

---

## 🛠️ Outils

Les outils sont utilisés dans les chantiers ou les projets internes. Leur gestion inclut :

- **Sortie d’outil** : l’outil est attribué à un employé.
- **Suivi d’état** : on note l’état de l’outil avant et après utilisation.
- **Retour d’outil** : lorsqu’un outil revient, on met à jour sa fiche d’usage.

Ces données sont stockées dans la table `usage_exemplaires`.

---

## 📦 Équipements

Les équipements, quant à eux, suivent une logique de **stock** et de **vente**. Ils sont considérés comme des biens destinés à être cédés aux partenaires ou clients. La logique de gestion de stock inclut :

- Suivi des exemplaires disponibles.
- Passage de commande.
- Réduction du stock après vente.

---

## 🔍 Résumé

| Type de produit | Usage principal     | Logique associée       |
| --------------- | ------------------- | ---------------------- |
| Équipement      | Vente               | Stock / Commande       |
| Outil           | Utilisation terrain | Sortie / Retour / État |

Cette distinction permet d’adapter les traitements métier à la nature réelle du produit.



================================================
File: modules/stocks/controllers/achat.controller.js
================================================
/**
 * Ce fichier est utilisÃ© pour modifier les informations de prix pour une livraison d'exemplaire
 * 
 * 
 */
const achatService = require("../services/achat.service");

const updateAchat = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const result = await achatService.updateAchatFields(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(400).json({ error: "Ã‰chec de la mise Ã  jour", details: error.message });
  }
};

const getAchatById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const result = await achatService.getAchatById(id);
    if (!result) return res.status(404).json({ error: "Achat introuvable" });
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: "Erreur serveur", details: error.message });
  }
};

const getAllAchats = async (req, res) => {
  try {
    const result = await achatService.getAllAchats();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: "Erreur serveur", details: error.message });
  }
};



const getAchatByExemplaireId = async (req, res) => {
    try {
      const idExemplaire = parseInt(req.params.id);
      if (isNaN(idExemplaire)) {
        return res.status(400).json({ error: "ID exemplaire invalide" });
      }
  
      const result = await achatService.getAchatByExemplaireId(idExemplaire);
      if (!result) {
        return res.status(404).json({ error: "Achat introuvable pour cet exemplaire" });
      }
  
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: "Erreur serveur", details: error.message });
    }
  };



module.exports = {
  updateAchat,
  getAchatById,
  getAllAchats,
  getAchatByExemplaireId,
};



================================================
File: modules/stocks/controllers/categorie.controller.js
================================================
const categorieService = require("../services/categorie.service");

// CREATE
const createCategorie = async (req, res) => {
  try {
    if (!req.body.libelle) {
      return res.status(400).json({ error: "Le libellÃ© est requis" });
    }
    const result = await categorieService.createCategorie(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getCategories = async (req, res) => {
  try {
    const result = await categorieService.getCategories();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getCategorieById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await categorieService.getCategorieById(id);
    if (!result) {
      return res.status(404).json({ error: "Categorie non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateCategorie = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await categorieService.updateCategorie(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteCategorie = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await categorieService.deleteCategorie(id);
    res.json({ message: "Categorie supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};


module.exports = {
  createCategorie,
  getCategories,
  getCategorieById,
  updateCategorie,
  deleteCategorie
};


================================================
File: modules/stocks/controllers/commande.controller.js
================================================
const commandeService = require("../services/commande.service");

const createCommande = async (req, res) => {
  try {
    const commande = await commandeService.createCommande(req.body);
    res.status(201).json(commande);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

const getCommandeById = async (req, res) => {
  try {
    const commande = await commandeService.getCommandeById(
      Number(req.params.id)
    );
    res.status(200).json(commande);
  } catch (err) {
    res.status(404).json({ error: err.message });
  }
};

/**
 * Exemple d'utilisation
 *
 * GET /api/commandes?limit=10&offset=20&etat=confirmee
 *
 */

const getAllCommandes = async (req, res) => {
  try {
    const { limit, offset, etat } = req.query;
    const commandes = await commandeService.getAllCommandes({
      limit: Number(limit) || 50,
      offset: Number(offset) || 0,
      etat,
    });
    res.status(200).json(commandes);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

const updateCommande = async (req, res) => {
  try {
    const commande = await commandeService.updateCommande(
      Number(req.params.id),
      req.body
    );
    res.status(200).json(commande);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

const deleteCommande = async (req, res) => {
  try {
    const result = await commandeService.deleteCommande(Number(req.params.id));
    res.status(200).json(result);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

module.exports={
  getCommandeById,
  getAllCommandes,
  updateCommande,
  deleteCommande,
  createCommande
}



================================================
File: modules/stocks/controllers/exemplaire.controller.js
================================================
const exemplaireService = require("../services/exemplaire.service");

const createExemplaire = async (req, res) => {
  try {
    const result = await exemplaireService.createExemplaire(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getExemplaires = async (req, res) => {
  try {
    const result = await exemplaireService.getExemplaires();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getExemplaireById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await exemplaireService.getExemplaireById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

//rechercher un exemplaire Ã  partir d'un numÃ©ro de series
const getExemplaireByNumSerie = async (req, res) => {
  try {
    const num_serie = req.params.num_serie;

    const result = await exemplaireService.getExemplaireByNumSerie(num_serie);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateExemplaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const data = req.body;

    if (!data || typeof data !== "object") {
      throw new Error(
        "Les donnÃ©es Ã  mettre Ã  jour sont invalides ou manquantes."
      );
    }

    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await exemplaireService.updateExemplaire(id, data);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteExemplaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await exemplaireService.deleteExemplaire(id);
    return res.json({ message: "Ã©lÃ©ment supprimÃ© avec succÃ¨s" });
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

// obtenir tout les exemplaires d'un produit
const getExemplairesByProduit = async (req, res) => {
  try {
    const id = req.params.id;

    if (!id) {
      return res.status(400).json({ message: "paramÃ¨tre manquant" });
    }

    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }

    const result = await exemplaireService.getExemplairesByProduit(
      parseInt(id)
    );
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

//filtrer les exemplaires selon leur etat (disponible,vendu...)
const filterExemplairesByEtat = async (req, res) => {
  try {
    const { id, etat } = req.params;

    // VÃ©rification des paramÃ¨tres
    if (!id || !etat) {
      return res.status(400).json({ error: "ParamÃ¨tres requis : id et etat" });
    }

    const parsedId = parseInt(id);

    if (isNaN(parsedId)) {
      return res
        .status(400)
        .json({ error: "ID invalide (doit Ãªtre un nombre)" });
    }

    // Liste blanche des Ã©tats valides
    const etatsAutorises = [
      "Disponible",
      "Vendu",
      "Utilisation",
      "En maintenance",
      "Endommage",
      "Reserve",
    ];
    if (!etatsAutorises.includes(etat)) {
      return res.status(400).json({
        error: `Etat invalide. Les Ã©tats autorisÃ©s sont : ${etatsAutorises.join(
          ", "
        )}`,
      });
    }

    const results = await exemplaireService.filterExemplairesByEtat(
      parsedId,
      etat
    );
    return res.status(200).json(results);
  } catch (error) {
    return res.status(500).json({
      error: "Une erreur est survenue lors du filtrage",
      details: error.message,
    });
  }
};


// // VÃ©rifie si un exemplaire spÃ©cifique est en cours d'utilisation
// const isExemplaireInUse = async (req, res) => {
//   try {
//     const id = req.param.id;
//     const results = await exemplaireService.isExemplaireInUse(parseInt(id));
//     return res.status(200).json(results);
//   } catch (error) {
//     return res.status(500).json({
//       error: "Une erreur est survenue",
//       details: error.message,
//     });
//   }
// };

// // RÃ©cupÃ¨re tous les exemplaires actuellement en cours d'utilisation
// const isExemplairesInUse = async (req, res) => {
//   try {
//     const results = await exemplaireService.isExemplairesInUse();
//     return res.status(200).json(results);
//   } catch (error) {
//     return res.status(500).json({
//       error: "Une erreur est survenue",
//       details: error.message,
//     });
//   }
// };

module.exports = {
  createExemplaire,
  getExemplaires,
  getExemplaireById,
  getExemplaireByNumSerie,
  updateExemplaire,
  deleteExemplaire,
  getExemplairesByProduit,
  // isExemplaireInUse,
  // isExemplairesInUse,

  filterExemplairesByEtat,
};



================================================
File: modules/stocks/controllers/famille.controller.js
================================================
const familleService = require("../services/famille.service");

// CREATE
const createFamille = async (req, res) => {
  try {
    if (!req.body.libelle_famille) {
      return res.status(400).json({ error: "Le libellÃ© est requis" });
    }
    const result = await familleService.createFamille(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getFamilles = async (req, res) => {
  try {
    const result = await familleService.getFamilles();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getFamilleById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await familleService.getFamilleById(id);
    if (!result) {
      return res.status(404).json({ error: "Famille non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateFamille = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await familleService.updateFamille(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteFamille = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await familleService.deleteFamille(id);
    res.json({ message: "Famille supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};


module.exports = {
  createFamille,
  getFamilles,
  getFamilleById,
  updateFamille,
  deleteFamille
};


================================================
File: modules/stocks/controllers/livraison.controller.js
================================================
const livraisonService = require("../services/livraison.service");

// CREATE
const createLivraison = async (req, res) => {
  try {
    const result = await livraisonService.createLivraison(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la crÃ©ation",
      details: error.message,
    });
  }
};

// READ ALL
const getLivraisons = async (req, res) => {
  try {
    const result = await livraisonService.getLivraisons();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message,
    });
  }
};

// READ ONE
const getLivraisonById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await livraisonService.getLivraisonById(id);
    if (!result) {
      return res.status(404).json({ error: "Livraison non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message,
    });
  }
};

// UPDATE
const updateLivraison = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await livraisonService.updateLivraison(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la mise Ã  jour",
      details: error.message,
    });
  }
};

// DELETE
const deleteLivraison = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await livraisonService.deleteLivraison(id);
    res.json({ message: "Livraison supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la suppression",
      details: error.message,
    });
  }
};

// Voir les exemplaires ajoutÃ©s lors dâ€™une livraisons
const getLivraisonExemplaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await livraisonService.getLivraisonExemplaire(id);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      error: "Une erreur est survenue",
      details: error.message,
    });
  }
};

module.exports = {
  createLivraison,
  getLivraisons,
  getLivraisonById,
  updateLivraison,
  deleteLivraison,
  getLivraisonExemplaire
};



================================================
File: modules/stocks/controllers/marque.controller.js
================================================
const marqueService = require("../services/marque.service");

const createMarque = async (req, res) => {
  try {
    const result = await marqueService.createMarque(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getMarques = async (req, res) => {
  try {
    const result = await marqueService.getMarques();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getMarqueById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.getMarqueById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateMarque = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.updateMarque(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteMarque = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.deleteMarque(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createMarque,
  getMarques,
  getMarqueById,
  updateMarque,
  deleteMarque,
};



================================================
File: modules/stocks/controllers/modele.controller.js
================================================
const modeleService = require("../services/modele.service");

const createModele = async (req, res) => {
  try {
    const result = await modeleService.createModele(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getModeles = async (req, res) => {
  try {
    const result = await modeleService.getModeles();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getModeleById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.getModeleById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateModele = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.updateModele(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteModele = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.deleteModele(id);
    return res.json(result);
  } catch (error) {
    re
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createModele,
  getModeles,
  getModeleById,
  updateModele,
  deleteModele,
};



================================================
File: modules/stocks/controllers/produit.controller.js
================================================
const produitService = require("../services/produit.service");
const upload = require("../../utils/middleware/uploadMiddleware");
const path = require("path");
const fs = require("fs");

// Configuration du dossier d'upload (depuis la racine du projet)
const UPLOAD_DIR = path.join(process.cwd(), 'media', 'images', 'stock_moyensgeneraux', 'produits');

const createProduit = async (req, res) => {
  try {
    // Configuration du chemin d'upload pour cette requÃªte
    req.uploadPath = UPLOAD_DIR;
    
    // Utilisation du middleware Multer pour gÃ©rer l'upload
    upload.single('image_produit')(req, res, async (err) => {
      if (err) {
        return res.status(400).json({ 
          error: "Erreur lors de l'upload de l'image",
          details: err.message 
        });
      }

      // PrÃ©paration des donnÃ©es du produit
      const produitData = {
        ...req.body,
        // Si un fichier a Ã©tÃ© uploadÃ©, on stocke le chemin relatif
        image_produit: req.file 
          ? path.join('media', 'images', 'stock_moyensgeneraux', 'produits', req.file.filename)
          : null
      };

      const result = await produitService.createProduit(produitData);
      return res.status(201).json(result);
    });
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la crÃ©ation du produit", 
      details: error.message 
    });
  }
};

const getProduits = async (req, res) => {
  try {
    const produits = await produitService.getProduits();
    
    // Transformer les chemins d'images en URLs accessibles si nÃ©cessaire
    const result = produits.map(produit => ({
      ...produit,
      image_url: produit.image_produit 
        ? `${req.protocol}://${req.get('host')}/${produit.image_produit.replace(/\\/g, '/')}`
        : null
    }));

    return res.status(200).json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la rÃ©cupÃ©ration des produits", 
      details: error.message 
    });
  }
};

const getProduitsByTypes = async (req, res) => {
  try {
    const idType = parseInt(req.params.idType);
    if (isNaN(idType)) {
      return res.status(400).json({ error: "ID de type de produit invalide" });
    }
    
    const produits = await produitService.getProduitsByTypes(Number(idType));
    
    // Transformer les chemins d'images en URLs accessibles si nÃ©cessaire
    const result = produits.map(produit => ({
      ...produit,
      image_url: produit.image_produit 
        ? `${req.protocol}://${req.get('host')}/${produit.image_produit.replace(/\\/g, '/')}`
        : null
    }));

    return res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la rÃ©cupÃ©ration des produits par type", 
      details: error.message 
    });
  }
};

const getProduitById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID de produit invalide" });
    }
    
    const produit = await produitService.getProduitById(Number(id));
    
    if (!produit) {
      return res.status(404).json({ error: "Produit non trouvÃ©" });
    }

    // Ajouter l'URL complÃ¨te de l'image si elle existe
    const result = {
      ...produit,
      image_url: produit.image_produit 
        ? `${req.protocol}://${req.get('host')}/${produit.image_produit.replace(/\\/g, '/')}`
        : null
    };

    return res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la rÃ©cupÃ©ration du produit", 
      details: error.message 
    });
  }
};

const updateProduit = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID de produit invalide" });
    }

    req.uploadPath = UPLOAD_DIR;
    
    upload.single('image_produit')(req, res, async (err) => {
      if (err) {
        return res.status(400).json({ 
          error: "Erreur lors de l'upload de l'image",
          details: err.message 
        });
      }

      // RÃ©cupÃ©rer l'ancien produit pour supprimer l'image existante si nÃ©cessaire
      const existingProduit = await produitService.getProduitById(id);
      if (!existingProduit) {
        return res.status(404).json({ error: "Produit non trouvÃ©" });
      }

      // PrÃ©paration des donnÃ©es de mise Ã  jour
      const updateData = {
        ...req.body,
        updated_at: new Date()
      };

      if (req.file) {
        // Si une nouvelle image est uploadÃ©e
        updateData.image_produit = path.join('media', 'images', 'stock_moyensgeneraux', 'produits', req.file.filename);
        
        // Supprimer l'ancienne image si elle existe
        if (existingProduit.image_produit) {
          const oldImagePath = path.join(process.cwd(), existingProduit.image_produit);
          if (fs.existsSync(oldImagePath)) {
            fs.unlinkSync(oldImagePath);
          }
        }
      }

      const result = await produitService.updateProduit(id, updateData);
      return res.json(result);
    });
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la mise Ã  jour du produit", 
      details: error.message 
    });
  }
};

const deleteProduit = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID de produit invalide" });
    }

    // RÃ©cupÃ©rer le produit avant suppression pour supprimer son image
    const produit = await produitService.getProduitById(id);
    if (!produit) {
      return res.status(404).json({ error: "Produit non trouvÃ©" });
    }

    const result = await produitService.deleteProduit(id);

    // Supprimer l'image associÃ©e si elle existe
    if (produit.image_produit) {
      const imagePath = path.join(process.cwd(), produit.image_produit);
      if (fs.existsSync(imagePath)) {
        fs.unlinkSync(imagePath);
      }
    }

    return res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la suppression du produit", 
      details: error.message 
    });
  }
};

module.exports = {
  createProduit,
  getProduits,
  getProduitById,
  updateProduit,
  deleteProduit,
  getProduitsByTypes
};


================================================
File: modules/stocks/controllers/sortiesExemplaire.controller.js
================================================
const sortiesService = require("../services/sortiesExemplaire.service");

const getAllSorties = async (req, res) => {
  try {
    const result = await sortiesService.getAllSorties();
    return res.status(200).json(result || []);
  } catch (error) {
    res.status(500).json({ error: "Une erreur est survenue", details: error.message });
  }
};

const getSortieById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) return res.status(400).json({ error: "ID invalide" });

    const result = await sortiesService.getSortieById(id);
    return res.json(result);
  } catch (error) {
    res.status(500).json({ error: "Une erreur est survenue", details: error.message });
  }
};

/**
 * Test utilisation
 * {
  "type_sortie": "Vente directe",
  "reference_id": 101,
  "date_sortie": "2025-04-25T10:00:00Z",
  "id_exemplaire": 6
}

 */
const createSortie = async (req, res) => {
  try {
    const result = await sortiesService.createSortie(req.body);
    res.status(201).json(result[0]);
  } catch (error) {
    res.status(400).json({ error: "Ã‰chec de la crÃ©ation", details: error.message });
  }
};

const updateSortie = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) return res.status(400).json({ error: "ID invalide" });

    const result = await sortiesService.updateSortie(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(400).json({ error: "Ã‰chec de la mise Ã  jour", details: error.message });
  }
};

const deleteSortie = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) return res.status(400).json({ error: "ID invalide" });

    const result = await sortiesService.deleteSortie(id);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: "Une erreur est survenue", details: error.message });
  }
};

module.exports = {
  getAllSorties,
  getSortieById,
  createSortie,
  updateSortie,
  deleteSortie,
};



================================================
File: modules/stocks/controllers/stocks.controller.js
================================================
ï»¿// const stockService = require('../services/stocks.service');

// module.exports = {
//   getAll: (req, res, next) => {
//     try {
//       const stockItems = stockService.getAllStockItems();
//       res.json(stockItems);
//     } catch (err) {
//       next(err);
//     }
//   },
//   create: (req, res, next) => {
//     try {
//       const newItem = stockService.createStockItem(req.body);
//       res.status(201).json(newItem);
//     } catch (err) {
//       next(err);
//     }
//   }
// };


================================================
File: modules/stocks/controllers/typesProduit.controller.js
================================================
const typeProduitService = require("../services/typesProduit.service");

// CREATE
const createTypeProduit = async (req, res) => {
  try {
    if (!req.body.libelle) {
      return res.status(400).json({ error: "Le libellÃ© est requis" });
    }
    const result = await typeProduitService.createTypeProduit(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getTypeProduits = async (req, res) => {
  try {
    const result = await typeProduitService.getTypeProduits();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getTypeProduitById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await typeProduitService.getTypeProduitById(id);
    if (!result) {
      return res.status(404).json({ error: "TypeProduit non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateTypeProduit = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await typeProduitService.updateTypeProduit(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteTypeProduit = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await typeProduitService.deleteTypeProduit(id);
    res.json({ message: "TypeProduit supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};


module.exports = {
  createTypeProduit,
  getTypeProduits,
  getTypeProduitById,
  updateTypeProduit,
  deleteTypeProduit
};


================================================
File: modules/stocks/routes/achat.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/achat.controller");

/**
 * id: id de la livraison
 */
router.get("/", controller.getAllAchats);
router.get("/:id", controller.getAchatById);
router.put("/:id", controller.updateAchat);
router.get("/exemplaire/:id", controller.getAchatByExemplaireId);

module.exports = router;



================================================
File: modules/stocks/routes/categorie.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/categorie.controller");

// CRUD Routes
router.post("/", controller.createCategorie);
router.get("/", controller.getCategories);
router.get("/:id", controller.getCategorieById);
router.put("/:id", controller.updateCategorie);
router.delete("/{:id}", controller.deleteCategorie);

module.exports = router;


================================================
File: modules/stocks/routes/commande.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/commande.controller");


router.post("/", controller.createCommande);
router.get("/", controller.getAllCommandes);
router.get("/:id", controller.getCommandeById);
router.put("/:id", controller.updateCommande);
router.delete("/:id", controller.deleteCommande);

module.exports = router;



================================================
File: modules/stocks/routes/exemplaire.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/exemplaire.controller");

// CRUD Routes
router.post("/", controller.createExemplaire);
router.get("/", controller.getExemplaires);
router.get("/:id", controller.getExemplaireById);
router.get("/series/:num_serie", controller.getExemplaireByNumSerie); //rechercher un exemplaire Ã  partir d'un numÃ©ro de series
router.put("/:id", controller.updateExemplaire);
router.delete("/:id", controller.deleteExemplaire);

router.get("/produit/:id", controller.getExemplairesByProduit); // id et code forme la clÃ© Ã©trangÃ¨re composÃ©e de la table produit
// router.get("/:id/is-in-use", controller.isExemplaireInUse); // VÃ©rifie si un exemplaire spÃ©cifique est en cours d'utilisation
// router.get("/in-use", controller.isExemplairesInUse); // RÃ©cupÃ¨re tous les exemplaires actuellement en cours d'utilisation

//id: id du produit
router.get("/produit/:id/etat/:etat", controller.filterExemplairesByEtat); //   filtrer les exemplaires selon leur etat (disponible,vendu...)

module.exports = router;



================================================
File: modules/stocks/routes/famille.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/famille.controller");

// CRUD Routes
router.post("/", controller.createFamille);
router.get("/", controller.getFamilles);
router.get("/:id", controller.getFamilleById);
router.put("/:id", controller.updateFamille);
router.delete("/:id", controller.deleteFamille);

module.exports = router;


================================================
File: modules/stocks/routes/livraison.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/livraison.controller");

// CRUD Routes
router.post("/", controller.createLivraison);
router.get("/", controller.getLivraisons);
router.get("/:id", controller.getLivraisonById);
router.put("/:id", controller.updateLivraison);
router.delete("/:id", controller.deleteLivraison);
router.delete("/livraisons/:id/exemplaires", controller.getLivraisonExemplaire); //Voir les exemplaires ajoutÃ©s lors dâ€™une livraison

module.exports = router;


================================================
File: modules/stocks/routes/marque.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/marque.controller");

// CRUD Routes
router.post("/", controller.createMarque);
router.get("/", controller.getMarques);
router.get("/:id", controller.getMarqueById);
router.put("/:id", controller.updateMarque);
router.delete("/:id", controller.deleteMarque);

module.exports = router;



================================================
File: modules/stocks/routes/modele.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/modele.controller");

// CRUD Routes
router.post("/", controller.createModele);
router.get("/", controller.getModeles);
router.get("/:id", controller.getModeleById);
router.put("/:id", controller.updateModele);
router.delete("/:id", controller.deleteModele);

module.exports = router;



================================================
File: modules/stocks/routes/produit.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/produit.controller");

// CRUD Routes
router.post("/", controller.createProduit);
router.get("/", controller.getProduits);
router.get("/:id", controller.getProduitById);
router.get("/:idType", controller.getProduitsByTypes); // afficher tous les outils/Ã©quipements
router.put("/:id", controller.updateProduit);
router.delete("/:id", controller.deleteProduit);

module.exports = router;



================================================
File: modules/stocks/routes/sortiesExemplaire.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/sortiesExemplaire.controller");


router.get("/", controller.getAllSorties);
router.get("/:id", controller.getSortieById);
router.post("/", controller.createSortie);
router.put("/:id", controller.updateSortie);
router.delete("/:id", controller.deleteSortie);

module.exports = router;


================================================
File: modules/stocks/routes/stocks.routes.js
================================================
ï»¿const express = require("express");
const router = express.Router();

// Import des sous-routes
const familleRoutes = require("./famille.routes");
const categorieRoutes = require("./categorie.route");
const marqueRoutes = require("./marque.routes");
const modeleRoutes = require("./modele.routes");
const produitRoutes = require("./produit.routes");
const exemplaireRoutes = require("./exemplaire.routes");
const livraisonRoutes = require("./livraison.routes");
const typesProduitRoutes = require("./typesProduit.routes");
const commandeRoutes = require("./commande.route");
const sortiesExemplairesRoutes = require("./sortiesExemplaire.route");
const achatRoutes = require("./achat.route");

// Montage des routes
router.use("/familles", familleRoutes);
router.use("/categories", categorieRoutes);
router.use("/marques", marqueRoutes);
router.use("/modeles", modeleRoutes);
router.use("/produits", produitRoutes);
router.use("/exemplaires", exemplaireRoutes);
router.use("/livraisons", livraisonRoutes);
router.use("/types-produits", typesProduitRoutes);
router.use("/commandes", commandeRoutes);
router.use("/sorties-exemplaires", sortiesExemplairesRoutes);
router.use("/achats", achatRoutes);

module.exports = router;



================================================
File: modules/stocks/routes/typesProduit.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/typesProduit.controller");

// CRUD Routes
router.post("/", controller.createTypeProduit);
router.get("/", controller.getTypeProduits);
router.get("/:id", controller.getTypeProduitById);
router.put("/:id", controller.updateTypeProduit);
router.delete("/:id", controller.deleteTypeProduit);

module.exports = router;



================================================
File: modules/stocks/services/achat.service.js
================================================
/**
 * Ce fichier est utilisÃ© pour modifier les informations de prix pour une livraison d'exemplaire
 *
 *
 */
const { eq } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
const { livraisons, exemplaires } = require("../../../core/database/models");

// Met Ã  jour uniquement les champs liÃ©s Ã  l'achat dans la table livraisons
// Et met Ã  jour le prix_exemplaire de tous les exemplaires liÃ©s si prix_de_vente est fourni
const updateAchatFields = async (id, data) => {
  const allowedFields = [
    "prix_achat",
    "frais_divers",
    "prix_de_revient",
    "prix_de_vente",
    "periode_achat",
  ];

  // On ne conserve que les champs autorisÃ©s Ã  Ãªtre modifiÃ©s
  const cleanData = Object.fromEntries(
    Object.entries(data).filter(([key]) => allowedFields.includes(key))
  );

  // Mise Ã  jour des champs dans la table livraisons
  const [result] = await db
    .update(livraisons)
    .set({
      ...cleanData,
      updated_at: new Date(),
    })
    .where(eq(livraisons.id_livraison, id))
    .returning();

  // Si prix_de_vente est fourni, on met Ã  jour le champ prix_exemplaire
  // de tous les exemplaires liÃ©s Ã  cette livraison
  if (cleanData.prix_de_vente !== undefined) {
    await db
      .update(exemplaires)
      .set({
        prix_exemplaire: cleanData.prix_de_vente,
        updated_at: new Date(),
      })
      .where(eq(exemplaires.id_livraison, id));
  }

  return result;
};

// RÃ©cupÃ¨re les informations d'achat d'une livraison Ã  partir de son ID
const getAchatById = async (id) => {
  const [result] = await db
    .select()
    .from(livraisons)
    .where(eq(livraisons.id_livraison, id));

  if (!result) return null;

  return {
    id: result.id_livraison,
    prix_achat: result.prix_achat,
    frais_divers: result.frais_divers,
    prix_de_revient: result.prix_de_revient,
    prix_de_vente: result.prix_de_vente,
    periode_achat: result.periode_achat,
  };
};

// RÃ©cupÃ¨re tous les enregistrements d'achat avec les champs d'achat uniquement
const getAllAchats = async () => {
  const rows = await db.select().from(livraisons);
  return rows.map((row) => ({
    id: row.id_livraison,
    prix_achat: row.prix_achat,
    frais_divers: row.frais_divers,
    prix_de_revient: row.prix_de_revient,
    prix_de_vente: row.prix_de_vente,
    periode_achat: row.periode_achat,
  }));
};

// RÃ©cupÃ¨re les infos d'achat Ã  partir d'un exemplaire spÃ©cifique (via son id_livraison)
const getAchatByExemplaireId = async (id_exemplaire) => {
  const [ex] = await db
    .select()
    .from(exemplaires)
    .where(eq(exemplaires.id_exemplaire, id_exemplaire));
  if (!ex) return null;

  const [achat] = await db
    .select()
    .from(livraisons)
    .where(eq(livraisons.id_livraison, ex.id_livraison));
  if (!achat) return null;

  return {
    id: achat.id_livraison,
    prix_achat: achat.prix_achat,
    frais_divers: achat.frais_divers,
    prix_de_revient: achat.prix_de_revient,
    prix_de_vente: achat.prix_de_vente,
    periode_achat: achat.periode_achat,
  };
};

module.exports = {
  updateAchatFields,
  getAchatById,
  getAllAchats,
  getAchatByExemplaireId,
};



================================================
File: modules/stocks/services/categorie.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { categories } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createCategorie = async (data) => {
  const [result] = await db.insert(categories).values(data).returning();
  return result;
};

const getCategories = async () => {
  return await db.select().from(categories);
};

const getCategorieById = async (id) => {
  const [result] = await db
    .select()
    .from(categories)
    .where(eq(categories.id_categorie, id));
  return result;
};

const updateCategorie = async (id, data) => {
  const [result] = await db
    .update(categories)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(categories.id_categorie, id))
    .returning();
  return result;
};

const deleteCategorie = async (id) => {
  const [result] = await db
    .delete(categories)
    .where(eq(categories.id_categorie, id))
    .returning();
  return result;
};

module.exports = {
  createCategorie,
  getCategories,
  getCategorieById,
  updateCategorie,
  deleteCategorie,
};



================================================
File: modules/stocks/services/commande.service.js
================================================
const { and, eq, inArray, sql } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
const {
  exemplaires,
  produits,
  commandes,
  partenaires,
  partenaire_commandes,
  sortie_exemplaires,
} = require("../../../core/database/models");

const {etatExemplaire}=require('./exemplaire.service')

const typeSortie = ["vente directe", "vente en ligne", "projet"];

/**
 * Effectue un achat d'exemplaires par un partenaire.
 *
 * Étapes :
 * 1. Validation des données d'entrée
 * 2. Vérification de la disponibilité des exemplaires
 * 3. Création de la commande
 * 4. Liaison commande-partenaire
 * 5. Mise à jour des exemplaires vendus
 * 6. Ajustement du stock produit
 * 7. Retour de la commande complète avec ses exemplaires
 *
 * @param {Object} params
 * @param {number[]} params.exemplaireIds - IDs des exemplaires à acheter
 * @param {number} params.partenaireId - ID du partenaire acheteur
 * @param {string} params.lieuLivraison - Lieu de livraison
 * @param {Date} [params.dateCommande=new Date()] - Date de commande
 * @param {Date} params.dateLivraison - Date de livraison prévue
 * @param {string} params.modePaiement - Mode de paiement
 * @returns {Promise<Object>} Commande complète avec les exemplaires liés
 */

// créer une commande
async function createCommande({
  exemplaireIds,
  partenaireId,
  lieuLivraison,
  dateCommande = new Date(),
  dateLivraison,
  modePaiement,
}) {
  return await db.transaction(async (tx) => {
    // 1. Validation des entrées
    if (!exemplaireIds?.length) throw new Error("Aucun exemplaire spécifié");
    if (!partenaireId) throw new Error("Partenaire non spécifié");

    // 2. Vérification des exemplaires
    const exemplairesToOrder = await tx
      .select()
      .from(exemplaires)
      .where(
        and(
          inArray(exemplaires.id_exemplaire, exemplaireIds),
          eq(exemplaires.etat_exemplaire, etatExemplaire[1]) //"Disponible"
        )
      );

    if (exemplairesToOrder.length !== exemplaireIds.length) {
      const missing = exemplaireIds.filter(
        (id) => !exemplairesToOrder.some((e) => e.id_exemplaire === id)
      );
      throw new Error(
        `Exemplaires non disponibles ou introuvables: ${missing.join(", ")}`
      );
    }

    // 3. Création de la commande
    const [newCommande] = await tx
      .insert(commandes)
      .values({
        date_de_commande: new Date(dateCommande),
        etat_commande: "en cours",
        date_livraison: new Date(dateLivraison),
        lieu_de_livraison: lieuLivraison,
        mode_de_paiement: modePaiement,
        created_at: new Date(),
        updated_at: new Date(),
      })
      .returning();

    // 4. Liaison partenaire-commande
    await tx.insert(partenaire_commandes).values({
      id_partenaire: partenaireId,
      id_commande: newCommande.id_commande,
      created_at: new Date(),
      updated_at: new Date(),
    });

    // 5. Mise à jour des exemplaires
    await tx
      .update(exemplaires)
      .set({
        etat_exemplaire: "Vendu",
        id_commande: newCommande.id_commande,
        updated_at: new Date(),
      })
      .where(inArray(exemplaires.id_exemplaire, exemplaireIds));

    // 6. Enregistrement dans sortie_exemplaires
    for (const exemplaireId of exemplaireIds) {
      await tx.insert(sortie_exemplaires).values({
        type_sortie: typeSortie[0],
        reference_id: newCommande.id_commande,
        date_sortie: new Date(),
        id_exemplaire: exemplaireId,
        created_at: new Date(),
        updated_at: new Date(),
      });
    }

    // 7. Mise à jour des stocks produits
    const produitsQuantites = exemplairesToOrder.reduce((acc, exemplaire) => {
      acc[exemplaire.id_produit] = (acc[exemplaire.id_produit] || 0) + 1;
      return acc;
    }, {});

    for (const [produitId, quantite] of Object.entries(produitsQuantites)) {
      await tx
        .update(produits)
        .set({
          qte_produit: sql`${produits.qte_produit} - ${quantite}`,
          updated_at: new Date(),
        })
        .where(eq(produits.id_produit, Number(produitId)));
    }

    // 8. Récupération de la commande complète
    const completeCommande = {
      ...newCommande,
      exemplaires: exemplairesToOrder,
      partenaire: { id_partenaire: partenaireId },
      sorties: exemplaireIds.map((id) => ({
        id_exemplaire: id,
        type_sortie: typeSortie[0],
        reference_id: newCommande.id_commande,
      })),
    };

    return completeCommande;
  });
}

// 🔍 Lire une commande avec détails
async function getCommandeById(idCommande) {
  const [row] = await db
    .select({
      commande: commandes,
      partenaire: partenaires,
    })
    .from(commandes)
    .leftJoin(
      partenaire_commandes,
      eq(commandes.id_commande, partenaire_commandes.id_commande)
    )
    .leftJoin(
      partenaires,
      eq(partenaire_commandes.id_partenaire, partenaires.id_partenaire)
    )
    .where(eq(commandes.id_commande, idCommande));

  if (!row) throw new Error("Commande introuvable");

  // Charger les exemplaires liés
  const exemplairesAssocies = await db
    .select()
    .from(exemplaires)
    .where(eq(exemplaires.id_commande, idCommande));

  return {
    ...row.commande,
    partenaire: row.partenaire || null,
    exemplaires: exemplairesAssocies,
  };
}

// 📜 Liste paginée ou filtrée des commandes
async function getAllCommandes({ limit = 50, offset = 0, etat = null } = {}) {
  let query = db
    .select()
    .from(commandes)
    .leftJoin(
      partenaire_commandes,
      eq(commandes.id_commande, partenaire_commandes.id_commande)
    )
    .leftJoin(
      partenaires,
      eq(partenaire_commandes.id_partenaire, partenaires.id_partenaire)
    );

  if (etat) {
    query = query.where(eq(commandes.etat_commande, etat));
  }

  return await query.limit(limit).offset(offset);
}

// 📝 Mise à jour d'une commande
async function updateCommande(idCommande, updateData) {
  const allowedFields = [
    "date_livraison",
    "lieu_de_livraison",
    "etat_commande",
    "mode_de_paiement",
  ];

  const updatePayload = Object.fromEntries(
    Object.entries(updateData).filter(([key]) => allowedFields.includes(key))
  );

  if (!Object.keys(updatePayload).length) {
    throw new Error("Aucune donnée valide à mettre à jour");
  }

  updatePayload.updated_at = new Date();

  const [result] = await db
    .update(commandes)
    .set(updatePayload)
    .where(eq(commandes.id_commande, idCommande))
    .returning();

  if (!result) throw new Error("Commande non trouvée");

  return getCommandeById(idCommande);
}

// ❌ Suppression d'une commande complète
async function deleteCommande(idCommande) {
  // 1. Récupération des exemplaires liés à cette commande
  const exemplairesAssocies = await db
    .select()
    .from(exemplaires)
    .where(eq(exemplaires.id_commande, idCommande));

  // 2. Suppression des liaisons avec les partenaires et des sorties
  await Promise.all([
    db
      .delete(partenaire_commandes)
      .where(eq(partenaire_commandes.id_commande, idCommande)),

    db.delete(sortie_exemplaires).where(
      and(
        eq(sortie_exemplaires.reference_id, idCommande),
        eq(sortie_exemplaires.type_sortie, typeSortie[0]) // "vente directe"
      )
    ),
  ]);

  // 3. Réinitialisation des exemplaires et mise à jour des stocks produits
  for (const ex of exemplairesAssocies) {
    await Promise.all([
      db
        .update(exemplaires)
        .set({
          id_commande: null,
          etat_exemplaire: etatExemplaire[1], //"Disponible"
          updated_at: new Date(),
        })
        .where(eq(exemplaires.id_exemplaire, ex.id_exemplaire)),

      db
        .update(produits)
        .set({
          qte_produit: sql`${produits.qte_produit} + 1`,
          updated_at: new Date(),
        })
        .where(eq(produits.id_produit, ex.id_produit)),
    ]);
  }

  // 4. Suppression de la commande elle-même
  const result = await db
    .delete(commandes)
    .where(eq(commandes.id_commande, idCommande));

  if (result.rowCount === 0) throw new Error("Commande introuvable");

  return { success: true };
}

module.exports = {
  createCommande,
  getCommandeById,
  getAllCommandes,
  updateCommande,
  deleteCommande,
};



================================================
File: modules/stocks/services/exemplaire.service.js
================================================
const { eq, sql, and, inArray, isNull } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper");
const { exemplaires, produits } = require("../../../core/database/models");

/**
 *
 * vendu : exemplaire vendu
 * disponible : exemplaire disponible
 * in Use     : exemplaire (outils) en cours d'utilisation (par un employÃ©)
 */
const etatExemplaire = [
  "Vendu",
  "Disponible",
  "Utilisation",
  "En maintenance",
  "Endommage",
  "Reserve",
]; //liste des etats de l'exemplaire

/**
 * Services pour le modÃ¨le `exemplaires` (MVC)
 *
 * Ce fichier contient toutes les opÃ©rations CRUD et les services
 * nÃ©cessaires pour gÃ©rer les exemplaires et les commandes liÃ©es.
 */

/**
 * CrÃ©er un nouvel exemplaire et incrÃ©menter la quantitÃ© du produit associÃ©.
 */
async function createExemplaire(data) {
  const { id_produit, code_produit } = data;
  const [newExemplaire] = await db.insert(exemplaires).values(data).returning();

  // IncrÃ©menter la quantitÃ© du produit liÃ©
  await db
    .update(produits)
    .set({
      qte_produit: sql`${produits.qte_produit} + 1`,
      updated_at: sql`NOW()`,
    })
    .where(eq(produits.id_produit, id_produit));

  return newExemplaire;
}

async function getExemplaires() {
  return db.select().from(exemplaires);
}

async function getExemplaireById(id) {
  const [ex] = await db
    .select()
    .from(exemplaires)
    .where(eq(exemplaires.id_exemplaire, id));
  return ex;
}

//rechercher un exemplaire Ã  partir d'un numÃ©ro de series
async function getExemplaireByNumSerie(num_serie) {
  const [ex] = await db
    .select()
    .from(exemplaires)
    .where(eq(exemplaires.num_serie, num_serie));
  return ex;
}

async function updateExemplaire(id, data) {
  return await db.transaction(async (tx) => {
    // 1. VÃ©rification de l'existence de l'exemplaire
    const [current] = await tx
      .select()
      .from(exemplaires)
      .where(eq(exemplaires.id_exemplaire, id));

    if (!current) {
      throw new Error("Exemplaire non trouvÃ©");
    }

    // 2. VÃ©rification du changement de produit
    const produitChange =
      data.id_produit && data.id_produit !== current.id_produit;

    if (produitChange) {
      // 3. Validation du nouveau produit
      const [newProduct] = await tx
        .select()
        .from(produits)
        .where(eq(produits.id_produit, data.id_produit));

      if (!newProduct) {
        throw new Error("Nouveau produit non trouvÃ©");
      }

      // 4. Ajustement des quantitÃ©s (en une seule requÃªte pour chaque opÃ©ration)
      // DÃ©crÃ©mentation ancien produit
      await tx
        .update(produits)
        .set({
          qte_produit: sql`${produits.qte_produit} - 1`,
          updated_at: sql`NOW()`,
        })
        .where(eq(produits.id_produit, current.id_produit));

      // IncrÃ©mentation nouveau produit
      await tx
        .update(produits)
        .set({
          qte_produit: sql`${produits.qte_produit} + 1`,
          updated_at: sql`NOW()`,
        })
        .where(eq(produits.id_produit, data.id_produit));
    }

    // 5. Mise Ã  jour de l'exemplaire
    const [updated] = await tx
      .update(exemplaires)
      .set({
        ...data,
        updated_at: new Date(),
      })
      .where(eq(exemplaires.id_exemplaire, id))
      .returning();

    return updated;
  });
}

async function deleteExemplaire(id) {
  return await db.transaction(async (tx) => {
    // 1. VÃ©rification de l'existence de l'exemplaire
    const [toDelete] = await tx
      .select()
      .from(exemplaires)
      .where(eq(exemplaires.id_exemplaire, id));

    if (!toDelete) {
      throw new Error("Exemplaire non trouvÃ©");
    }

    // 2. VÃ©rification que la quantitÃ© ne deviendra pas nÃ©gative
    const [produit] = await tx
      .select({ qte_produit: produits.qte_produit })
      .from(produits)
      .where(eq(produits.id_produit, toDelete.id_produit));

    if (produit.qte_produit <= 0) {
      throw new Error("La quantitÃ© du produit est dÃ©jÃ  Ã  zÃ©ro");
    }

    // 3. DÃ©crÃ©mentation du stock produit
    const updateResult = await tx
      .update(produits)
      .set({
        qte_produit: sql`GREATEST(${produits.qte_produit} - 1, 0)`, // Ã‰vite les valeurs nÃ©gatives
        updated_at: sql`NOW()`,
      })
      .where(eq(produits.id_produit, toDelete.id_produit));

    if (updateResult.rowCount === 0) {
      throw new Error("Ã‰chec de la mise Ã  jour du produit");
    }

    // 4. Suppression de l'exemplaire
    const [deleted] = await tx
      .delete(exemplaires)
      .where(eq(exemplaires.id_exemplaire, id))
      .returning();

    return deleted;
  });
}

/** ---Autres requetes --- */

async function getExemplairesByProduit(id) {
  return db.select().from(exemplaires).where(eq(exemplaires.id_produit, id));
}

//filtrer les exemplaires selon leur etat (disponible,vendu...)
async function filterExemplairesByEtat(id, etat) {
  return db
    .select()
    .from(exemplaires)
    .where(
      and(
        eq(exemplaires.id_produit, id),
        eq(exemplaires.etat_exemplaire, etat)
      )
    );
}


// // // VÃ©rifie si un exemplaire spÃ©cifique est en cours d'utilisation
// // async function isExemplaireInUse(exId) {
// //   const [result] = await db
// //     .select()
// //     .from(usage_exemplaires)
// //     .where(
// //       and(
// //         eq(usage_exemplaires.id_exemplaire, exId),
// //         isNull(usage_exemplaires.date_retour_usage)
// //       )
// //     );

// //   return !!result; //retourne un boolÃ©en
// // }

// // RÃ©cupÃ¨re tous les exemplaires actuellement en cours d'utilisation
// async function isExemplairesInUse() {
//   return filterExemplairesByEtat(etatExemplaire[2]);
// }

module.exports = {
  createExemplaire,
  getExemplaires,
  getExemplaireById,
  getExemplaireByNumSerie,
  updateExemplaire,
  deleteExemplaire,
  getExemplairesByProduit,
  // isExemplaireInUse,
  // isExemplairesInUse,

  filterExemplairesByEtat,

  //variable
  etatExemplaire,
};

// /**
//  * RÃ©cupÃ¨re tous les exemplaires utilisÃ©s dans le cadre dâ€™un projet donnÃ©.

//  */
// async function getExemplairesByProjet(projectId) {
//   return db
//     .select()
//     .from(exemplaires)
//     .innerJoin(
//       usage_exemplaires,
//       eq(usage_exemplaires.id_exemplaire, exemplaires.id_exemplaire)
//     )
//     .where(eq(exemplaires.id_projet, projectId));
// }



================================================
File: modules/stocks/services/famille.service.js
================================================
// const { eq } = require("drizzle-orm");
// const dbConfig = require("../../../core/database/config");
// const { familles } = require("../../../core/database/models");

// // Solution robuste pour rÃ©cupÃ©rer db correctement
// const db = dbConfig.db || dbConfig.default;

// // Debug crucial
// console.log("MÃ©thodes Drizzle disponibles:", {
//   insert: typeof db.insert,
//   select: typeof db.select,
//   update: typeof db.update,
//   delete: typeof db.delete
// });

const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { familles } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createFamille = async (data) => {
  const [result] = await db.insert(familles).values(data).returning();
  return result;
};

const getFamilles = async () => {
  return await db.select().from(familles);
};

const getFamilleById = async (id) => {
  const [result] = await db.select().from(familles).where(eq(familles.id_famille, id));
  return result;
};

const updateFamille = async (id, data) => {
  const [result] = await db
    .update(familles)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(familles.id_famille, id))
    .returning();
  return result;
};

const deleteFamille = async (id) => {
  const [result] = await db
    .delete(familles)
    .where(eq(familles.id_famille, id))
    .returning();
  return result;
};

module.exports = {
  createFamille,
  getFamilles,
  getFamilleById,
  updateFamille,
  deleteFamille,
};



================================================
File: modules/stocks/services/livraison.service.js
================================================
// const { eq } = require("drizzle-orm");
// const dbConfig = require("../../../core/database/config");
// const { livraisons } = require("../../../core/database/models");

// // Solution robuste pour rÃ©cupÃ©rer db correctement
// const db = dbConfig.db || dbConfig.default;

// // Debug crucial
// console.log("MÃ©thodes Drizzle disponibles:", {
//   insert: typeof db.insert,
//   select: typeof db.select,
//   update: typeof db.update,
//   delete: typeof db.delete
// });

const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { livraisons, exemplaires } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createLivraison = async (data) => {
  const [result] = await db.insert(livraisons).values(data).returning();
  return result;
};

const getLivraisons = async () => {
  return await db.select().from(livraisons);
};

const getLivraisonById = async (id) => {
  const [result] = await db
    .select()
    .from(livraisons)
    .where(eq(livraisons.id_livraison, id));
  return result;
};

const updateLivraison = async (id, data) => {
  const [result] = await db
    .update(livraisons)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(livraisons.id_livraison, id))
    .returning();
  return result;
};

const deleteLivraison = async (id) => {
  const [result] = await db
    .delete(livraisons)
    .where(eq(livraisons.id_livraison, id))
    .returning();
  return result;
};

// [GET] /livraisons â†’ Liste des livraisons
// [POST] /livraisons â†’ Ajouter une livraisons (avec des exemplaires entrants)

// Voir les exemplaires ajoutÃ©s lors dâ€™une livraisons
const getLivraisonExemplaire = async (id) => {
  const [result] = await db
    .select(exemplaires)
    .where(eq(exemplaires.id_livraison, id));

  return result;
};

module.exports = {
  createLivraison,
  getLivraisons,
  getLivraisonById,
  updateLivraison,
  deleteLivraison,
  getLivraisonExemplaire,
};



================================================
File: modules/stocks/services/marque.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { marques } = require("../../../core/database/models");

const createMarque = async (data) => {
  const [result] = await db.insert(marques).values(data).returning();
  return result;
};

const getMarques = async () => {
  return await db.select().from(marques);
};

const getMarqueById = async (id) => {
  const [result] = await db
    .select()
    .from(marques)
    .where(eq(marques.id_marque, id));
  return result;
};

const updateMarque = async (id, data) => {
  const [result] = await db
    .update(marques)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(marques.id_marque, id))
    .returning();
  return result;
};

const deleteMarque = async (id) => {
  const [result] = await db
    .delete(marques)
    .where(eq(marques.id_marque, id))
    .returning();
  return result;
};

module.exports = {
  createMarque,
  getMarques,
  getMarqueById,
  updateMarque,
  deleteMarque,
};



================================================
File: modules/stocks/services/modele.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { modeles } = require("../../../core/database/models");

const createModele = async (data) => {
  const [result] = await db.insert(modeles).values(data).returning();
  return result;
};

const getModeles = async () => {
  return await db.select().from(modeles);
};

const getModeleById = async (id) => {
  const [result] = await db
    .select()
    .from(modeles)
    .where(eq(modeles.id_modele, id));
  return result;
};

const updateModele = async (id, data) => {
  const [result] = await db
    .update(modeles)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(modeles.id_modele, id))
    .returning();
  return result;
};

const deleteModele = async (id) => {
  const [result] = await db
    .delete(modeles)
    .where(eq(modeles.id_modele, id))
    .returning();
  return result;
};

module.exports = {
  createModele,
  getModeles,
  getModeleById,
  updateModele,
  deleteModele,
};



================================================
File: modules/stocks/services/produit.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const {
  produits,
} = require("../../../core/database/models");

const createProduit = async (data) => {
  const [result] = await db.insert(produits).values(data).returning();
  return result;
};

const getProduits = async () => {
  return await db.select().from(produits); 
};

// afficher tous les outils/Ã©quipements
const getProduitsByTypes = async (idType) => {
  return await db.select().from(produits).where(eq(produits.id_type_produit,idType)); 
};

const getProduitById = async (id) => {
  const [result] = await db
    .select()
    .from(produits)
    .where(eq(produits.id_produit, id));
  return result;
};

const updateProduit = async (id, data) => {
  const [result] = await db
    .update(produits)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(produits.id_produit, id))
    .returning();
  return result;
};

const deleteProduit = async (id) => {
  const [result] = await db
    .delete(produits)
    .where(eq(produits.id_produit, id))
    .returning();
  return result;
};


module.exports = {
  createProduit,
  getProduits,
  getProduitById,
  updateProduit,
  deleteProduit,
  getProduitsByTypes
};



================================================
File: modules/stocks/services/sortiesExemplaire.service.js
================================================
const { and, eq, inArray, sql } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
const {
  sortie_exemplaires,
  exemplaires,
  produits,
  commandes,
  partenaires,
  partenaire_commandes,
} = require("../../../core/database/models");

async function getAllSorties() {
  return await db
    .select({
      id: sortie_exemplaires.id_sortie_exemplaire,
      type: sortie_exemplaires.type_sortie,
      date: sortie_exemplaires.date_sortie,
      exemplaireId: sortie_exemplaires.id_exemplaire,
      produitId: produits.id_produit,
      produitDesi: produits.desi_produit,
      commandeId: commandes.id_commande,
      partenaireNom: partenaires.nom_partenaire,
    })
    .from(sortie_exemplaires)
    .leftJoin(exemplaires, eq(sortie_exemplaires.id_exemplaire, exemplaires.id_exemplaire))
    .leftJoin(produits, eq(exemplaires.id_produit, produits.id_produit))
    .leftJoin(commandes, eq(exemplaires.id_commande, commandes.id_commande))
    .leftJoin(partenaire_commandes, eq(commandes.id_commande, partenaire_commandes.id_commande))
    .leftJoin(partenaires, eq(partenaire_commandes.id_partenaire, partenaires.id_partenaire));
}

async function getSortieById(id) {
  return await db
    .select()
    .from(sortie_exemplaires)
    .where(eq(sortie_exemplaires.id_sortie_exemplaire, id));
}

async function createSortie({ type_sortie, reference_id, date_sortie, id_exemplaire }) {
  return await db
    .insert(sortie_exemplaires)
    .values({
      type_sortie,
      reference_id,
      date_sortie: new Date(date_sortie),
      id_exemplaire,
      created_at: new Date(),
      updated_at: new Date(),
    })
    .returning();
}

async function updateSortie(id, data) {
  return await db
    .update(sortie_exemplaires)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(sortie_exemplaires.id_sortie_exemplaire, id));
}

async function deleteSortie(id) {
  return await db
    .delete(sortie_exemplaires)
    .where(eq(sortie_exemplaires.id_sortie_exemplaire, id));
}

module.exports = {
  getAllSorties,
  getSortieById,
  createSortie,
  updateSortie,
  deleteSortie,
};



================================================
File: modules/stocks/services/stocks.service.js
================================================
// const { stocks } = require('../tests/stocks.mock');

// module.exports = {
//   getAllStockItems: () => {
//     return stocks;
//   },
//   createStockItem: (itemData) => {
//     const newItem = {
//       id: stocks.length + 1,
//       ...itemData,
//       last_updated: new Date()
//     };
//     stocks.push(newItem);
//     return newItem;
//   }
// };


================================================
File: modules/stocks/services/typesProduit.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { type_produits } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createTypeProduit = async (data) => {
  const [result] = await db.insert(type_produits).values(data).returning();
  return result;
};

const getTypeProduits = async () => {
  return await db.select().from(type_produits);
};

const getTypeProduitById = async (id) => {
  const [result] = await db
    .select()
    .from(type_produits)
    .where(eq(type_produits.id_type_produit, id));
  return result;
};

const updateTypeProduit = async (id, data) => {
  const [result] = await db
    .update(type_produits)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(type_produits.id_type_produit, id))
    .returning();
  return result;
};

const deleteTypeProduit = async (id) => {
  const [result] = await db
    .delete(type_produits)
    .where(eq(type_produits.id_type_produit, id))
    .returning();
  return result;
};

module.exports = {
  createTypeProduit,
  getTypeProduits,
  getTypeProduitById,
  updateTypeProduit,
  deleteTypeProduit,
};



================================================
File: modules/stocks/tests/stocks.mock.js
================================================
// module.exports = {
//   famille: [
//     {
//       id: 1,
//       libelle: "Informatique"
//     },
//     {
//       id: 2,
//       libelle: "Bureautique"
//     }
//   ],

//   categorie: [
//     {
//       id: 1,
//       libelle: "PÃ©riphÃ©rique"
//     },
//     {
//       id: 2,
//       libelle: "Composant"
//     }
//   ],

//   modele: [
//     {
//       id: 1,
//       libelle: "ProBook 450"
//     },
//     {
//       id: 2,
//       libelle: "ThinkPad X1"
//     }
//   ],

//   marque: [
//     {
//       id: 1,
//       libelle: "HP"
//     },
//     {
//       id: 2,
//       libelle: "Lenovo"
//     }
//   ],

//   fonction: [
//     {
//       id: 1,
//       nom: "DÃ©veloppeur"
//     },
//     {
//       id: 2,
//       nom: "Chef de projet"
//     }
//   ],

//   employes: [
//     {
//       id: 1,
//       nom: "Dupont",
//       keycloak_id: "a1b2c3d4-e5f6-7890",
//       prenom: "Jean",
//       email: "jean.dupont@example.com",
//       contact: "+123456789",
//       adresse: "123 Rue Example, Ville",
//       status: "Actif",
//       fonctionId: 1
//     },
//     {
//       id: 2,
//       nom: "Martin",
//       keycloak_id: "b2c3d4e5-f6g7-8901",
//       prenom: "Sophie",
//       email: "sophie.martin@example.com",
//       contact: "+987654321",
//       adresse: "456 Avenue Test, Ville",
//       status: "Actif",
//       fonctionId: 2
//     }
//   ],

//   demande: [
//     {
//       id: 1,
//       dateDebut: "2025-01-15",
//       status: "En cours",
//       dateFin: "2025-01-30",
//       motif: "Besoin d'un nouvel ordinateur",
//       type: "MatÃ©riel",
//       employeId: 1
//     }
//   ],

//   typeDoc: [
//     {
//       id: 1,
//       libelle: "Contrat"
//     },
//     {
//       id: 2,
//       libelle: "Facture"
//     }
//   ],

//   entite: [
//     {
//       id: 1,
//       libelle: "Direction"
//     },
//     {
//       id: 2,
//       libelle: "Service Technique"
//     }
//   ],

//   produit: [
//     {
//       id: 1,
//       code: "PROD001",
//       nom: "Ordinateur portable",
//       description: "Ordinateur portable haute performance",
//       type: "MatÃ©riel",
//       image: "images/prod001.jpg",
//       quantite: "10",
//       modeleId: 1,
//       categorieId: 1,
//       familleId: 1,
//       marqueId: 1
//     }
//   ],

//   documents: [
//     {
//       id: 1,
//       titre: "Contrat de travail",
//       fichier: "docs/contrat.pdf",
//       dateAjout: "2025-01-10",
//       employeId: 1,
//       typeDocId: 1
//     }
//   ],

//   partenaire: [
//     {
//       id: 1,
//       nom: "TechSolutions Inc.",
//       telephone: "+1234567890",
//       email: "contact@techsolutions.com",
//       specialite: "Informatique",
//       localisation: "123 Business Ave, City",
//       type: "Fournisseur",
//       entiteId: 1
//     }
//   ],

//   contrat: [
//     {
//       id: 1,
//       nom: "Contrat de maintenance",
//       duree: "1 an",
//       dateDebut: "2025-01-01",
//       dateFin: "2025-12-31",
//       lien: "contrats/2025/maintenance.pdf",
//       partenaireId: 1
//     }
//   ],

//   intervention: [
//     {
//       id: 1,
//       date: "2025-02-15",
//       causeDefaillance: "Panne matÃ©rielle",
//       rapport: "rapports/interv001.pdf",
//       typeMaintenance: "Corrective",
//       typeDefaillance: "MatÃ©rielle",
//       superviseur: "M. Responsable",
//       duree: "2 heures",
//       numero: "INT-2025-001",
//       lieu: "Bureau 101",
//       contratId: 1
//     }
//   ],

//   projet: [
//     {
//       id: 1,
//       nom: "Migration vers Windows 11",
//       type: "IT",
//       devis: "DEV-2025-001",
//       dateDebut: "2025-03-01",
//       dateFin: "2025-06-30",
//       duree: "4 mois",
//       description: "Migration de tous les postes vers Windows 11",
//       etat: "En cours",
//       partenaireId: 1,
//       familleId: 1
//     }
//   ],

//   livraison: [
//     {
//       id: 1,
//       autresFrais: "50",
//       periodeAchat: "Mars 2025",
//       prixAchat: "1200",
//       dedouanement: "100",
//       prixTransport: "150",
//       dateLivraison: "2025-03-15",
//       quantite: "5",
//       partenaireId: 1
//     }
//   ],

//   mission: [
//     {
//       id: 1,
//       nom: "DÃ©ploiement pilote",
//       description: "DÃ©ploiement initial sur 10 postes tests",
//       statut: "En cours",
//       lieu: "SiÃ¨ge social",
//       projetId: 1
//     }
//   ],

//   exemplaire: [
//     {
//       id: 1,
//       numSerie: "SN123456789",
//       prix: "1250",
//       etat: "Neuf",
//       livraisonId: 1,
//       produitId: 1,
//       produitCode: "PROD001"
//     }
//   ],

//   tache: [
//     {
//       id: 1,
//       nom: "Installation OS",
//       description: "Installation de Windows 11 sur les postes",
//       statut: "En cours",
//       dateDebut: "2025-03-10",
//       dateFin: "2025-03-12",
//       responsable: "Technicien IT",
//       missionId: 1
//     }
//   ],

//   projetExemplaireEmployes: [
//     {
//       exemplaireId: 1,
//       projetId: 1,
//       employeId: 1,
//       dateUtilisation: "2025-03-16",
//       dateFin: "2025-06-30",
//       dateDebut: "2025-03-16"
//     }
//   ],

//   exemplaireAcheter: [
//     {
//       exemplaireId: 1,
//       partenaireId: 1,
//       lieuLivraison: "EntrepÃ´t principal",
//       quantite: "1",
//       dateAchat: "2025-03-10"
//     }
//   ],

//   missionEmployes: [
//     {
//       employeId: 1,
//       missionId: 1
//     }
//   ],

//   interventionProduit: [
//     {
//       exemplaireId: 1,
//       interventionId: 1
//     }
//   ],

//   interventionEmploye: [
//     {
//       employeId: 1,
//       interventionId: 1
//     }
//   ],

//   sollicitationProduits: [
//     {
//       produitId: 1,
//       produitCode: "PROD001",
//       partenaireId: 1,
//       etat: "En attente",
//       description: "Besoin de piÃ¨ces de rechange"
//     }
//   ],

//   sollicitationInterventions: [
//     {
//       partenaireId: 1,
//       interventionId: 1,
//       etat: "TerminÃ©",
//       description: "Intervention urgente rÃ©alisÃ©e"
//     }
//   ]
// };


================================================
File: modules/stocks/utils/drizzle-wrapper.js
================================================
/**
 * ⚠️ [ARCHITECTURE - SOLUTION DE CONTOURNEMENT] ⚠️
 *
 * Problème initial :
 * - Le fichier central config.js utilise des ES Modules (import/export)
 * - Le reste du projet utilise CommonJS (require/module.exports)
 * - Résultat : db.insert() non reconnu dans famille.service.js
 *
 * Pourquoi ce fichier existe :
 * 1. Évite de modifier config.js (fichier partagé avec d'autres modules)
 * 2. Contourne l'incompatibilité des systèmes de modules
 * 3. Garantit une instance Drizzle fonctionnelle avec :
 *    - Les mêmes paramètres de connexion
 *    - Le même schéma de base de données
 *
 * Solution technique :
 * - Crée une nouvelle instance Drizzle locale
 * - Réutilise les variables d'environnement existantes
 * - Maintient l'isolation du module
 *
 * Risques à connaître :
 * - Double instance de Pool PostgreSQL (augmente légèrement les connexions)
 * - Nécessite de synchroniser les changements de schéma manuellement
 *
 * Alternatives envisagées et rejetées :
 * - Convertir tout le projet en ES Modules (trop intrusif)
 * - Modifier config.js (risque pour les autres modules)
 */

// [Mon module stocks] → [drizzle-wrapper local] → PostgreSQL
//             ↑
//             └─ [N'utilise PAS config.js]

// modules/stocks/utils/drizzle-wrapper.js
const { drizzle } = require("drizzle-orm/node-postgres");
const { Pool } = require("pg");
const schema = require("../../../core/database/models");

// Config locale (utilise les mêmes variables d'environnement de .env)
const pool = new Pool({
  // host: process.env.DB_HOST,
  host: "172.31.3.7",
  port: process.env.DB_PORT,
  user: process.env.APP_DB_USER,
  password: process.env.APP_DB_PASSWORD,
  database: process.env.APP_DB_NAME,
});

module.exports = drizzle(pool, { schema });



================================================
File: modules/stocks/utils/setup-triggers.js
================================================
// const { sql } = require('drizzle-orm');
// const { db } = require('./db.config');

// async function setupUpdatedAtTriggers() {
//   // Ã‰tape 1 : CrÃ©er la fonction PostgreSQL
//   await db.execute(sql`
//     CREATE OR REPLACE FUNCTION update_updated_at_column()
//     RETURNS TRIGGER AS $$
//     BEGIN
//       NEW.updated_at = NOW();
//       RETURN NEW;
//     END;
//     $$ LANGUAGE plpgsql;
//   `);

//   // Ã‰tape 2 : Liste des tables Ã  gÃ©rer
//   const tables = [
//     'familles', 'modeles', 'marques', 'fonctions', 'employes',
//     'demandes', 'type_docs', 'clients_en_ligne', 'entites',
//     'partenaires', 'commandes', 'type_produits', 'prestations',
//     'produits', 'contrats', 'projets', 'livraisons', 'documents',
//     'interventions', 'taches', 'exemplaires',
//     'intervention_employes', 'usage_exemplaires', 'prestation_employes'
//   ];

//   // Ã‰tape 3 : CrÃ©er un trigger sur chaque table
//   for (const table of tables) {
//     await db.execute(sql`
//       DROP TRIGGER IF EXISTS trg_update_${sql.identifier(table)}_updated_at ON ${sql.identifier(table)};
//     `);

//     await db.execute(sql`
//       CREATE TRIGGER trg_update_${sql.identifier(table)}_updated_at
//       BEFORE UPDATE ON ${sql.identifier(table)}
//       FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
//     `);
//   }

//   console.log('âœ… Triggers "updated_at" appliquÃ©s avec succÃ¨s Ã  toutes les tables.');
// }

// module.exports = {
//   setupUpdatedAtTriggers,
// };



================================================
File: modules/technique/controllers/interventions.controller.js
================================================
const path = require('path');
const interventionsService = require("../services/interventions.service");


const interventionsController = {
  getAllInterventions: async (req, res) => {
    try {
      const interventions = await interventionsService.getAllInterventions();
      res.status(200).json(interventions);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  getInterventionById: async (req, res) => {
    try {
      const { id } = req.params;
      const intervention = await interventionsService.getInterventionById(parseInt(id));
      if (!intervention) {
        return res.status(404).json({ message: "Intervention non trouvÃ©e" });
      }
      res.status(200).json(intervention);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  createIntervention: async (req, res) => {
    try {
      const interventionData = {
        date_: new Date(req.body.date_),
        cause_defaillance: req.body.cause_defaillance,
        rapport_intervention: req.body.rapport_intervention,
        type_intervention: req.body.type_intervention,
        type_defaillance: req.body.type_defaillance,
        duree: req.body.duree,
        lieu: req.body.lieu,
        statut_intervention: req.body.statut_intervention || 'en_cours',
        recommandation: req.body.recommandation,
        probleme_signale: req.body.probleme_signale,
        mode_intervention: req.body.mode_intervention,
        detail_cause: req.body.detail_cause,
        type: req.body.type,
        id_partenaire: req.body.id_partenaire ? parseInt(req.body.id_partenaire) : null,
        id_contrat: req.body.id_contrat ? parseInt(req.body.id_contrat) : null
      };

      const newIntervention = await interventionsService.createIntervention(interventionData);

      res.status(201).json({
        success: true,
        message: "Intervention crÃ©Ã©e avec succÃ¨s",
        data: {
          intervention: newIntervention,
          details: {
            dateCreation: new Date().toISOString()
          }
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la crÃ©ation de l'intervention",
        error: error.message
      });
    }
  },

  updateIntervention: async (req, res) => {
    try {
      const { id } = req.params;
      // Prendre directement toutes les donnÃ©es du corps de la requÃªte
      const updateData = req.body;
      
      // Convertir les types de donnÃ©es si nÃ©cessaire
      if (updateData.date_) updateData.date_ = new Date(updateData.date_);
      if (updateData.id_partenaire) updateData.id_partenaire = parseInt(updateData.id_partenaire);
      if (updateData.id_contrat) updateData.id_contrat = parseInt(updateData.id_contrat);

      const updatedIntervention = await interventionsService.updateIntervention(
        parseInt(id), 
        updateData
      );

      if (!updatedIntervention) {
        return res.status(404).json({ message: "Intervention non trouvÃ©e" });
      }

      res.status(200).json(updatedIntervention);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  deleteIntervention: async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await interventionsService.deleteIntervention(parseInt(id));
      
      if (!deleted) {
        return res.status(404).json({ 
          success: false,
          message: "Intervention non trouvÃ©e" 
        });
      }
      
      // Remplacer le status 204 (sans contenu) par un 200 avec un message de succÃ¨s
      res.status(200).json({
        success: true,
        message: "Intervention supprimÃ©e avec succÃ¨s",
        data: { id: parseInt(id) }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false,
        message: error.message 
      });
    }
  },
  
  addDocumentToIntervention: async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: "Aucun fichier n'a Ã©tÃ© tÃ©lÃ©chargÃ©"
        });
      }

      const { id } = req.params;
      const documentData = {
        libelle_document: req.body.libelle_document,
        classification_document: req.body.classification_document,
        lien_document: req.file.path.replace(/\\/g, '/'), // Normalise le chemin pour la BD
        etat_document: req.body.etat_document || 'actif',
        id_nature_document: parseInt(req.body.id_nature_document),
        // id_intervention: parseInt(id)
      };

      const document = await interventionsService.addDocumentToIntervention(documentData);
      
      res.status(201).json({
        success: true,
        message: "Document ajoutÃ© avec succÃ¨s Ã  l'intervention",
        data: {
          document: document,
          details: {
            dateCreation: new Date().toISOString(),
            chemin: documentData.lien_document
          }
        }
      });
    } catch (error) {
      console.error("Erreur lors de l'ajout du document :", error);
      res.status(500).json({
        success: false,
        message: "Erreur lors de l'ajout du document",
        error: error.message
      });
    }
  },


  // Dans interventionsController, ajoutez cette mÃ©thode pour rÃ©cupÃ©rer les documents d'une intervention

  getInterventionDocuments: async (req, res) => {
    try {
      const { id } = req.params;
      const documents = await interventionsService.getInterventionDocuments(parseInt(id));
      
      res.status(200).json({
        success: true,
        message: "Liste des documents de l'intervention rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: documents
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },

  
  deleteDocument: async (req, res) => {
    try {
      const { id, documentId } = req.params;
      
      // VÃ©rification que le document appartient bien Ã  l'intervention
      const document = await interventionsService.getDocumentById(parseInt(documentId));
      if (!document || document.id_intervention !== parseInt(id)) {
        return res.status(404).json({ 
          success: false, 
          message: "Document non trouvÃ© ou n'appartenant pas Ã  cette intervention" 
        });
      }
      
      const deleted = await interventionsService.deleteDocument(parseInt(documentId));
      
      res.status(200).json({
        success: true,
        message: "Document supprimÃ© avec succÃ¨s",
        data: { 
          intervention_id: parseInt(id), 
          document_id: parseInt(documentId) 
        }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },

  addEmployeToIntervention: async (req, res) => {
    try {
      const { id } = req.params;
      const { id_employes } = req.body;
      
      const result = await interventionsService.addEmployeToIntervention(
        parseInt(id),
        parseInt(id_employes)
      );
      
      res.status(201).json({
        success: true,
        message: "EmployÃ© ajoutÃ© Ã  l'intervention avec succÃ¨s",
        data: result
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },
  
  removeEmployeFromIntervention: async (req, res) => {
    try {
      const { id, employeId } = req.params;
      
      const result = await interventionsService.removeEmployeFromIntervention(
        parseInt(id),
        parseInt(employeId)
      );
      
      if (!result) {
        return res.status(404).json({ 
          success: false, 
          message: "Association non trouvÃ©e" 
        });
      }
      
      // Changer le status Ã  200 et ajouter un message de succÃ¨s
      res.status(200).json({
        success: true,
        message: "EmployÃ© retirÃ© de l'intervention avec succÃ¨s",
        data: { 
          intervention_id: parseInt(id), 
          employe_id: parseInt(employeId) 
        }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },
  
  getInterventionEmployes: async (req, res) => {
    try {
      const { id } = req.params;
      const employes = await interventionsService.getInterventionEmployes(parseInt(id));
      
      res.status(200).json({
        success: true,
        message: "Liste des employÃ©s de l'intervention rÃ©cupÃ©rÃ©e",
        data: employes
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  }
};
  

module.exports = interventionsController;



================================================
File: modules/technique/controllers/projets.controller.js
================================================
const path = require('path');
const projetsService = require("../services/projets.service");


const projetsController = {
  getAllProjets: async (req, res) => {
    try {
      const projets = await projetsService.getAllProjets();
      res.status(200).json(projets);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  getProjetById: async (req, res) => {
    try {
      const { id } = req.params;
      const projet = await projetsService.getProjetById(parseInt(id));
      if (!projet) {
        return res.status(404).json({ message: "Projet non trouvÃ©" });
      }
      res.status(200).json(projet);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  createProjet: async (req, res) => {
    try {
      const projetData = {
        nom_projet: req.body.nom_projet,
        type_projet: req.body.type_projet,
        devis_estimatif: parseFloat(req.body.devis_estimatif),
        date_debut: new Date(req.body.date_debut),
        date_fin: new Date(req.body.date_fin),
        duree_prevu_projet: req.body.duree_prevu_projet,
        description_projet: req.body.description_projet,
        etat: req.body.etat || 'en_cours',
        lieu: req.body.lieu,
        responsable: req.body.responsable,
        site: req.body.site,
        id_famille: req.body.id_famille ? parseInt(req.body.id_famille) : null
      };

      const newProjet = await projetsService.createProjet(projetData);

      res.status(201).json({
        success: true,
        message: "Projet crÃ©Ã© avec succÃ¨s",
        data: {
          projet: newProjet,
          details: {
            dateCreation: new Date().toISOString()
          }
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la crÃ©ation du projet",
        error: error.message
      });
    }
  },

  updateProjet: async (req, res) => {
    try {
      const { id } = req.params;
      // Prendre directement toutes les donnÃ©es du corps de la requÃªte
      const updateData = req.body;
      
      // Convertir les types de donnÃ©es si nÃ©cessaire
      if (updateData.devis_estimatif) updateData.devis_estimatif = parseFloat(updateData.devis_estimatif);
      if (updateData.date_debut) updateData.date_debut = new Date(updateData.date_debut);
      if (updateData.date_fin) updateData.date_fin = new Date(updateData.date_fin);
      if (updateData.id_famille) updateData.id_famille = parseInt(updateData.id_famille);

      const updatedProjet = await projetsService.updateProjet(parseInt(id), updateData);

      if (!updatedProjet) {
        return res.status(404).json({ message: "Projet non trouvÃ©" });
      }

      res.status(200).json(updatedProjet);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },


  deleteProjet: async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await projetsService.deleteProjet(parseInt(id));
      
      if (!deleted) {
        return res.status(404).json({ 
          success: false,
          message: "Projet non trouvÃ©" 
        });
      }
      
      // RÃ©ponse explicite avec un message de succÃ¨s
      res.status(200).json({
        success: true,
        message: "Projet supprimÃ© avec succÃ¨s",
        data: { id: parseInt(id) }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false,
        message: error.message 
      });
    }
  },
  

  addDocumentToProjet: async (req, res) => {
    try {
     

      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: "Aucun fichier n'a Ã©tÃ© tÃ©lÃ©chargÃ©"
        });
      }

      const { id } = req.params;
      const documentData = {
        libelle_document: req.body.libelle_document,
        classification_document: req.body.classification_document,
        lien_document: req.file.path.replace(/\\/g, '/'), 
        etat_document: req.body.etat_document || 'actif',
        id_nature_document: parseInt(req.body.id_nature_document),
        id_projet: parseInt(id)
      };

      const document = await projetsService.addDocumentToProjet(documentData);
      
      res.status(201).json({
        success: true,
        message: "Document ajoutÃ© avec succÃ¨s au projet",
        data: {
          document: document,
          details: {
            dateCreation: new Date().toISOString(),
            creePar: req.user?.username || 'system',
            chemin: documentData.lien_document
          }
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de l'ajout du document",
        error: error.message
      });
    }
  },

  addPartenaireToProjet: async (req, res) => {
    try {
      const { id } = req.params;
      const { id_partenaire } = req.body;
      
      const result = await projetsService.addPartenaireToProjet(
        parseInt(id),
        parseInt(id_partenaire)
      );
      
      res.status(201).json({
        success: true,
        message: "Partenaire ajoutÃ© au projet avec succÃ¨s",
        data: result
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },

  removePartenaireFromProjet: async (req, res) => {
    try {
      const { id, partenaireId } = req.params;
      
      const result = await projetsService.removePartenaireFromProjet(
        parseInt(id),
        parseInt(partenaireId)
      );
      
      if (!result) {
        return res.status(404).json({ 
          success: false, 
          message: "Association non trouvÃ©e" 
        });
      }
      
      res.status(200).json({
        success: true,
        message: "Partenaire retirÃ© du projet avec succÃ¨s",
        data: { 
          projet_id: parseInt(id), 
          partenaire_id: parseInt(partenaireId) 
        }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },

  getProjetPartenaires: async (req, res) => {
    try {
      const { id } = req.params;
      const partenaires = await projetsService.getProjetPartenaires(parseInt(id));
      
      res.status(200).json({
        success: true,
        message: "Liste des partenaires du projet rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: partenaires
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },

  getProjetLivrables: async (req, res) => {
    try {
      const { id } = req.params;
      const livrables = await projetsService.getProjetLivrables(parseInt(id));
      
      res.status(200).json({
        success: true,
        message: "Liste des livrables du projet rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: livrables
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },

  createLivrable: async (req, res) => {
    try {
      const { id } = req.params;
      const livrableData = {
        ...req.body,
        id_projet: parseInt(id)
      };
      
      const newLivrable = await projetsService.createLivrable(livrableData);
      
      res.status(201).json({
        success: true,
        message: "Livrable crÃ©Ã© avec succÃ¨s",
        data: newLivrable
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },

  getProjetDocuments: async (req, res) => {
    try {
      const { id } = req.params;
      const documents = await projetsService.getProjetDocuments(parseInt(id));
      
      res.status(200).json({
        success: true,
        message: "Liste des documents du projet rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: documents
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  },

  deleteDocument: async (req, res) => {
    try {
      const { id, documentId } = req.params;
      
      // VÃ©rification que le document appartient bien au projet
      const document = await projetsService.getDocumentById(parseInt(documentId));
      if (!document || document.id_projet !== parseInt(id)) {
        return res.status(404).json({ 
          success: false, 
          message: "Document non trouvÃ© ou n'appartenant pas Ã  ce projet" 
        });
      }
      
      const deleted = await projetsService.deleteDocument(parseInt(documentId));
      
      res.status(200).json({
        success: true,
        message: "Document supprimÃ© avec succÃ¨s",
        data: { 
          projet_id: parseInt(id), 
          document_id: parseInt(documentId) 
        }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  }

};

module.exports = projetsController;



================================================
File: modules/technique/controllers/taches.controller.js
================================================
const tachesService = require("../services/taches.service");

const tachesController = {
  getAllTaches: async (req, res) => {
    try {
      const taches = await tachesService.getAllTaches();
      res.status(200).json(taches);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  getTacheById: async (req, res) => {
    try {
      const { id } = req.params;
      const tache = await tachesService.getTacheById(parseInt(id));
      if (!tache) {
        return res.status(404).json({ message: "TÃ¢che non trouvÃ©e" });
      }
      res.status(200).json(tache);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  createTache: async (req, res) => {
    try {
      const tacheData = req.body;
      const newTache = await tachesService.createTache(tacheData);
      res.status(201).json(newTache);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  updateTache: async (req, res) => {
    try {
      const { id } = req.params;
      const tacheData = req.body;
      const updatedTache = await tachesService.updateTache(parseInt(id), tacheData);
      if (!updatedTache) {
        return res.status(404).json({ message: "TÃ¢che non trouvÃ©e" });
      }
      res.status(200).json(updatedTache);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  deleteTache: async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await tachesService.deleteTache(parseInt(id));
      if (!deleted) {
        return res.status(404).json({ message: "TÃ¢che non trouvÃ©e" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  addEmployeToTache: async (req, res) => {
    try {
      const { id } = req.params;
      const { id_employes } = req.body;
      
      const result = await tachesService.addEmployeToTache(
        parseInt(id),
        parseInt(id_employes)
      );
      
      res.status(201).json(result);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  removeEmployeFromTache: async (req, res) => {
    try {
      const { id, employeId } = req.params;
      
      const result = await tachesService.removeEmployeFromTache(
        parseInt(id),
        parseInt(employeId)
      );
      
      if (!result) {
        return res.status(404).json({ message: "Association non trouvÃ©e" });
      }
      
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  getTacheEmployes: async (req, res) => {
    try {
      const { id } = req.params;
      const employes = await tachesService.getTacheEmployes(parseInt(id));
      res.status(200).json(employes);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  },

  getTachesByProjet: async (req, res) => {
    try {
      const { projetId } = req.params;
      const taches = await tachesService.getTachesByProjet(parseInt(projetId));
      res.status(200).json(taches);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  }
};

module.exports = tachesController;



================================================
File: modules/technique/routes/interventions.routes.js
================================================
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const interventionsController = require('../controllers/interventions.controller');
const uploadMiddleware = require("../../utils/middleware/uploadMiddleware");

// DÃ©finition des chemins de stockage
const UPLOAD_PATHS = {
  INTERVENTIONS: 'media/documents/technique/interventions'
};

// Middleware pour gÃ©rer les erreurs d'upload
const handleUploadError = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    return res.status(400).json({
      success: false,
      message: "Erreur lors du tÃ©lÃ©chargement du fichier",
      error: err.message
    });
  }
  next(err);
};

// Routes CRUD de base
router.get("/", interventionsController.getAllInterventions);
router.get("/:id", interventionsController.getInterventionById);
router.post("/", interventionsController.createIntervention);
router.put("/:id", interventionsController.updateIntervention);
router.delete("/:id", interventionsController.deleteIntervention);

// Route pour les documents avec gestion des erreurs d'upload
router.post("/:id/documents",
  (req, res, next) => {
    try {
      // DÃ©finir le chemin avant l'upload
      req.uploadPath = path.join(process.cwd(), UPLOAD_PATHS.INTERVENTIONS);
      next();
    } catch (error) {
      next(error);
    }
  },
  uploadMiddleware.single("document"),
  interventionsController.addDocumentToIntervention
);

// Routes pour la gestion des employÃ©s
router.post("/:id/employes", interventionsController.addEmployeToIntervention);
router.delete("/:id/employes/:employeId", interventionsController.removeEmployeFromIntervention);
router.get("/:id/employes", interventionsController.getInterventionEmployes);


// Routes pour la gestion des documents
router.get("/:id/documents", interventionsController.getInterventionDocuments);
router.delete("/:id/documents/:documentId", interventionsController.deleteDocument);


module.exports = router;



================================================
File: modules/technique/routes/projets.routes.js
================================================
const express = require("express");
const router = express.Router();
const multer = require('multer');
const path = require('path');
const projetsController = require("../controllers/projets.controller");
const uploadMiddleware = require("../../utils/middleware/uploadMiddleware");

// DÃ©finition des chemins de stockage
const UPLOAD_PATHS = {
  PROJETS: 'media/documents/technique/projets'
};

// Routes CRUD de base
router.get("/", projetsController.getAllProjets);
router.get("/:id", projetsController.getProjetById);
router.post("/", projetsController.createProjet);
router.put("/:id", projetsController.updateProjet);
router.delete("/:id", projetsController.deleteProjet);

// Routes pour la gestion des documents
router.post("/:id/documents",
  (req, res, next) => {
    try {
      // DÃ©finir le chemin avant l'upload
      req.uploadPath = path.join(process.cwd(), UPLOAD_PATHS.PROJETS);
      next();
    } catch (error) {
      next(error);
    }
  },
  uploadMiddleware.single("document"),
  projetsController.addDocumentToProjet
);

router.get("/:id/documents", projetsController.getProjetDocuments);
router.delete("/:id/documents/:documentId", projetsController.deleteDocument);

// Routes pour la gestion des partenaires
router.post("/:id/partenaires", projetsController.addPartenaireToProjet);
router.delete("/:id/partenaires/:partenaireId", projetsController.removePartenaireFromProjet);
router.get("/:id/partenaires", projetsController.getProjetPartenaires);

module.exports = router;



================================================
File: modules/technique/routes/taches.routes.js
================================================
const express = require("express");
const router = express.Router();
const tachesController = require("../controllers/taches.controller");

// Routes pour les tÃ¢ches
router.get("/", tachesController.getAllTaches);
router.get("/:id", tachesController.getTacheById);
router.post("/", tachesController.createTache);
router.put("/:id", tachesController.updateTache);
router.delete("/:id", tachesController.deleteTache);

// Routes pour la gestion des employÃ©s assignÃ©s aux tÃ¢ches
router.post("/:id/employes", tachesController.addEmployeToTache);
router.delete("/:id/employes/:employeId", tachesController.removeEmployeFromTache);
router.get("/:id/employes", tachesController.getTacheEmployes);

// Obtenir les tÃ¢ches par projet
router.get("/projet/:projetId", tachesController.getTachesByProjet);

module.exports = router;



================================================
File: modules/technique/routes/technique.routes.js
================================================
const express = require("express");
const router = express.Router();

// Import des sous-routes
const interventionsRoutes = require("./interventions.routes");
const projetsRoutes = require("./projets.routes");
const tachesRoutes = require("./taches.routes");

// Montage des routes
router.use("/interventions", interventionsRoutes);
router.use("/projets", projetsRoutes);
router.use("/taches", tachesRoutes);

module.exports = router;



================================================
File: modules/technique/services/interventions.service.js
================================================
const { db } = require('../../../core/database/config');
const { interventions, intervention_employes, employes, intervention_taches, documents } = require("../../../core/database/models");

const { eq, and } = require("drizzle-orm");

const interventionsService = {
  getAllInterventions: async () => {
    return await db.select().from(interventions);
  },

  getInterventionById: async (id) => {
    const result = await db
      .select()
      .from(interventions)
      .where(eq(interventions.id_intervention, id));
    return result.length > 0 ? result[0] : null;
  },

  createIntervention: async (interventionData) => {
    const result = await db
      .insert(interventions)
      .values(interventionData)
      .returning();
    return result[0];
  },

  updateIntervention: async (id, interventionData) => {
    const result = await db
      .update(interventions)
      .set({
        ...interventionData,
        updated_at: new Date(),
      })
      .where(eq(interventions.id_intervention, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  },

  deleteIntervention: async (id) => {
    const result = await db
      .delete(interventions)
      .where(eq(interventions.id_intervention, id))
      .returning();
    return result.length > 0;
  },

  addDocumentToIntervention: async (documentData) => {
    const result = await db.insert(documents).values(documentData).returning();
    return result[0];
  },

  addEmployeToIntervention: async (interventionId, employeId) => {
    const result = await db
      .insert(intervention_employes)
      .values({
        id_intervention: interventionId,
        id_employes: employeId,
      })
      .returning();
    return result[0];
  },

  removeEmployeFromIntervention: async (interventionId, employeId) => {
    const result = await db
      .delete(intervention_employes)
      .where(
        and(
          eq(intervention_employes.id_intervention, interventionId),
          eq(intervention_employes.id_employes, employeId)
        )
      )
      .returning();
    return result.length > 0;
  },

  getInterventionEmployes: async (interventionId) => {
    return await db
      .select({
        id_employes: employes.id_employes,
        nom_employes: employes.nom_employes,
        prenom_employes: employes.prenom_employes,
        email_employes: employes.email_employes,
      })
      .from(intervention_employes)
      .innerJoin(
        employes,
        eq(intervention_employes.id_employes, employes.id_employes)
      )
      .where(eq(intervention_employes.id_intervention, interventionId));
  },

  getInterventionDocuments: async (interventionId) => {
    try {
      return await db
        .select({
          id_documents: documents.id_documents,
          libelle_document: documents.libelle_document,
          classification_document: documents.classification_document,
          lien_document: documents.lien_document,
          etat_document: documents.etat_document,
          created_at: documents.created_at,
          updated_at: documents.updated_at
        })
        .from(documents)
        .where(eq(documents.id_intervention, interventionId));
    } catch (error) {
      throw new Error(`Erreur lors de la rÃ©cupÃ©ration des documents: ${error.message}`);
    }
  },

  getDocumentById: async (documentId) => {
    try {
      const result = await db
        .select()
        .from(documents)
        .where(eq(documents.id_documents, documentId));
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      throw new Error(`Erreur lors de la rÃ©cupÃ©ration du document: ${error.message}`);
    }
  },

  deleteDocument: async (documentId) => {
    try {
      const result = await db
        .delete(documents)
        .where(eq(documents.id_documents, documentId))
        .returning();
      return result.length > 0;
    } catch (error) {
      throw new Error(`Erreur lors de la suppression du document: ${error.message}`);
    }
  }
};

module.exports = interventionsService;



================================================
File: modules/technique/services/projets.service.js
================================================
const { db } = require('../../../core/database/config');
const { projets, collaborer, documents, livrables, partenaires } = require("../../../core/database/models");
const { eq, and } = require("drizzle-orm");

const projetsService = {
  getAllProjets: async () => {
    return await db.select().from(projets);
  },

  getProjetById: async (id) => {
    const result = await db
      .select()
      .from(projets)
      .where(eq(projets.id_projet, id));
    return result.length > 0 ? result[0] : null;
  },

  createProjet: async (projetData) => {
    const result = await db
      .insert(projets)
      .values(projetData)
      .returning();
    return result[0];
  },

  updateProjet: async (id, projetData) => {
    const result = await db
      .update(projets)
      .set({
        ...projetData,
        updated_at: new Date(),
      })
      .where(eq(projets.id_projet, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  },

  deleteProjet: async (id) => {
    const result = await db
      .delete(projets)
      .where(eq(projets.id_projet, id))
      .returning();
    return result.length > 0;
  },

  addDocumentToProjet: async (documentData) => {
    const result = await db.insert(documents).values(documentData).returning();
    return result[0];
  },

  addPartenaireToProjet: async (projetId, partenaireId) => {
    const result = await db
      .insert(collaborer)
      .values({
        id_projet: projetId,
        id_partenaire: partenaireId,
      })
      .returning();
    return result[0];
  },

  removePartenaireFromProjet: async (projetId, partenaireId) => {
    const result = await db
      .delete(collaborer)
      .where(
        and(
          eq(collaborer.id_projet, projetId),
          eq(collaborer.id_partenaire, partenaireId)
        )
      )
      .returning();
    return result.length > 0;
  },

  getProjetPartenaires: async (projetId) => {
    return await db
      .select({
        id_partenaire: partenaires.id_partenaire,
        nom_partenaire: partenaires.nom_partenaire,
        email_partenaire: partenaires.email_partenaire,
        telephone_partenaire: partenaires.telephone_partenaire,
        specialite: partenaires.specialite
      })
      .from(collaborer)
      .innerJoin(
        partenaires,
        eq(collaborer.id_partenaire, partenaires.id_partenaire)
      )
      .where(eq(collaborer.id_projet, projetId));
  },

  getProjetLivrables: async (projetId) => {
    return await db
      .select()
      .from(livrables)
      .where(eq(livrables.id_projet, projetId));
  },

  createLivrable: async (livrableData) => {
    const result = await db
      .insert(livrables)
      .values(livrableData)
      .returning();
    return result[0];
  },

  // Ajout des nouvelles mÃ©thodes pour la gestion des documents
  getProjetDocuments: async (projetId) => {
    try {
      return await db
        .select({
          id_documents: documents.id_documents,
          libelle_document: documents.libelle_document,
          classification_document: documents.classification_document,
          lien_document: documents.lien_document,
          etat_document: documents.etat_document,
          created_at: documents.created_at,
          updated_at: documents.updated_at
        })
        .from(documents)
        .where(eq(documents.id_projet, projetId));
    } catch (error) {
      throw new Error(`Erreur lors de la rÃ©cupÃ©ration des documents: ${error.message}`);
    }
  },

  getDocumentById: async (documentId) => {
    try {
      const result = await db
        .select()
        .from(documents)
        .where(eq(documents.id_documents, documentId));
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      throw new Error(`Erreur lors de la rÃ©cupÃ©ration du document: ${error.message}`);
    }
  },

  deleteDocument: async (documentId) => {
    try {
      const result = await db
        .delete(documents)
        .where(eq(documents.id_documents, documentId))
        .returning();
      return result.length > 0;
    } catch (error) {
      throw new Error(`Erreur lors de la suppression du document: ${error.message}`);
    }
  }
};

module.exports = projetsService;



================================================
File: modules/technique/services/taches.service.js
================================================
const { db } = require('../../../core/database/config');
const { taches, intervention_taches, employes } = require("../../../core/database/models");
const { eq, and } = require("drizzle-orm");

const tachesService = {
  getAllTaches: async () => {
    return await db.select().from(taches);
  },

  getTacheById: async (id) => {
    const result = await db
      .select()
      .from(taches)
      .where(eq(taches.id_tache, id));
    return result.length > 0 ? result[0] : null;
  },

  createTache: async (tacheData) => {
    const result = await db
      .insert(taches)
      .values(tacheData)
      .returning();
    return result[0];
  },

  updateTache: async (id, tacheData) => {
    const result = await db
      .update(taches)
      .set({
        ...tacheData,
        updated_at: new Date(),
      })
      .where(eq(taches.id_tache, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  },

  deleteTache: async (id) => {
    const result = await db
      .delete(taches)
      .where(eq(taches.id_tache, id))
      .returning();
    return result.length > 0;
  },

  addEmployeToTache: async (tacheId, employeId) => {
    const result = await db
      .insert(intervention_taches)
      .values({
        id_tache: tacheId,
        id_employes: employeId,
      })
      .returning();
    return result[0];
  },

  removeEmployeFromTache: async (tacheId, employeId) => {
    const result = await db
      .delete(intervention_taches)
      .where(
        and(
          eq(intervention_taches.id_tache, tacheId),
          eq(intervention_taches.id_employes, employeId)
        )
      )
      .returning();
    return result.length > 0;
  },

  getTacheEmployes: async (tacheId) => {
    return await db
      .select({
        id_employes: employes.id_employes,
        nom_employes: employes.nom_employes,
        prenom_employes: employes.prenom_employes,
        email_employes: employes.email_employes,
      })
      .from(intervention_taches)
      .innerJoin(
        employes,
        eq(intervention_taches.id_employes, employes.id_employes)
      )
      .where(eq(intervention_taches.id_tache, tacheId));
  },

  getTachesByProjet: async (projetId) => {
    return await db
      .select()
      .from(taches)
      .where(eq(taches.id_projet, projetId));
  },
};

module.exports = tachesService;



================================================
File: modules/users/digest.txt
================================================
Directory structure:
â””â”€â”€ users/
    â”œâ”€â”€ controllers/
    â”‚   â”œâ”€â”€ sync.controller.js
    â”‚   â””â”€â”€ users.controller.js
    â”œâ”€â”€ routes/
    â”‚   â””â”€â”€ users.routes.js
    â”œâ”€â”€ services/
    â”‚   â””â”€â”€ users.service.js
    â””â”€â”€ sql/
        â”œâ”€â”€ employes.sql
        â””â”€â”€ fonctions.sql

================================================
File: controllers/sync.controller.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonction } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');
const logger = require('../../../core/utils/logger');

module.exports = {
  syncUser: async (req, res) => {
    const token = req.kauth.grant.access_token;
    // const { email, firstName, lastName } = req.body;
    const { email } = req.body;


    // Validation email/token
    if (!token?.content?.email || !email) {
      logger.warn('Token ou email manquant', { token, email });
      return res.status(400).json({ error: "Token ou email invalide" });
    }

    if (token.content.email !== email) {
      logger.warn('IncohÃƒÂ©rence email/token', {
        tokenEmail: token.content.email,
        providedEmail: email,
        userId: token.content.sub
      });
      return res.status(400).json({ error: "Email ne correspond pas au token" });
    }


    try {
      // RÃƒÂ©cupÃƒÂ©ration de l'ID de la fonction Technicien
      const technicien = await db.select()
        .from(fonction)
        .where(eq(fonction.nom, 'Technicien'))
        .limit(1);
      console.log("RÃƒÂ©sultat recherche Technicien:", technicien);

      if (!technicien || technicien.length === 0) {
        throw new Error('La fonction Technicien n\'existe pas en base');
      }

      const fonctionId = technicien[0].id;

      // DonnÃƒÂ©es utilisateur
      const userData = {
        keycloak_id: token.content.sub,
        email: token.content.email,
        status: 'actif',
        fonctionId: fonctionId,
        created_at: new Date(),
        updated_at: new Date()
      };

      // Upsert
      await db.insert(employes)
        .values(userData)
        .onConflictDoUpdate({
          target: employes.keycloak_id,
          set: {
            email: userData.email,
            nom: userData.nom,
            prenom: userData.prenom,
            fonctionId: fonctionId,
            updated_at: userData.updated_at
          }
        });

      res.status(204).end();
    } catch (error) {
      logger.error('Erreur de synchronisation', {
        error: error.message,
        userId: token.content.sub,
        email: token.content.email
      });

      if (error.message.includes('Technicien')) {
        res.status(400).json({ 
          error: "Configuration manquante",
          details: "La fonction Technicien doit ÃƒÂªtre crÃƒÂ©ÃƒÂ©e en base de donnÃƒÂ©es"
        });
      } else {
        res.status(500).json({ 
          error: "Ãƒâ€°chec de la synchronisation",
          details: error.message
        });
      }
    }
  }
};


================================================
File: controllers/users.controller.js
================================================
Ã¯Â»Â¿const logger = require('../../../core/utils/logger');
const userService = require('../services/users.service');

module.exports = {
  getAllUsers: async (req, res, next) => {
    try {
      const { page = 1, limit = 10 } = req.query;
      const users = await userService.getAllUsers(parseInt(page), parseInt(limit));
      
      logger.info(`RÃƒÂ©cupÃƒÂ©ration de ${users.length} utilisateurs`);
      res.json(users.map(user => ({
        ...user,
        fonction: user.fonction?.nom || 'Non dÃƒÂ©fini'
      })));
    } catch (error) {
      logger.error('Ãƒâ€°chec de rÃƒÂ©cupÃƒÂ©ration des utilisateurs:', error);
      next(error);
    }
  },


  getMyProfile: async (req, res) => {
  const token = req.kauth?.grant?.access_token;
  if (!token?.content?.sub) {
      return res.status(401).json({ error: "Token non fourni ou invalide" });
  }
  const { sub } = req.kauth.grant.access_token.content;

  try {
    const user = await userService.getUserByKeycloakId(sub);
    // console.log('User data:', user); // Debug log

    if (!user) {
      return res.status(404).json({ error: "Utilisateur non trouvÃƒÂ©" });
    }

    res.json({
      email: user.email,
      nom: user.nom,
      prenom: user.prenom,
      contact: user.contact,
      adresse: user.adresse,
      fonction: user.fonction?.nom || 'Non dÃƒÂ©fini'
    });
  } catch (error) {
    console.error('Error details:', error); // Log complet de l'erreur
    res.status(500).json({ 
      error: "Erreur serveur",
      details: error.message
    });
  }
},

  updateMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content;
    const updates = req.body;

    try {
      const allowedFields = ["adresse", "contact", "nom", "prenom"];
      const filteredUpdates = Object.keys(updates)
        .filter(key => allowedFields.includes(key))
        .reduce((obj, key) => ({ ...obj, [key]: updates[key] }), {});

      if (Object.keys(filteredUpdates).length === 0) {
        return res.status(400).json({ error: "Aucun champ modifiable fourni" });
      }

      logger.error('Test-------------------------',filteredUpdates);

      await userService.updateUserProfile(sub, filteredUpdates);
      res.status(204).end();
    } catch (error) {
      logger.error('Ãƒâ€°chec de la mise ÃƒÂ  jour du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Ãƒâ€°chec de la mise ÃƒÂ  jour" });
    }
  }
};


================================================
File: routes/users.routes.js
================================================
Ã¯Â»Â¿const express = require('express');
const router = express.Router();
const { protect } = require('../../../core/auth/middleware');
const UsersController = require('../controllers/users.controller');
const SyncController = require('../controllers/sync.controller');


// Synchronisation Keycloak Ã¢â€ â€™ BD MÃƒÂ©tier
router.post('/sync', protect(), SyncController.syncUser);

// RÃƒÂ©cupÃƒÂ©ration du profil utilisateur
router.get('/me', protect([]), UsersController.getMyProfile);


// Mise ÃƒÂ  jour du profil (ex: tÃƒÂ©lÃƒÂ©phone)
router.patch('/me', protect([]), UsersController.updateMyProfile);

// RÃƒÂ©cupÃƒÂ©ration de tous les utilisateurs (avec pagination)
router.get('/', protect([]), UsersController.getAllUsers);

module.exports = router;


================================================
File: services/users.service.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonction } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');

module.exports = {
  getUserByKeycloakId: async (keycloakId) => {
    const result = await db.select()
      .from(employes)
      .leftJoin(fonction, eq(employes.fonctionId, fonction.id)) 
      .where(eq(employes.keycloak_id, keycloakId))
      .limit(1);

    return result[0] ? {
      ...result[0].employes,
      fonction: result[0].fonction 
    } : null;
  },

  updateUserProfile: async (keycloakId, data) => {
    const allowedFields = ["contact", "adresse", "prenom", "nom"];
    const updates = Object.keys(data)
      .filter(key => allowedFields.includes(key))
      .reduce((obj, key) => ({ ...obj, [key]: data[key] }), {});

    await db.update(employes)
      .set(updates)
      .where(eq(employes.keycloak_id, keycloakId));
  },

  getAllUsers: async (page = 1, limit = 10) => {
    try {
      return await db.select({
        id: employes.id,
        email: employes.email,
        prenom: employes.prenom,
        nom: employes.nom,
        status: employes.status,
        // service: employes.service
      })
      .from(employes)
      .orderBy(employes.nom)
      .limit(limit)
      .offset((page - 1) * limit)
      .execute();
    } catch (error) {
      throw new Error(`Ãƒâ€°chec de rÃƒÂ©cupÃƒÂ©ration des utilisateurs: ${error.message}`);
    }
  },
};


================================================
File: sql/employes.sql
================================================
INSERT INTO public.employes(
    id, nom, keycloak_id, prenom, email, contact, adresse, status, fonction_id)
VALUES 
    (1, 'Dupont', 'keycloak-001', 'Jean', 'jean.dupont@example.com', '0612345678', '10 Rue de Paris, 75001', true, 1),x
    (2, 'Martin', 'keycloak-002', 'Sophie', 'sophie.martin@example.com', '0623456789', '22 Av. des Champs, 69002', true, 2),
    (3, 'Bernard', 'keycloak-003', 'Pierre', 'pierre.bernard@example.com', '0634567890', '5 Bd LibertÃƒÂ©, 13003', true, 3), -- Technicien
    (4, 'Petit', 'keycloak-004', 'Marie', 'marie.petit@example.com', '0645678901', '15 Rue Lyon, 31004', false, 3), -- Technicien
    (5, 'Durand', 'keycloak-005', 'Luc', 'luc.durand@example.com', '0656789012', '30 Av. Central, 59005', true, 4),
    (6, 'Leroy', 'keycloak-006', 'Emma', 'emma.leroy@example.com', '0667890123', '8 Pl. RÃƒÂ©publique, 67006', true, 5),
    (7, 'Moreau', 'keycloak-007', 'Thomas', 'thomas.moreau@example.com', '0678901234', '12 Rue Principale, 33007', true, 3), -- Technicien
    (8, 'Lefebvre', 'keycloak-008', 'Julie', 'julie.lefebvre@example.com', '0689012345', '40 Bd des Roses, 06008', false, 2),
    (9, 'Roux', 'keycloak-009', 'Nicolas', 'nicolas.roux@example.com', '0690123456', '25 Impasse Fleurie, 34009', true, 3), -- Technicien
    (10, 'Girard', 'keycloak-010', 'Isabelle', 'isabelle.girard@example.com', '0601234567', '18 Chemin Vert, 44010', true, 1);


================================================
File: sql/fonctions.sql
================================================
INSERT INTO public.fonctions(id_fonction, nom_fonction)
VALUES 
    (1, 'Directeur'),
    (2, 'Manager'),
    (3, 'Technicien'),
    (4, 'Assistant'),
    (5, 'SecrÃƒÂ©taire');




================================================
File: modules/users/controllers/sync.controller.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonctions } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');
const logger = require('../../../core/utils/logger');

module.exports = {
  syncUser: async (req, res) => {
    const token = req.kauth.grant.access_token;
    const { email, firstName, lastName } = req.body;
    // const { email } = req.body;


    // Validation email/token
    if (!token?.content?.email || !email) {
      logger.warn('Token ou email manquant', { token, email });
      return res.status(400).json({ error: "Token ou email invalide" });
    }

    if (token.content.email !== email) {
      logger.warn('IncohÃ©rence email/token', {
        tokenEmail: token.content.email,
        providedEmail: email,
        userId: token.content.sub
      });
      return res.status(400).json({ error: "Email ne correspond pas au token" });
    }


    try {
      // RÃ©cupÃ©ration de l'ID de la fonction Technicien
      const technicien = await db.select()
        .from(fonctions)
        .where(eq(fonctions.nom_fonction, 'Technicien'))
        .limit(1);
      console.log("RÃ©sultat recherche Technicien:", technicien);

      if (!technicien || technicien.length === 0) {
        throw new Error('La fonction Technicien n\'existe pas en base');
      }

      const fonctionId = technicien[0].id;

      // DonnÃ©es utilisateur
      const userData = {
        keycloak_id: token.content.sub,
        email_employes: token.content.email,
        nom_employes:firstName,
        prenom_employes:lastName,
        status: 'actif',
        fonctionId: fonctionId,
        created_at: new Date(),
        updated_at: new Date()
      };

      // Upsert
      await db.insert(employes)
        .values(userData)
        .onConflictDoUpdate({
          target: employes.keycloak_id,
          set: {
            email: userData.email,
            nom: userData.nom,
            prenom: userData.prenom,
            fonctionId: fonctionId,
            updated_at: userData.updated_at
          }
        });

      res.status(204).end();
    } catch (error) {
      logger.error('Erreur de synchronisation', {
        error: error.message,
        userId: token.content.sub,
        email: token.content.email
      });

      if (error.message.includes('Technicien')) {
        res.status(400).json({ 
          error: "Configuration manquante",
          details: "La fonction Technicien doit Ãªtre crÃ©Ã©e en base de donnÃ©es"
        });
      } else {
        res.status(500).json({ 
          error: "Ã‰chec de la synchronisation",
          details: error.message
        });
      }
    }
  }
};


================================================
File: modules/users/controllers/users.controller.js
================================================
ï»¿const logger = require('../../../core/utils/logger');
const userService = require('../services/users.service');

module.exports = {
  getAllUsers: async (req, res, next) => {
    try {
      const { page = 1, limit = 10 } = req.query;
      const users = await userService.getAllUsers(parseInt(page), parseInt(limit));
      
      logger.info(`RÃ©cupÃ©ration de ${users.length} utilisateurs`);
      res.json(users.map(user => ({
        ...user,
        fonction: user.fonction?.nom || 'Non dÃ©fini'
      })));
    } catch (error) {
      logger.error('Ã‰chec de rÃ©cupÃ©ration des utilisateurs:', error);
      next(error);
    }
  },


  getMyProfile: async (req, res) => {
  const token = req.kauth?.grant?.access_token;
  if (!token?.content?.sub) {
      return res.status(401).json({ error: "Token non fourni ou invalide" });
  }
  const { sub } = req.kauth.grant.access_token.content;

  try {
    const user = await userService.getUserByKeycloakId(sub);
    // console.log('User data:', user); // Debug log

    if (!user) {
      return res.status(404).json({ error: "Utilisateur non trouvÃ©" });
    }

    res.json({
      email: user.email,
      nom: user.nom,
      prenom: user.prenom,
      contact: user.contact,
      adresse: user.adresse,
      fonction: user.fonction?.nom || 'Non dÃ©fini'
    });
  } catch (error) {
    console.error('Error details:', error); // Log complet de l'erreur
    res.status(500).json({ 
      error: "Erreur serveur",
      details: error.message
    });
  }
},

  updateMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content;
    const updates = req.body;

    try {
      const allowedFields = ["adresse", "contact", "nom", "prenom"];
      const filteredUpdates = Object.keys(updates)
        .filter(key => allowedFields.includes(key))
        .reduce((obj, key) => ({ ...obj, [key]: updates[key] }), {});

      if (Object.keys(filteredUpdates).length === 0) {
        return res.status(400).json({ error: "Aucun champ modifiable fourni" });
      }

      logger.error('Erreur',filteredUpdates);

      await userService.updateUserProfile(sub, filteredUpdates);
      res.status(204).end();
    } catch (error) {
      logger.error('Ã‰chec de la mise Ã  jour du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Ã‰chec de la mise Ã  jour" });
    }
  }
};


================================================
File: modules/users/routes/users.routes.js
================================================
ï»¿const express = require('express');
const router = express.Router();
const { protect } = require('../../../core/auth/middleware');
const UsersController = require('../controllers/users.controller');
const SyncController = require('../controllers/sync.controller');


// Synchronisation Keycloak â†’ BD MÃ©tier
router.post('/sync', protect(), SyncController.syncUser);

// RÃ©cupÃ©ration du profil utilisateur
router.get('/me', protect([]), UsersController.getMyProfile);


// Mise Ã  jour du profil (ex: tÃ©lÃ©phone)
router.patch('/me', protect([]), UsersController.updateMyProfile);

// RÃ©cupÃ©ration de tous les utilisateurs (avec pagination)
/**
 * @swagger
 * /users:
 *   get:
 *     summary: Liste des utilisateurs
 *     tags:
 *       - Utilisateurs
 */
router.get('/', protect(["rh7",]), UsersController.getAllUsers);

module.exports = router;


================================================
File: modules/users/services/users.service.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonctions } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');

module.exports = {
  getUserByKeycloakId: async (keycloakId) => {
    const result = await db.select()
      .from(employes)
      .leftJoin(fonctions, eq(employes.id_fonction, fonctions.id_fonction)) 
      .where(eq(employes.keycloak_id, keycloakId))
      .limit(1);

    return result[0] ? {
      ...result[0].employes,
      fonction: result[0].fonctions 
    } : null;
  },

  updateUserProfile: async (keycloakId, data) => {
    const allowedFields = ["contact", "adresse", "prenom", "nom"];
    const updates = Object.keys(data)
      .filter(key => allowedFields.includes(key))
      .reduce((obj, key) => ({ ...obj, [key]: data[key] }), {});

    await db.update(employes)
      .set(updates)
      .where(eq(employes.keycloak_id, keycloakId));
  },

  getAllUsers: async (page = 1, limit = 10) => {
    try {
      return await db.select({
        id: employes.id_employes,
        email: employes.email_employes,
        prenom: employes.prenom_employes,
        nom: employes.nom_employes,
        status: employes.status_employes,
        // service: employes.service
      })
      .from(employes)
      .orderBy(employes.nom_employes)
      .limit(limit)
      .offset((page - 1) * limit)
      .execute();
    } catch (error) {
      throw new Error(`Ã‰chec de rÃ©cupÃ©ration des utilisateurs: ${error.message}`);
    }
  },
};


================================================
File: modules/users/sql/employes.sql
================================================
INSERT INTO public.employes(
    id, nom, keycloak_id, prenom, email, contact, adresse, status, fonction_id)
VALUES 
    (1, 'Dupont', 'keycloak-001', 'Jean', 'jean.dupont@example.com', '0612345678', '10 Rue de Paris, 75001', true, 1),x
    (2, 'Martin', 'keycloak-002', 'Sophie', 'sophie.martin@example.com', '0623456789', '22 Av. des Champs, 69002', true, 2),
    (3, 'Bernard', 'keycloak-003', 'Pierre', 'pierre.bernard@example.com', '0634567890', '5 Bd LibertÃ©, 13003', true, 3), -- Technicien
    (4, 'Petit', 'keycloak-004', 'Marie', 'marie.petit@example.com', '0645678901', '15 Rue Lyon, 31004', false, 3), -- Technicien
    (5, 'Durand', 'keycloak-005', 'Luc', 'luc.durand@example.com', '0656789012', '30 Av. Central, 59005', true, 4),
    (6, 'Leroy', 'keycloak-006', 'Emma', 'emma.leroy@example.com', '0667890123', '8 Pl. RÃ©publique, 67006', true, 5),
    (7, 'Moreau', 'keycloak-007', 'Thomas', 'thomas.moreau@example.com', '0678901234', '12 Rue Principale, 33007', true, 3), -- Technicien
    (8, 'Lefebvre', 'keycloak-008', 'Julie', 'julie.lefebvre@example.com', '0689012345', '40 Bd des Roses, 06008', false, 2),
    (9, 'Roux', 'keycloak-009', 'Nicolas', 'nicolas.roux@example.com', '0690123456', '25 Impasse Fleurie, 34009', true, 3), -- Technicien
    (10, 'Girard', 'keycloak-010', 'Isabelle', 'isabelle.girard@example.com', '0601234567', '18 Chemin Vert, 44010', true, 1);


================================================
File: modules/users/sql/fonctions.sql
================================================
INSERT INTO public.fonctions(id_fonction, nom_fonction)
VALUES 
    (1, 'Directeur'),
    (2, 'Manager'),
    (3, 'Technicien'),
    (4, 'Assistant'),
    (5, 'SecrÃ©taire');


================================================
File: modules/utils/middleware/uploadMiddleware.js
================================================
/**
 * Middleware pour la gestion de l'upload de fichiers
 * Ce module configure Multer pour permettre le tÃ©lÃ©chargement de fichiers
 * dans l'application, avec des rÃ¨gles spÃ©cifiques sur les types et emplacements
 * de stockage des fichiers.
 */

const multer = require('multer');  // Importe la bibliothÃ¨que Multer pour gÃ©rer l'upload de fichiers
const path = require('path');      // Importe le module path pour manipuler les chemins de fichiers
const fs = require('fs');          // Importe le module fs (file system) pour manipuler les fichiers

/**
 * Configuration du stockage des fichiers tÃ©lÃ©chargÃ©s
 * DÃ©finit comment et oÃ¹ les fichiers seront enregistrÃ©s
 */
const storage = multer.diskStorage({
  /**
   * DÃ©termine le dossier de destination pour les fichiers tÃ©lÃ©chargÃ©s
   * @param {Object} req - La requÃªte HTTP
   * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
   * @param {Function} cb - Fonction de callback Ã  appeler avec le chemin de destination
   */
  destination: function (req, file, cb) {
    // Le chemin de destination est dÃ©fini dynamiquement dans le contrÃ´leur via req.uploadPath
    const uploadPath = req.uploadPath;
    
    // CrÃ©e le dossier de destination s'il n'existe pas dÃ©jÃ 
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    // Appelle le callback avec le chemin de destination
    cb(null, uploadPath);
  },
  
  /**
   * GÃ©nÃ¨re un nom unique pour le fichier tÃ©lÃ©chargÃ©
   * @param {Object} req - La requÃªte HTTP
   * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
   * @param {Function} cb - Fonction de callback Ã  appeler avec le nom du fichier
   */
  filename: function (req, file, cb) {
    // Ajoute un timestamp au nom du fichier pour Ã©viter les collisions
    const timestamp = Date.now();
    
    // Extrait le nom et l'extension du fichier original
    const originalName = path.parse(file.originalname);
    
    // CrÃ©e un nouveau nom avec le format: nom-original_timestamp.extension
    const newFilename = `${originalName.name}_${timestamp}${originalName.ext}`;
    
    // Appelle le callback avec le nouveau nom de fichier
    cb(null, newFilename);
  }
});

/**
 * Fonction de filtrage des types de fichiers autorisÃ©s
 * @param {Object} req - La requÃªte HTTP
 * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
 * @param {Function} cb - Fonction de callback pour accepter ou refuser le fichier
 */
const fileFilter = (req, file, cb) => {
  // Liste des types MIME autorisÃ©s pour l'upload
  const allowedMimeTypes = [
    // Images
    'image/jpeg', 'image/png', 'image/gif',
    
    // Documents PDF
    'application/pdf',
    
    // Documents Microsoft Office
    'application/msword',  // Word (.doc)
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // Word (.docx)
    'application/vnd.ms-excel', // Excel (.xls)
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // Excel (.xlsx)
    'application/vnd.ms-powerpoint', // PowerPoint (.ppt)
    'application/vnd.openxmlformats-officedocument.presentationml.presentation', // PowerPoint (.pptx)
    
    // Fichiers texte
    'text/plain',
    
    // Archives
    'application/zip',
    'application/x-rar-compressed'
  ];
  
  // VÃ©rifie si le type MIME du fichier est autorisÃ©
  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true); // Accepte le fichier
  } else {
    // Rejette le fichier avec un message d'erreur
    cb(new Error(`Type de fichier non autorisÃ©: ${file.mimetype}`), false);
  }
};

/**
 * Configuration complÃ¨te de Multer avec les options dÃ©finies
 * - storage: dÃ©finit comment et oÃ¹ stocker les fichiers
 * - fileFilter: dÃ©finit quels types de fichiers sont acceptÃ©s
 * - limits: dÃ©finit les limites pour l'upload (taille, nombre de fichiers, etc.)
 */
const upload = multer({ 
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: Infinity } // Permet des fichiers de taille illimitÃ©e
});

// Exporte le middleware configurÃ© pour Ãªtre utilisÃ© dans les routes
module.exports = upload;



================================================
File: .github/workflows/main.yml
================================================
# name: Build and deploy

# on:
#   push:
#     branches:
#       - dev

# jobs:
#   build-and-deploy:
#     runs-on: self-hosted
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Build and deploy
#         run: |
#           docker-compose build
#           docker-compose up -d



# name: Build and deploy

# on:
#   push:
#     branches:
#       - dev

# jobs:
#   build-and-deploy:
#     runs-on: self-hosted
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Debug environment
#         run: |
#           # Check Docker installation
#           which docker || echo "Docker binary not found"
#           which docker-compose || echo "Docker Compose binary not found"
          
#           # Check versions
#           docker --version || echo "Docker command failed"
#           docker-compose --version || echo "Docker Compose command failed"
          
#           # Check if Docker daemon is running
#           docker info || echo "Docker daemon not accessible"
          
#           # Check Docker socket
#           ls -la /var/run/docker.sock || echo "Docker socket not found at default location"
          
#           # Check user permissions
#           id
#           groups
          
#           # Check Docker group
#           getent group docker || echo "Docker group not found"

#       - name: Try alternate Docker Compose approach
#         run: |
#           # Try using Docker CLI plugin (v2 compose)
#           docker compose version || echo "Docker Compose plugin not available"
          
#           # Check Python environment
#           python3 --version
#           pip3 list | grep -E "docker|compose|urllib3|requests"

# name: Build and deploy

# on:
#   push:
#     branches:
#       - dev

# jobs:
#   build-and-deploy:
#     runs-on: self-hosted
#     if: contains(github.event.head_commit.message, '[deploy]')
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       # - name: Show commit message
#       #   run: echo "Deploying based on commit message: ${{ github.event.head_commit.message }}"

#       - name: Build and deploy
#         run: |
#           echo "Starting deployment..."
#           docker-compose build
#           docker-compose up -d
#           echo "Deployment completed!"



# name: Build and deploy

# on:
#   push:
#     branches:
#       - dev

# jobs:
#   build-and-deploy:
#     runs-on: self-hosted
#     if: contains(github.event.head_commit.message, '[deploy]')
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Build and deploy
#         env:
#           KC_HOSTNAME: ${{ secrets.KC_HOSTNAME }}
#         run: |
#           echo "KC_HOSTNAME=$KC_HOSTNAME"
#           echo "Starting deployment..."
#           docker-compose build
#           docker-compose up -d
#           echo "Deployment completed!"



name: Build and deploy

on:
  push:
    branches:
      - dev

jobs:
  build-and-deploy:
    runs-on: self-hosted
    if: contains(github.event.head_commit.message, '[deploy]')
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build and deploy
        env:
          KC_HOSTNAME: ${{ secrets.KC_HOSTNAME }}
        run: |
          echo "KC_HOSTNAME=$KC_HOSTNAME"
          echo "Starting deployment..."
          docker-compose -f docker-compose.prod.yml build
          docker-compose -f docker-compose.prod.yml up -d
          echo "Deployment completed!"


