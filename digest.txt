Directory structure:
└── dcat_backend/
    ├── README.md
    ├── Dockerfile
    ├── docker-compose.prod.yml
    ├── docker-compose.yml
    ├── drizzle.config.js
    ├── package.json
    ├── post-init.sh
    ├── server.js
    ├── core/
    │   ├── auth/
    │   │   ├── keycloak.config.js
    │   │   ├── middleware.js
    │   │   └── setupKeycloak.js
    │   ├── database/
    │   │   ├── config.js
    │   │   ├── db.config.js
    │   │   ├── migration.js
    │   │   ├── models.js
    │   │   ├── test-db.js
    │   │   └── migrations/
    │   │       ├── 0000_cloudy_fat_cobra.sql
    │   │       ├── 0001_worthless_venus.sql
    │   │       ├── 0002_previous_wasp.sql
    │   │       └── meta/
    │   │           ├── 0000_snapshot.json
    │   │           ├── 0001_snapshot.json
    │   │           ├── 0002_snapshot.json
    │   │           └── _journal.json
    │   └── utils/
    │       ├── logger.js
    │       ├── swagger.js
    │       └── swagger.routes.js
    ├── init-db/
    │   └── nit-multiple-dbs.sh
    ├── keycloak-setup/
    │   ├── backend_cli_id.json
    │   ├── frontend_cli_id.json
    │   └── keycloak-setup.js
    ├── media/
    │   ├── documents/
    │   │   ├── administration/
    │   │   │   ├── RH/
    │   │   │   │   └── demandes/
    │   │   │   └── finance&compta/
    │   │   └── technique/
    │   │       └── livrables/
    │   │           └── azerty_1745604679689.docx
    │   └── images/
    │       ├── affiches_dcat/
    │       ├── services_dcat/
    │       └── stock_moyensgeneraux/
    │           └── produits/
    ├── modules/
    │   ├── Administration&Finance/
    │   │   ├── FinanceCompta/
    │   │   │   ├── controllers/
    │   │   │   │   └── doc_Fc.controller.js
    │   │   │   ├── routes/
    │   │   │   │   └── doc_FC.route.js
    │   │   │   └── services/
    │   │   │       └── doc_FC.service.js
    │   │   ├── GestionAdministrative/
    │   │   │   ├── controllers/
    │   │   │   │   ├── contrat.controller.js
    │   │   │   │   ├── entite.controller.js
    │   │   │   │   ├── interlocuteur.controller.js
    │   │   │   │   ├── nature.controller.js
    │   │   │   │   └── partenaire.controller.js
    │   │   │   ├── routes/
    │   │   │   │   ├── contrat.route.js
    │   │   │   │   ├── entite.route.js
    │   │   │   │   ├── interlocuteur.route.js
    │   │   │   │   ├── nature.route.js
    │   │   │   │   └── partenaire.route.js
    │   │   │   └── services/
    │   │   │       ├── contrat.service.js
    │   │   │       ├── entite.service.js
    │   │   │       ├── interlocuteur.service.js
    │   │   │       ├── nature.service.js
    │   │   │       └── partenaire.service.js
    │   │   ├── RH/
    │   │   │   ├── controllers/
    │   │   │   │   ├── demande.controller.js
    │   │   │   │   ├── employes.controller.js
    │   │   │   │   └── fonction.controller.js
    │   │   │   ├── routes/
    │   │   │   │   ├── demande.route.js
    │   │   │   │   ├── employe.route.js
    │   │   │   │   └── fonction.route.js
    │   │   │   └── services/
    │   │   │       ├── demande.service.js
    │   │   │       ├── employe.service.js
    │   │   │       └── fonction.service.js
    │   │   └── routes/
    │   │       └── Administration&Finance.routes.js
    │   ├── clients/
    │   │   ├── controllers/
    │   │   │   └── clients.controller.js
    │   │   └── routes/
    │   │       └── clients.routes.js
    │   ├── dashboard/
    │   │   ├── controllers/
    │   │   │   └── dashboard.controller.js
    │   │   └── routes/
    │   │       └── dashboard.routes.js
    │   ├── ecommerceweb/
    │   ├── marketing_commercial/
    │   │   ├── controllers/
    │   │   │   ├── affiches.controller.js
    │   │   │   ├── clients.controller.js
    │   │   │   ├── commandes.controller.js
    │   │   │   ├── produits.controller.js
    │   │   │   └── services_dcat.controller.js
    │   │   ├── routes/
    │   │   │   ├── affiches.routes.js
    │   │   │   ├── clients.routes.js
    │   │   │   ├── commandes.routes.js
    │   │   │   ├── marketing_commercial.routes.js
    │   │   │   ├── produits.routes.js
    │   │   │   └── services_dcat.routes.js
    │   │   └── services/
    │   │       ├── affiches.service.js
    │   │       ├── clients.service.js
    │   │       ├── commandes.service.js
    │   │       ├── produits.service.js
    │   │       └── services_dcat.service.js
    │   ├── moyens_generaux/
    │   │   ├── controllers/
    │   │   │   ├── maintenance.controller.js
    │   │   │   ├── maintenanceMoyenTravail.controller.js
    │   │   │   ├── mouvementOutil.controller.js
    │   │   │   └── moyensdeTravail.controller.js
    │   │   ├── routes/
    │   │   │   ├── maintenance.route.js
    │   │   │   ├── maintenanceMoyenTravail.route.js
    │   │   │   ├── mouvementOutil.route.js
    │   │   │   ├── moyens_generaux.routes.js
    │   │   │   └── moyensdeTravail.route.js
    │   │   └── services/
    │   │       ├── maintenance.service.js
    │   │       ├── maintenanceMoyenTravail.service.js
    │   │       ├── mouvementOutil.service.js
    │   │       └── moyensdeTravail.service.js
    │   ├── stocks/
    │   │   ├── readme.md
    │   │   ├── controllers/
    │   │   │   ├── achat.controller.js
    │   │   │   ├── categorie.controller.js
    │   │   │   ├── commande.controller.js
    │   │   │   ├── exemplaire.controller.js
    │   │   │   ├── famille.controller.js
    │   │   │   ├── livraison.controller.js
    │   │   │   ├── marque.controller.js
    │   │   │   ├── modele.controller.js
    │   │   │   ├── produit.controller.js
    │   │   │   ├── sortiesExemplaire.controller.js
    │   │   │   ├── stocks.controller.js
    │   │   │   └── typesProduit.controller.js
    │   │   ├── routes/
    │   │   │   ├── achat.route.js
    │   │   │   ├── categorie.route.js
    │   │   │   ├── commande.route.js
    │   │   │   ├── exemplaire.routes.js
    │   │   │   ├── famille.routes.js
    │   │   │   ├── livraison.routes.js
    │   │   │   ├── marque.routes.js
    │   │   │   ├── modele.routes.js
    │   │   │   ├── produit.routes.js
    │   │   │   ├── sortiesExemplaire.route.js
    │   │   │   ├── stocks.routes.js
    │   │   │   └── typesProduit.routes.js
    │   │   ├── services/
    │   │   │   ├── achat.service.js
    │   │   │   ├── categorie.service.js
    │   │   │   ├── commande.service.js
    │   │   │   ├── exemplaire.service.js
    │   │   │   ├── famille.service.js
    │   │   │   ├── livraison.service.js
    │   │   │   ├── marque.service.js
    │   │   │   ├── modele.service.js
    │   │   │   ├── produit.service.js
    │   │   │   ├── sortieExemplaire.service.js
    │   │   │   ├── stocks.service.js
    │   │   │   └── typesProduit.service.js
    │   │   ├── tests/
    │   │   │   └── stocks.mock.js
    │   │   └── utils/
    │   │       ├── drizzle-wrapper.js
    │   │       └── setup-triggers.js
    │   ├── technique/
    │   │   ├── controllers/
    │   │   │   ├── interventions.controller.js
    │   │   │   ├── livrable.controller.js
    │   │   │   ├── projets.controller.js
    │   │   │   └── taches.controller.js
    │   │   ├── routes/
    │   │   │   ├── interventions.routes.js
    │   │   │   ├── livrable.routes.js
    │   │   │   ├── projets.routes.js
    │   │   │   ├── taches.routes.js
    │   │   │   └── technique.routes.js
    │   │   └── services/
    │   │       ├── interventions.service.js
    │   │       ├── livrable.service.js
    │   │       ├── projets.service.js
    │   │       └── taches.service.js
    │   └── utils/
    │       └── middleware/
    │           ├── uploadMiddleware.js
    │           └── uploadOriginalNameMiddleware.js
    └── .github/
        └── workflows/
            └── main.yml

================================================
File: README.md
================================================
[Non-text file]


================================================
File: Dockerfile
================================================
# Ã‰tape 1 : Builder les dÃ©pendances
FROM node:22-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev  # Installe uniquement les dÃ©pendances de production

# Ã‰tape 2 : Image finale
FROM node:22-alpine

WORKDIR /app

# Copie des dÃ©pendances et du code
COPY --from=builder /app/node_modules ./node_modules
COPY . .

# SÃ©curitÃ©
RUN chown -R node:node /app \
    && apk add --no-cache tini  # Pour gÃ©rer correctement les signaux
USER node

# Port exposÃ© (doit correspondre Ã  votre .env)
EXPOSE 2000

# Point d'entrÃ©e avec Tini pour Ã©viter les zombies
ENTRYPOINT ["/sbin/tini", "--"]

# Commande de dÃ©marrage (utilise la variable PORT depuis .env)
CMD node server.js



================================================
File: docker-compose.prod.yml
================================================
version: '3.8'

services:
  # Service Backend
  app:
    build: .
    container_name: dcat_backend
    ports:
      - "2000:2000"
    env_file:
      - .env
    environment:
      DB_HOST: postgres
      DB_NAME: ${APP_DB_NAME:-app_db_name}
      DB_USER: ${APP_DB_USER:-app_db_user}
      DB_PASSWORD: ${APP_DB_PASSWORD:-app_db_password}
    depends_on:
      - postgres
      - keycloak
    restart: always
    networks:
      - dcat_network

  # Service PostgreSQL
  postgres:
    image: postgres:15-alpine
    container_name: dcat_postgres
    env_file: .env
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-default_postgres_password}
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db:/docker-entrypoint-initdb.d
      - ./.env:/tmp/.env:ro
    ports:
      - "${DB_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - dcat_network

  # Service Keycloak
  keycloak:
    image: quay.io/keycloak/keycloak:26.1.4
    container_name: keycloak
    env_file: .env
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/${KEYCLOAK_DB_NAME:-keycloak_db}
      KC_DB_USERNAME: ${KEYCLOAK_DB_USER:-keycloak_user}
      KC_DB_PASSWORD: ${KEYCLOAK_DB_PASSWORD:-keycloak123}
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin123}
      KC_PROXY_HEADERS: xforwarded
      KC_HOSTNAME: keycloak.dcat.ci
      KC_HOSTNAME_STRICT: "false"
      KC_HTTP_ENABLED: "true"
      KC_LANGUAGES: fr
    command: ["start", "--hostname-strict=false"]
    ports:
      - "8080:8080" 
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - dcat_network
volumes:
  postgres_data:

networks:
  dcat_network:
    driver: bridge







================================================
File: docker-compose.yml
================================================
version: '3.8'

services:
  # app:
  #   build: .
  #   container_name: dcat_backend
  #   ports:
  #     - "2000:2000"
  #   env_file:
  #     - .env
  #   environment:
  #     DB_HOST: postgres
  #     DB_NAME: ${APP_DB_NAME:-app_db_name}
  #     DB_USER: ${APP_DB_USER:-app_db_user}
  #     DB_PASSWORD: ${APP_DB_PASSWORD:-app_db_password}
  #   depends_on:
  #     - postgres
  #     - keycloak
  #   networks:
  #     - dcat_network

  postgres:
    image: postgres:15-alpine
    container_name: dcat_postgres
    env_file: .env
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-default_postgres_password}
      POSTGRES_USER: ${POSTGRES_USER:-default_postgres_user}
      # POSTGRES_DB: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db:/docker-entrypoint-initdb.d
      - ./.env:/tmp/.env:ro
    ports:
      - "${DB_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - dcat_network

  keycloak:
    image: quay.io/keycloak/keycloak:26.1.4
    container_name: keycloak
    env_file: .env
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/${KEYCLOAK_DB_NAME:-keycloak_db}
      KC_DB_USERNAME: ${KEYCLOAK_DB_USER:-keycloak_user}
      KC_DB_PASSWORD: ${KEYCLOAK_DB_PASSWORD:-keycloak123}
      KC_BOOTSTRAP_ADMIN_USERNAME: admin
      KC_BOOTSTRAP_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin123}
      KC_HOSTNAME: ${KC_HOSTNAME:-localhost}
      KC_HEALTH_ENABLED: true
      KC_PROXY: edge
    ports:
      - "8080:8080"
    depends_on:
      postgres:
        condition: service_healthy
    command: ["start-dev"]
    networks:
      - dcat_network

volumes:
  postgres_data:

networks:
  dcat_network:
    driver: bridge


================================================
File: drizzle.config.js
================================================
require('dotenv').config();

module.exports = {
  schema: "./core/database/models.js",
  out: "./core/database/migrations",
  dialect: "postgresql", 
  dbCredentials: {
  url: `postgresql://${process.env.APP_DB_USER}:${process.env.APP_DB_PASSWORD}@${process.env.DB_HOST}:${process.env.DB_PORT}/${process.env.APP_DB_NAME}`
  },
  verbose: true,
  strict: true,
  ...(process.env.NODE_ENV === 'development' && {
    debug: true,
    migrationsTable: 'migrations_dev'
  })
};





================================================
File: package.json
================================================
{
  "scripts": {
    "start": "nodemon server.js"
  },
  "dependencies": {
    "@keycloak/keycloak-admin-client": "^26.1.4",
    "bcryptjs": "^3.0.2",
    "cors": "^2.8.5",
    "dayjs": "^1.11.13",
    "dotenv": "^16.4.7",
    "drizzle-kit": "^0.30.6",
    "drizzle-orm": "^0.41.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jose": "^6.0.10",
    "jsonwebtoken": "^9.0.2",
    "keycloak-connect": "^26.1.1",
    "multer": "^1.4.5-lts.2",
    "nodemailer": "^7.0.3",
    "nodemon": "^3.1.9",
    "openid-client": "^6.4.1",
    "pg": "^8.15.6",
    "pg-promise": "^11.13.0",
    "postgres-js": "^0.1.0",
    "sequelize": "^6.37.7",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.17.0"
  }
}



================================================
File: post-init.sh
================================================
#!/bin/bash

# Charger les variables d'environnement
source .env

# Couleurs pour les messages
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Fonction pour afficher les messages d'information
info() {
    echo -e "${YELLOW}[INFO] $1${NC}"
}

# Fonction pour afficher les messages de succÃ¨s
success() {
    echo -e "${GREEN}[SUCCESS] $1${NC}"
}

# Fonction pour afficher les messages d'erreur
error() {
    echo -e "${RED}[ERROR] $1${NC}"
}

# VÃ©rification des variables d'environnement requises
check_env_vars() {
    local missing_vars=()
    
    # VÃ©rifier les variables PostgreSQL superuser
    [ -z "$POSTGRES_USER" ] && missing_vars+=("POSTGRES_USER")
    [ -z "$POSTGRES_PASSWORD" ] && missing_vars+=("POSTGRES_PASSWORD")
    
    # VÃ©rifier les variables de connexion DB
    [ -z "$DB_HOST" ] && missing_vars+=("DB_HOST")
    [ -z "$DB_PORT" ] && missing_vars+=("DB_PORT")
    
    # VÃ©rifier les variables Keycloak
    [ -z "$KEYCLOAK_DB_NAME" ] && missing_vars+=("KEYCLOAK_DB_NAME")
    [ -z "$KEYCLOAK_DB_USER" ] && missing_vars+=("KEYCLOAK_DB_USER")
    [ -z "$KEYCLOAK_DB_PASSWORD" ] && missing_vars+=("KEYCLOAK_DB_PASSWORD")
    
    # VÃ©rifier les variables App
    [ -z "$APP_DB_NAME" ] && missing_vars+=("APP_DB_NAME")
    [ -z "$APP_DB_USER" ] && missing_vars+=("APP_DB_USER")
    [ -z "$APP_DB_PASSWORD" ] && missing_vars+=("APP_DB_PASSWORD")
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        error "Variables d'environnement manquantes : ${missing_vars[*]}"
        return 1
    fi
    
    return 0
}

# Application des migrations avec Drizzle
apply_migrations() {
    info "Application des migrations de base de donnÃ©es avec Drizzle..."
    npx drizzle-kit push
    
    if [ $? -eq 0 ]; then
        success "Migrations appliquÃ©es avec succÃ¨s"
        return 0
    else
        error "Erreur lors de l'application des migrations"
        return 1
    fi
}

# Configuration de la synchronisation SQL
configure_sql_sync() {
    info "ExÃ©cution de la configuration SQL pour la synchronisation des utilisateurs..."
    
    # CrÃ©er un fichier SQL temporaire avec les variables d'environnement remplacÃ©es
    cat > /tmp/post-init.sql << EOL
-- 1. Installer l'extension DBLink si elle n'est pas dÃ©jÃ  prÃ©sente
CREATE EXTENSION IF NOT EXISTS dblink;

-- 2. CrÃ©er une table pour journaliser les erreurs
CREATE TABLE IF NOT EXISTS sync_error_log (
    id SERIAL PRIMARY KEY,
    operation TEXT,
    error_message TEXT,
    user_id TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 3. CrÃ©er la fonction de synchronisation avec DBLink
CREATE OR REPLACE FUNCTION sync_keycloak_users_to_employes()
RETURNS TRIGGER AS \$\$
DECLARE
    conn_string TEXT := 'dbname=${APP_DB_NAME} host=${DB_HOST} user=${APP_DB_USER} password=${APP_DB_PASSWORD}';
    conn_exists BOOLEAN;
BEGIN
    -- Correction pour la vÃ©rification de connexion
    BEGIN
        PERFORM dblink_connect('conn_check', conn_string);
        conn_exists := TRUE;
    EXCEPTION WHEN OTHERS THEN
        conn_exists := FALSE;
    END;

    IF TG_OP = 'INSERT' THEN
        BEGIN
            PERFORM dblink_exec(
                'conn_check',
                format('INSERT INTO employes(
                    keycloak_id, 
                    nom_employes, 
                    prenom_employes, 
                    email_employes,
                    status_employes,
                    date_embauche_employes,
                    password_employes,
                    created_at,
                    updated_at
                ) VALUES (
                    %L, %L, %L, %L, %L, CURRENT_DATE, %L, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
                )',
                NEW.id,
                COALESCE(NEW.last_name, ''),
                COALESCE(NEW.first_name, ''),
                COALESCE(NEW.email, ''),
                'actif',
                '' -- password vide, sera configurÃ© par l'utilisateur
                )
            );
        EXCEPTION WHEN OTHERS THEN
            INSERT INTO sync_error_log (operation, error_message, user_id)
            VALUES ('INSERT', SQLERRM, NEW.id);
        END;
    ELSIF TG_OP = 'UPDATE' THEN
        BEGIN
            -- VÃ©rifier si l'enregistrement existe dÃ©jÃ 
            IF EXISTS (SELECT 1 FROM dblink('conn_check',
                    format('SELECT 1 FROM employes WHERE keycloak_id = %L', NEW.id)
                ) AS t(exists int)) THEN
                -- Si l'enregistrement existe, le mettre Ã  jour
                PERFORM dblink_exec(
                    'conn_check',
                    format('UPDATE employes SET
                        nom_employes = %L,
                        prenom_employes = %L,
                        email_employes = %L,
                        updated_at = CURRENT_TIMESTAMP
                        WHERE keycloak_id = %L',
                        COALESCE(NEW.last_name, ''),
                        COALESCE(NEW.first_name, ''),
                        COALESCE(NEW.email, ''),
                        NEW.id
                    )
                );
            ELSE
                -- Si l'enregistrement n'existe pas, l'insÃ©rer
                PERFORM dblink_exec(
                    'conn_check',
                    format('INSERT INTO employes(
                        keycloak_id, 
                        nom_employes, 
                        prenom_employes, 
                        email_employes,
                        status_employes,
                        date_embauche_employes,
                        password_employes,
                        created_at,
                        updated_at
                    ) VALUES (
                        %L, %L, %L, %L, %L, CURRENT_DATE, %L, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
                    )',
                    NEW.id,
                    COALESCE(NEW.last_name, ''),
                    COALESCE(NEW.first_name, ''),
                    COALESCE(NEW.email, ''),
                    'actif',
                    '' -- password vide
                    )
                );
            END IF;
        EXCEPTION WHEN OTHERS THEN
            INSERT INTO sync_error_log (operation, error_message, user_id)
            VALUES ('UPDATE', SQLERRM, NEW.id);
        END;
    ELSIF TG_OP = 'DELETE' THEN
        BEGIN
            -- On ne supprime pas les enregistrements mais on les marque comme inactifs
            PERFORM dblink_exec(
                'conn_check',
                format('UPDATE employes SET 
                    status_employes = %L,
                    updated_at = CURRENT_TIMESTAMP
                    WHERE keycloak_id = %L',
                    'inactif',
                    OLD.id
                )
            );
        EXCEPTION WHEN OTHERS THEN
            INSERT INTO sync_error_log (operation, error_message, user_id)
            VALUES ('DELETE', SQLERRM, OLD.id);
        END;
    END IF;

    RETURN NULL;
END;
\$\$ LANGUAGE plpgsql;

-- 4. CrÃ©er le trigger sur la table user_entity de Keycloak
DROP TRIGGER IF EXISTS sync_keycloak_users_trigger ON user_entity;
CREATE TRIGGER sync_keycloak_users_trigger
AFTER INSERT OR UPDATE OR DELETE ON user_entity
FOR EACH ROW EXECUTE FUNCTION sync_keycloak_users_to_employes();

-- 5. Fonction d'initialisation pour synchroniser les utilisateurs existants
CREATE OR REPLACE FUNCTION init_sync_keycloak_users()
RETURNS VOID AS \$\$
DECLARE
    conn_string TEXT := 'dbname=${APP_DB_NAME} host=${DB_HOST} user=${APP_DB_USER} password=${APP_DB_PASSWORD}';
    user_record RECORD;
BEGIN
    -- Ã‰tablir la connexion
    PERFORM dblink_connect('conn_init', conn_string);

    -- Parcourir tous les utilisateurs existants
    FOR user_record IN SELECT id, first_name, last_name, email FROM user_entity LOOP
        BEGIN
            -- VÃ©rifier si l'utilisateur existe dÃ©jÃ 
            IF NOT EXISTS (
                SELECT 1 FROM dblink('conn_init',
                    format('SELECT 1 FROM employes WHERE keycloak_id = %L', user_record.id)
                ) AS t(exists int)
            ) THEN
                -- Si l'utilisateur n'existe pas, l'ajouter
                PERFORM dblink_exec(
                    'conn_init',
                    format('INSERT INTO employes(
                        keycloak_id, 
                        nom_employes, 
                        prenom_employes, 
                        email_employes,
                        status_employes,
                        date_embauche_employes,
                        password_employes,
                        created_at,
                        updated_at
                    ) VALUES (
                        %L, %L, %L, %L, %L, CURRENT_DATE, %L, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
                    )',
                    user_record.id,
                    COALESCE(user_record.last_name, ''),
                    COALESCE(user_record.first_name, ''),
                    COALESCE(user_record.email, ''),
                    'actif',
                    '' -- password vide
                    )
                );
            END IF;
        EXCEPTION WHEN OTHERS THEN
            -- Log d'erreur pour cet utilisateur spÃ©cifique
            INSERT INTO sync_error_log (operation, error_message, user_id)
            VALUES ('INIT_SYNC', SQLERRM, user_record.id);
        END;
    END LOOP;
    
    -- Fermer la connexion
    PERFORM dblink_disconnect('conn_init');
END;
\$\$ LANGUAGE plpgsql;

-- 6. CrÃ©er une fonction pour tester la connexion
CREATE OR REPLACE FUNCTION test_dblink_connection()
RETURNS BOOLEAN AS \$\$
DECLARE
    conn_string TEXT := 'dbname=${APP_DB_NAME} host=${DB_HOST} user=${APP_DB_USER} password=${APP_DB_PASSWORD}';
    success BOOLEAN := FALSE;
BEGIN
    BEGIN
        PERFORM dblink_connect('test_conn', conn_string);
        PERFORM dblink_disconnect('test_conn');
        
        INSERT INTO sync_error_log (operation, error_message, user_id)
        VALUES ('CONNECTION_TEST', 'Connection successful', 'SYSTEM');
        
        success := TRUE;
    EXCEPTION WHEN OTHERS THEN
        INSERT INTO sync_error_log (operation, error_message, user_id)
        VALUES ('CONNECTION_TEST', SQLERRM, 'SYSTEM');
        success := FALSE;
    END;
    
    RETURN success;
END;
\$\$ LANGUAGE plpgsql;

-- ExÃ©cuter le test de connexion
SELECT test_dblink_connection();

-- Accorder les privilÃ¨ges Ã  l'utilisateur Keycloak sur la table sync_error_log
GRANT ALL PRIVILEGES ON TABLE sync_error_log TO ${KEYCLOAK_DB_USER};
GRANT USAGE, SELECT ON SEQUENCE sync_error_log_id_seq TO ${KEYCLOAK_DB_USER};

-- ExÃ©cuter la synchronisation initiale
SELECT init_sync_keycloak_users();
EOL

    # ExÃ©cuter le script SQL
    PGPASSWORD=${POSTGRES_PASSWORD} psql -h ${DB_HOST} -p ${DB_PORT} -U ${POSTGRES_USER} -d ${KEYCLOAK_DB_NAME} -f /tmp/post-init.sql
    
    if [ $? -eq 0 ]; then
        success "Configuration SQL pour la synchronisation des utilisateurs effectuÃ©e avec succÃ¨s"
        return 0
    else
        error "Erreur lors de la configuration SQL"
        return 1
    fi
}

# Configuration de Keycloak avec Node.js
configure_keycloak() {
    info "ExÃ©cution du script Node.js pour la configuration de Keycloak..."
    
    # ExÃ©cuter le script Node.js
    node keycloak-setup/keycloak-setup.js
    
    if [ $? -eq 0 ]; then
        success "Configuration de Keycloak effectuÃ©e avec succÃ¨s"
        return 0
    else
        error "Erreur lors de la configuration de Keycloak via Node.js"
        return 1
    fi
}

# Fonction principale
main() {
    info "DÃ©marrage de la configuration post-initialisation..."
    
    # VÃ©rifier les variables d'environnement
    if ! check_env_vars; then
        error "Configuration abandonnÃ©e en raison de variables d'environnement manquantes"
        exit 1
    fi
    
    # Appliquer les migrations
    if ! apply_migrations; then
        error "Configuration abandonnÃ©e en raison d'erreurs lors de l'application des migrations"
        exit 1
    fi
    
    info "ExÃ©cution des scripts post-initialisation..."
    
    # Configurer la synchronisation SQL
    if ! configure_sql_sync; then
        error "Configuration abandonnÃ©e en raison d'erreurs lors de la configuration SQL"
        exit 1
    fi
    
    # Configurer Keycloak
    if ! configure_keycloak; then
        error "Configuration abandonnÃ©e en raison d'erreurs lors de la configuration de Keycloak"
        exit 1
    fi
    
    success "Toutes les configurations post-initialisation ont Ã©tÃ© rÃ©alisÃ©es avec succÃ¨s !"
    success "Vous pouvez maintenant utiliser votre systÃ¨me avec la synchronisation configurÃ©e."
}

# ExÃ©cution de la fonction principale
main


================================================
File: server.js
================================================
ï»¿const express = require("express");
const path = require("path");
const helmet = require("helmet");
const { keycloak } = require("./core/auth/keycloak.config");
const { initKeycloak, protect } = require("./core/auth/middleware");
const logger = require("./core/utils/logger");
const swaggerRoutes = require('./core/utils/swagger.routes');

require("dotenv").config();

// Initialisation Express
const app = express();

// =============== MIDDLEWARES DE BASE ===============
app.use(helmet());
app.disable("x-powered-by");
app.use(express.json({ limit: "10kb" }));
app.use(express.urlencoded({ extended: true, limit: "10kb" }));

// =============== KEYCLOAK ===============
app.use(initKeycloak());

// =============== CORS ===============
const cors = require('cors');
app.use(cors({
  origin: 'http://localhost:5173'
}));

// =============== CHARGEMENT DES MODULES ===============
function loadModule(moduleName) {
  try {
    const modulePath = path.join(
      __dirname,
      "modules",
      moduleName,
      "routes",
      `${moduleName}.routes.js`
    );
    const router = require(modulePath);
    logger.info(`Module chargÃ©: ${moduleName}`);
    return router;
  } catch (error) {
    logger.error(`Ã‰chec du chargement du module ${moduleName}`, error);
    process.exit(1);
  }
}

// Swagger 
app.use('/api', swaggerRoutes);

// Chargement des modules
app.use("/api/stocks", loadModule("stocks"));
app.use("/api/moyens-generaux", loadModule("moyens_generaux"));
app.use("/api/administration", loadModule("Administration&Finance"));

// CHARGEMENT DES ENDPOINT DU MODULZ TECHNIQUES

app.use("/api/technique", loadModule("technique"));

app.use("/api/marketing_commercial", loadModule("marketing_commercial"));

// =============================================
// ROUTES PUBLIQUES
// =============================================

app.get("/health", (req, res) => {
  res.json({
    status: "OK",
    // auth: 'bearer-only',
    keycloak: {
      realm: keycloak.config.realm,
      clientId: keycloak.config.resource,
    },
  });
});

// Pour les fichiers
app.use("/media", express.static(path.join(process.cwd(), "media")));

// =============== ROUTES PROTÃ‰GÃ‰ES ===============
app.get("/api/protected", protect(), (req, res) => {
  res.json({
    message: "AccÃ¨s autorisÃ©",
    user: req.kauth.grant.access_token.content,
  });
});

// =============== GESTION DES ERREURS ===============
app.use((req, res) => {
  res.status(404).json({
    error: "Endpoint non trouvÃ©",
    path: req.path,
  });
});

app.use((err, req, res, next) => {
  const status = err.status || 500;
  logger.error({
    status,
    message: err.message,
    path: req.path,
    stack: process.env.NODE_ENV === "development" ? err.stack : undefined,
  });
  res.status(status).json({
    error: status === 500 ? "Erreur interne" : err.message,
  });
});

// =============================================
// DÃ‰MARRAGE DU SERVEUR
// =============================================
// const PORT = process.env.PORT || 3000;
const PORT = 2000;
app.listen(PORT, () => {
  logger.info(`Server running on port ${PORT}`);
  logger.info(`Keycloak configured for realm: ${keycloak.config.realm}`);
  logger.info("Available routes:");
  logger.info(`- GET  http://localhost:${PORT}/health`);
  logger.info(`- GET  http://localhost:${PORT}/api/technique`);
  logger.info(`- POST http://localhost:${PORT}/api/interventions (protected)`);
  logger.info(`- GET  http://localhost:${PORT}/api/stocks`);
  logger.info(
    `- POST http://localhost:${PORT}/api/stocks (protected, requires inventory-manager role)`
  );
  logger.info(`- GET  http://localhost:${PORT}/api/protected (protected)`);
  logger.info(`- ###################NODE_ENV:${process.env.NODE_ENV}########################`);

});



================================================
File: core/auth/keycloak.config.js
================================================
ï»¿const Keycloak = require('keycloak-connect');
const logger = require('../utils/logger');
require('dotenv').config();

// const keycloakConfig = {
//   realm: process.env.KEYCLOAK_REALM,
//   'auth-server-url': process.env.KEYCLOAK_URL,
//   'ssl-required': 'external',
//   resource: process.env.KEYCLOAK_CLIENT_ID,
//   'bearer-only': true,
//   'verify-token-audience': true,
//   credentials: {
//     secret: process.env.KEYCLOAK_CLIENT_SECRET
//   }
// };


const keycloakConfig = {
  realm: process.env.KEYCLOAK_REALM,
  'auth-server-url': process.env.KEYCLOAK_URL,
  'ssl-required': 'external',
  // resource: process.env.KEYCLOAK_CLIENT_ID,
  resource: process.env.KEYCLOAK_BACKEND_CLIENT_ID,
  'bearer-only': true,
  'confidential-port': 0, // Important pour les clients confidentiels
  'verify-token-audience': true,
  'use-resource-role-mappings': true, // Prend en compte les rÃ´les client
  credentials: {
    secret: process.env.KEYCLOAK_BACKEND_CLIENT_SECRET
  }
};

// Validation de la configuration
if (!process.env.KEYCLOAK_BACKEND_CLIENT_SECRET) {
  logger.error('Configuration Keycloak incomplÃ¨te : KEYCLOAK_CLIENT_SECRET manquant');
  process.exit(1);
}

const keycloak = new Keycloak({}, keycloakConfig);

module.exports = {
  keycloak,
  keycloakConfig
};


================================================
File: core/auth/middleware.js
================================================
const { keycloak } = require('./keycloak.config');
const { getKeycloakPublicKey } = require('./setupKeycloak');
const { jwtVerify } = require('jose');
const logger = require('../utils/logger');

// Middleware d'initialisation Keycloak
const initKeycloak = () => {
  logger.info('Middleware Keycloak initialisÃ© (mode bearer-only)');
  return keycloak.middleware();
};


const protect = (requiredRoles = []) => {
  return [
    keycloak.protect(),
    async (req, res, next) => {
      if (requiredRoles.length === 0) return next();
      
      const token = req.kauth.grant.access_token;
      const roles = token.content.realm_access?.roles || [];
      
      const hasRole = requiredRoles.some(role => roles.includes(role));
      
      if (!hasRole) {
        logger.warn(`AccÃ¨s refusÃ© - RÃ´les manquants`, {
          user: token.content.sub,
          providedRoldes:requiredRoles,
          actualRoles: roles
        });
        return res.status(403).json({ error: 'Permissions insuffisantes' });
      }
      next();
    }
  ];
};


// Validation JWT autonome
const validateJWT = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ error: 'Authorization header manquant' });
  }

  try {
    const token = authHeader.split(' ')[1];
    const { payload } = await jwtVerify(token, await getKeycloakPublicKey());
    req.userToken = payload;
    next();
  } catch (error) {
    logger.error('Ã‰chec de validation JWT', error);
    res.status(401).json({ error: 'Token invalide' });
  }
};

module.exports = {
  initKeycloak,
  protect,
  validateJWT,
  keycloak
};



================================================
File: core/auth/setupKeycloak.js
================================================
const { keycloak } = require('./keycloak.config');
const { createRemoteJWKSet } = require('jose');
const { Issuer } = require('openid-client');
const logger = require('../utils/logger');

async function getKeycloakPublicKey() {
  try {
    const issuer = await Issuer.discover(
      `${keycloak.config['auth-server-url']}/realms/${keycloak.config.realm}`
    );
    return createRemoteJWKSet(new URL(issuer.metadata.jwks_uri));
  } catch (error) {
    logger.error('Erreur de rÃ©cupÃ©ration des clÃ©s Keycloak', error);
    throw new Error('Service d\'authentification indisponible');
  }
}

module.exports = {
  getKeycloakPublicKey
};


================================================
File: core/database/config.js
================================================
const pg = require('pg');
const { drizzle } = require('drizzle-orm/node-postgres');
const schema = require('./models.js');
require('dotenv').config();

// Configuration du pool PostgreSQL
const pool = new pg.Pool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.APP_DB_USER,
  password: process.env.APP_DB_PASSWORD,
  database: process.env.APP_DB_NAME,
  ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false
});

// Test de connexion
pool.connect()
  .then(() => console.log('✅ Connected to PostgreSQL'))
  .catch(err => console.error('❌ PostgreSQL connection error:', err));

// Export en CommonJS
module.exports = {
  db: drizzle(pool, { schema }),
  pool
};


================================================
File: core/database/db.config.js
================================================
ï»¿module.exports = {
  HOST: process.env.DB_HOST || "postgres", 
  USER: process.env.DB_USER || "dcat_user",
  PASSWORD: process.env.DB_PASSWORD || "dcat_password",
  DB: process.env.DB_NAME || "dcat_db",
  dialect: "postgres",
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
};


================================================
File: core/database/migration.js
================================================
require("dotenv").config();
const { migrate } = require("drizzle-orm/node-postgres/migrator");
const { db } = require("./db.config");

(async () => {
  console.log("⏳ Migration en cours...");
  await migrate(db, { migrationsFolder: "backend/migrations" });
  console.log("✅ Migration terminée !");
  process.exit(0);
})();



================================================
File: core/database/models.js
================================================
const {
  pgTable,
  serial,
  varchar,
  integer,
  date,
  timestamp,
  decimal,
  boolean,
  text,
  time,
  primaryKey,
  foreignKey,
} = require("drizzle-orm/pg-core");

// Famille
const familles = pgTable("familles", {
  id_famille: serial("id_famille").primaryKey(),
  libelle_famille: varchar("libelle_famille", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Modele
const modeles = pgTable("modeles", {
  id_modele: serial("id_modele").primaryKey(),
  libelle_modele: varchar("libelle_modele", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Marque
const marques = pgTable("marques", {
  id_marque: serial("id_marque").primaryKey(),
  libelle_marque: varchar("libelle_marque", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Fonction
const fonctions = pgTable("fonctions", {
  id_fonction: serial("id_fonction").primaryKey(),
  nom_fonction: varchar("nom_fonction", { length: 50 }).unique(),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Employes
const employes = pgTable("employes", {
  id_employes: serial("id_employes").primaryKey(),
  keycloak_id: varchar("keycloak_id", { length: 100 }).unique(),
  nom_employes: varchar("nom_employes", { length: 50 }),
  prenom_employes: varchar("prenom_employes", { length: 75 }),
  email_employes: varchar("email_employes", { length: 100 }),
  contact_employes: varchar("contact_employes", { length: 50 }),
  adresse_employes: text("adresse_employes"),
  status_employes: varchar("status_employes", { length: 50 }),
  date_embauche_employes: date("date_embauche_employes"),
  password_employes: varchar("password_employes", { length: 255 }),
  date_de_naissance: date("date_de_naissance"),
  contrat: varchar("contrat", { length: 100 }),
  id_fonction: integer("id_fonction").references(() => fonctions.id_fonction),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Demande
const demandes = pgTable("demandes", {
  id_demandes: serial("id_demandes").primaryKey(),
  date_absence: date("date_absence"),
  status: varchar("status", { length: 50 }),
  date_retour: date("date_retour"),
  motif: text("motif"),
  type_demande: varchar("type_demande", { length: 50 }),
  durÃ©e: varchar("durÃ©e", { length: 50 }),
  heure_debut: time("heure_debut"),
  heure_fin: time("heure_fin"),
  id_employes: integer("id_employes").references(() => employes.id_employes),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Nature_document
const nature_documents = pgTable("nature_documents", {
  id_nature_document: serial("id_nature_document").primaryKey(),
  libelle: varchar("libelle", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// EntitÃ©
const entites = pgTable("entites", {
  id_entite: serial("id_entite").primaryKey(),
  denomination: varchar("denomination", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Client_en_ligne
// Client_en_ligne
const clients_en_ligne = pgTable("clients_en_ligne", {
  id_client: serial("id_client").primaryKey(),
  nom: varchar("nom", { length: 50 }),
  role: varchar("role", { length: 50 }).default('client'),
  email: varchar("email", { length: 50 }).unique(),
  password: varchar("password", { length: 255 }),
  contact: varchar("contact", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

const refresh_tokens = pgTable("refresh_tokens", { 
  id: serial("id").primaryKey(),
  user_id: integer("user_id")
    .notNull()
    .references(() => clients_en_ligne.id_client, { onDelete: 'cascade' }),
  token: varchar("token", { length: 255 }).notNull().unique(),
  expires_at: timestamp("expires_at").notNull(),
  created_at: timestamp("created_at").defaultNow().notNull(),
});


// Commande
const commandes = pgTable("commandes", {
  id_commande: serial("id_commande").primaryKey(),
  date_de_commande: date("date_de_commande"),
  etat_commande: varchar("etat_commande", { length: 50 }).default("En cours"),
  date_livraison: date("date_livraison"),
  lieu_de_livraison: varchar("lieu_de_livraison", { length: 50 }),
  mode_de_paiement: varchar("mode_de_paiement", { length: 50 }),
  id_client: integer("id_client").references(() => clients_en_ligne.id_client),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Type_produit
const type_produits = pgTable("type_produits", {
  id_type_produit: serial("id_type_produit").primaryKey(),
  libelle: varchar("libelle", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// CatÃ©gorie
const categories = pgTable("categories", {
  id_categorie: serial("id_categorie").primaryKey(),
  libelle: varchar("libelle", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Projet
const projets = pgTable("projets", {
  id_projet: serial("id_projet").primaryKey(),
  nom_projet: varchar("nom_projet", { length: 50 }).notNull(),
  type_projet: varchar("type_projet", { length: 50 }).notNull(),
  devis_estimatif: decimal("devis_estimatif", {
    precision: 10,
    scale: 2,
  }),
  date_debut: date("date_debut"),
  date_fin: date("date_fin"),
  duree_prevu_projet: varchar("duree_prevu_projet", { length: 50 }),
  description_projet: text("description_projet"),
  etat: varchar("etat", { length: 50 }),
  lieu: varchar("lieu", { length: 50 }),
  responsable: varchar("responsable", { length: 50 }),
  site: varchar("site", { length: 50 }),
  id_famille: integer("id_famille").references(() => familles.id_famille),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Tache
const taches = pgTable("taches", {
  id_tache: serial("id_tache").primaryKey(),
  nom_tache: varchar("nom_tache", { length: 50 }),
  desc_tache: text("desc_tache"),
  statut: varchar("statut", { length: 50 }),
  date_debut: date("date_debut"),
  date_fin: date("date_fin"),
  priorite: varchar("priorite", { length: 50 }),
  id_projet: integer("id_projet").references(() => projets.id_projet),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Prestation
const prestations = pgTable("prestations", {
  id_prestation: serial("id_prestation").primaryKey(),
  date_de_maintenance: date("date_de_maintenance"),
  type_de_maintenance: varchar("type_de_maintenance", { length: 50 }),
  description: text("description"),
  responsable: varchar("responsable", { length: 50 }),
  pieces_remplacees: text("pieces_remplacees"),
  cout_maintenance: decimal("cout_maintenance", {
    precision: 10,
    scale: 2,
  }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Livrable
const livrables = pgTable("livrables", {
  id_livrable: serial("id_livrable").primaryKey(),
  libelle_livrable: varchar("libelle_livrable", { length: 100 }),
  date: date("date"),
  realisations: text("realisations"),
  reserves: text("reserves"),
  approbation: text("approbation"),
  recommandation: text("recommandation"),
  id_projet: integer("id_projet").references(() => projets.id_projet),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Moyens_de_travail
const moyens_de_travail = pgTable("moyens_de_travail", {
  id_moyens_de_travail: serial("id_moyens_de_travail").primaryKey(),
  denomination: varchar("denomination", { length: 50 }),
  date_acquisition: date("date_acquisition"),
  section: varchar("section", { length: 50 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Service
const services = pgTable("services", {
  id_service: serial("id_service").primaryKey(),
  titre_service: varchar("titre_service", { length: 100 }),
  sous_titre_service: varchar("sous_titre_service", { length:  200}),
  detail_service: text("detail_service"),
  image_service: varchar("image", { length: 255 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Affiche
const affiches = pgTable("affiches", {
  id_affiche: serial("id_affiche").primaryKey(),
  image: varchar("image", { length: 255 }),
  titre_promotion: varchar("titre_promotion", { length: 100 }),
  sous_titre_promotion: varchar("sous_titre_promotion", { length: 150 }),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Produit
const produits = pgTable("produits", {
  id_produit: serial("id_produit").primaryKey(), // ClÃ© primaire simple
  code_produit: varchar("code_produit", { length: 100 }).unique(),
  desi_produit: varchar("desi_produit", { length: 50 }),
  desc_produit: text("desc_produit"),
  image_produit: text("image_produit"),
  qte_produit: integer("qte_produit").default(0),
  emplacement_produit: text("emplacement"),
  caracteristiques_produit: text("caracteristiques"),
  prix_produit: decimal("prix_produit", {
    precision: 10,
    scale: 2,
  }),
  id_categorie: integer("id_categorie").references(
    () => categories.id_categorie
  ),
  id_type_produit: integer("id_type_produit").references(
    () => type_produits.id_type_produit
  ),
  id_modele: integer("id_modele").references(() => modeles.id_modele),
  id_famille: integer("id_famille").references(() => familles.id_famille),
  id_marque: integer("id_marque").references(() => marques.id_marque),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Partenaire
const partenaires = pgTable("partenaires", {
  id_partenaire: serial("id_partenaire").primaryKey(),
  nom_partenaire: varchar("nom_partenaire", { length: 50 }),
  telephone_partenaire: varchar("telephone_partenaire", {
    length: 50,
  }),
  email_partenaire: varchar("email_partenaire", { length: 100 }).unique(),
  specialite: varchar("specialite", { length: 50 }),
  localisation: varchar("localisation", { length: 50 }),
  type_partenaire: varchar("type_partenaire", { length: 50 }),
  statut: varchar("statut", { length: 50 }),
  id_entite: integer("id_entite").references(() => entites.id_entite),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Contrat
const contrats = pgTable("contrats", {
  id_contrat: serial("id_contrat").primaryKey(),
  nom_contrat: varchar("nom_contrat", { length: 50 }),
  duree_contrat: varchar("duree_contrat", { length: 50 }),
  date_debut: date("date_debut"),
  date_fin: date("date_fin"),
  reference: varchar("reference", { length: 50 }),
  type_de_contrat: varchar("type_de_contrat", { length: 50 }),
  statut: varchar("statut", { length: 50 }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Interlocuteur
const interlocuteurs = pgTable("interlocuteurs", {
  id_interlocuteur: serial("id_interlocuteur").primaryKey(),
  nom_interlocuteur: varchar("nom_interlocuteur", { length: 50 }),
  prenom_interlocuteur: varchar("prenom_interlocuteur", {
    length: 75,
  }),
  contact_interlocuteur: varchar("contact_interlocuteur", {
    length: 50,
  }),
  email_interlocuteur: varchar("email_interlocuteur", { length: 100 }).unique(),
  fonction_interlocuteur: varchar("fonction_interlocuteur", {
    length: 50,
  }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Maintenance
const maintenances = pgTable("maintenances", {
  id_maintenance: serial("id_maintenance").primaryKey(),
  recurrence: varchar("recurrence", { length: 50 }),
  operations: text("operations"),
  recommandations: text("recommandations"),
  type_maintenance: varchar("type_maintenance", { length: 50 }),
  autre_intervenant: varchar("autre_intervenant", { length: 50 }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Livraison
const livraisons = pgTable("livraisons", {
  id_livraison: serial("id_livraison").primaryKey(),
  reference_livraison: varchar("reference_livraison", { length: 75 }),
  frais_divers: decimal("frais_divers", { precision: 10, scale: 2 }),
  periode_achat: varchar("periode_achat", { length: 50 }),
  prix_achat: decimal("prix_achat", { precision: 10, scale: 2 }),
  prix_de_revient: decimal("prix_de_revient", {
    precision: 10,
    scale: 2,
  }),
  prix_de_vente: decimal("prix_de_vente", {
    precision: 10,
    scale: 2,
  }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Intervention
const interventions = pgTable("interventions", {
  id_intervention: serial("id_intervention").primaryKey(),
  date_intervention: date("date_intervention"),
  cause_defaillance: varchar("cause_defaillance", { length: 50 }),
  rapport_intervention: text("rapport_intervention"),
  type_intervention: varchar("type_intervention", { length: 50 }),
  type_defaillance: varchar("type_defaillance", { length: 50 }),
  duree: varchar("duree", { length: 50 }),
  lieu: varchar("lieu", { length: 100 }),
  statut_intervention: varchar("statut_intervention", { length: 50 }),
  recommandation: text("recommandation"),
  probleme_signale: varchar("probleme_signale", { length: 50 }),
  mode_intervention: varchar("mode_intervention", { length: 50 }),
  detail_cause: text("detail_cause"),
  type: varchar("type", { length: 50 }),
  id_partenaire: integer("id_partenaire").references(
    () => partenaires.id_partenaire
  ),
  id_contrat: integer("id_contrat").references(() => contrats.id_contrat),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Documents
const documents = pgTable("documents", {
  id_documents: serial("id_documents").primaryKey(),
  libelle_document: varchar("libelle_document", { length: 100 }),
  classification_document: varchar("classification_document", {
    length: 50,
  }),
  date_document: varchar("date_document", { length: 50 }),
  lien_document: varchar("lien_document", { length: 255 }),
  //etat_document : actif, archive
  etat_document: varchar("etat_document", { length: 50 }).default("Actif"),
  id_livrable: integer("id_livrable").references(() => livrables.id_livrable),
  id_projet: integer("id_projet").references(() => projets.id_projet),
  id_demandes: integer("id_demandes").references(() => demandes.id_demandes),
  id_contrat: integer("id_contrat").references(() => contrats.id_contrat),
  id_employes: integer("id_employes").references(() => employes.id_employes),
  id_intervention: integer("id_intervention").references(
    () => interventions.id_intervention
  ),
  id_nature_document: integer("id_nature_document").references(
    () => nature_documents.id_nature_document
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Exemplaire_produit
const exemplaires = pgTable("exemplaires", {
  id_exemplaire: serial("id_exemplaire").primaryKey(),
  num_serie: varchar("num_serie", { length: 50 }),
  date_entree: date("date_entree"),
  etat_exemplaire: varchar("etat_exemplaire", { length: 75 }).default(
    "Disponible"
  ), //"Vendu", "Disponible", "Utilisation", "En maintenance", "Endommage", "Reserve"
  id_livraison: integer("id_livraison").references(
    () => livraisons.id_livraison
  ),
  id_produit: integer("id_produit").references(() => produits.id_produit), // RÃ©fÃ©rence simplifiÃ©e
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Sortie_exemplaire
const sortie_exemplaires = pgTable("sortie_exemplaires", {
  id_sortie_exemplaire: serial("id_sortie_exemplaire").primaryKey(),
  type_sortie: varchar("type_sortie", { length: 50 }),
  reference_id: integer("reference_id"),
  date_sortie: date("date_sortie"),
  id_exemplaire: integer("id_exemplaire").references(
    () => exemplaires.id_exemplaire
  ),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at").defaultNow().notNull(),
});

// Tables d'association

const partenaire_projets = pgTable(
  "partenaire_projets",
  {
    id_projet: integer("id_projet")
      .notNull()
      .references(() => projets.id_projet),
    id_partenaire: integer("id_partenaire")
      .notNull()
      .references(() => partenaires.id_partenaire),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_projet, table.id_partenaire] }),
  })
);

const intervention_employes = pgTable(
  "intervention_employes",
  {
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    id_intervention: integer("id_intervention")
      .notNull()
      .references(() => interventions.id_intervention),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_employes, table.id_intervention] }),
  })
);

const partenaire_commandes = pgTable(
  "partenaire_commandes",
  {
    id_partenaire: integer("id_partenaire")
      .notNull()
      .references(() => partenaires.id_partenaire),
    id_commande: integer("id_commande")
      .notNull()
      .references(() => commandes.id_commande),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_partenaire, table.id_commande] }),
  })
);

const employe_entrer_exemplaires = pgTable(
  "employe_entrer_exemplaires",
  {
    id_exemplaire: integer("id_exemplaire")
      .notNull()
      .references(() => exemplaires.id_exemplaire),
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    etat_apres: varchar("etat_apres", { length: 50 }).notNull(),
    date_de_retour: date("date_de_retour").notNull(),
    commentaire: text("commentaire"),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_exemplaire, table.id_employes] }),
  })
);

const employe_prestations = pgTable(
  "employe_prestations",
  {
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    id_prestation: integer("id_prestation")
      .notNull()
      .references(() => prestations.id_prestation),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_employes, table.id_prestation] }),
  })
);

const intervention_taches = pgTable(
  "intervention_taches",
  {
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    id_tache: integer("id_tache")
      .notNull()
      .references(() => taches.id_tache),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_employes, table.id_tache] }),
  })
);

const employe_sortir_exemplaires = pgTable(
  "employe_sortir_exemplaires",
  {
    id_exemplaire: integer("id_exemplaire")
      .notNull()
      .references(() => exemplaires.id_exemplaire),
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    but_usage: varchar("but_usage", { length: 50 }).notNull(),
    etat_avant: varchar("etat_avant", { length: 50 }).notNull(),
    date_de_sortie: date("date_de_sortie").notNull(),
    site_intervention: varchar("site_intervention", { length: 100 }).notNull(),
    commentaire: text("commentaire"),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_exemplaire, table.id_employes] }),
  })
);

const maintenance_employes = pgTable(
  "maintenance_employes",
  {
    id_employes: integer("id_employes")
      .notNull()
      .references(() => employes.id_employes),
    id_maintenance: integer("id_maintenance")
      .notNull()
      .references(() => maintenances.id_maintenance),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id_employes, table.id_maintenance] }),
  })
);

const maintenance_moyens_travail = pgTable(
  "maintenance_moyens_travail",
  {
    id_moyens_de_travail: integer("id_moyens_de_travail")
      .notNull()
      .references(() => moyens_de_travail.id_moyens_de_travail),
    id_maintenance: integer("id_maintenance")
      .notNull()
      .references(() => maintenances.id_maintenance),
    date_maintenance: date("date_maintenance"),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({
      columns: [table.id_moyens_de_travail, table.id_maintenance],
    }),
  })
);

const commande_produits = pgTable(
  "commande_produits",
  {
    id_commande: integer("id_commande")
      .notNull()
      .references(() => commandes.id_commande),
    id_produit: integer("id_produit")
      .notNull()
      .references(() => produits.id_produit),
    quantite: integer("quantite"),
    prix_unitaire: decimal("prix_unitaire", { precision: 10, scale: 2 }),
    created_at: timestamp("created_at").defaultNow().notNull(),
    updated_at: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => ({
    pk: primaryKey({
      columns: [table.id_commande, table.id_produit],
    }),
  })
);

module.exports = {
  familles,
  modeles,
  marques,
  fonctions,
  employes,
  demandes,
  nature_documents,
  entites,
  clients_en_ligne,
  refresh_tokens,
  commandes,
  type_produits,
  categories,
  projets,
  taches,
  prestations,
  livrables,
  moyens_de_travail,
  services,
  affiches,
  produits,
  partenaires,
  contrats,
  interlocuteurs,
  maintenances,
  livraisons,
  documents,
  interventions,
  exemplaires,
  sortie_exemplaires,
  partenaire_projets,
  intervention_employes,
  partenaire_commandes,
  employe_entrer_exemplaires,
  employe_prestations,
  intervention_taches,
  employe_sortir_exemplaires,
  maintenance_employes,
  maintenance_moyens_travail,
  commande_produits,
};



================================================
File: core/database/test-db.js
================================================
// test-db.js
const { db } = require('./config');
const { intervention } = require('./models');

(async () => {
  try {
    console.log("Testing database connection...");
    const result = await db.select().from(intervention).limit(1);
    console.log("Success! Found", result.length, "interventions");
  } catch (err) {
    console.error("Database test failed:", err);
  } finally {
    process.exit();
  }
})();


================================================
File: core/database/migrations/0000_cloudy_fat_cobra.sql
================================================
CREATE TABLE "familles" (
	"id_famille" serial PRIMARY KEY NOT NULL,
	"libelle_famille" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "modeles" (
	"id_modele" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "marques" (
	"id_marque" serial PRIMARY KEY NOT NULL,
	"libelle_marque" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "fonctions" (
	"id_fonction" serial PRIMARY KEY NOT NULL,
	"nom_fonction" varchar(50),
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "fonctions_nom_fonction_unique" UNIQUE("nom_fonction")
);
--> statement-breakpoint
CREATE TABLE "employes" (
	"id_employes" serial PRIMARY KEY NOT NULL,
	"keycloak_id" varchar(100),
	"nom_employes" varchar(50),
	"prenom_employes" varchar(75),
	"email_employes" varchar(100),
	"contact_employes" varchar(50),
	"adresse_employes" text,
	"status_employes" varchar(50),
	"date_embauche_employes" date,
	"password_employes" varchar(255),
	"date_de_naissance" date,
	"contrat" varchar(100),
	"id_fonction" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "employes_keycloak_id_unique" UNIQUE("keycloak_id")
);
--> statement-breakpoint
CREATE TABLE "demandes" (
	"id_demandes" serial PRIMARY KEY NOT NULL,
	"date_absence" date,
	"status" varchar(50),
	"date_retour" date,
	"motif" text,
	"type_demande" varchar(50),
	"durÃ©e" varchar(50),
	"heure_debut" time,
	"heure_fin" time,
	"id_employes" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "nature_documents" (
	"id_nature_document" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(50),
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "entites" (
	"id_entite" serial PRIMARY KEY NOT NULL,
	"denomination" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "clients_en_ligne" (
	"id_client" serial PRIMARY KEY NOT NULL,
	"nom_complet" varchar(50) NOT NULL,
	"email" varchar(50) NOT NULL,
	"mot_de_passe" varchar(255) NOT NULL,
	"numero_de_telephone" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "clients_en_ligne_email_unique" UNIQUE("email")
);
--> statement-breakpoint
CREATE TABLE "commandes" (
	"id_commande" serial PRIMARY KEY NOT NULL,
	"date_de_commande" timestamp NOT NULL,
	"etat_commande" varchar(50) NOT NULL,
	"date_livraison" timestamp,
	"lieu_de_livraison" varchar(50) NOT NULL,
	"mode_de_paiement" varchar(50) NOT NULL,
	"id_client" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "type_produits" (
	"id_type_produit" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "categories" (
	"id_categorie" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "projets" (
	"id_projet" serial PRIMARY KEY NOT NULL,
	"nom_projet" varchar(50) NOT NULL,
	"type_projet" varchar(50) NOT NULL,
	"devis_estimatif" numeric(10, 2) NOT NULL,
	"date_debut" date NOT NULL,
	"date_fin" date NOT NULL,
	"duree_prevu_projet" varchar(50) NOT NULL,
	"description_projet" text NOT NULL,
	"etat" varchar(50) NOT NULL,
	"lieu" varchar(50) NOT NULL,
	"responsable" varchar(50) NOT NULL,
	"site" varchar(50) NOT NULL,
	"id_famille" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "taches" (
	"id_tache" serial PRIMARY KEY NOT NULL,
	"nom_tache" varchar(50) NOT NULL,
	"desc_tache" text NOT NULL,
	"statut" varchar(50) NOT NULL,
	"date_debut" timestamp NOT NULL,
	"date_fin" timestamp,
	"priorite" varchar(50) NOT NULL,
	"id_projet" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "prestations" (
	"id_prestation" serial PRIMARY KEY NOT NULL,
	"date_de_maintenance" timestamp NOT NULL,
	"type_de_maintenance" varchar(50) NOT NULL,
	"description" text NOT NULL,
	"responsable" varchar(50) NOT NULL,
	"pieces_remplacees" text NOT NULL,
	"cout_maintenance" numeric(10, 2) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "livrables" (
	"id_livrable" serial PRIMARY KEY NOT NULL,
	"date" date NOT NULL,
	"realisations" text NOT NULL,
	"reserves" text,
	"approbation" boolean NOT NULL,
	"recommandation" text,
	"id_projet" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "moyens_de_travail" (
	"id_moyens_de_travail" serial PRIMARY KEY NOT NULL,
	"denomination" varchar(50) NOT NULL,
	"date_acquisition" date NOT NULL,
	"section" varchar(50) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "services" (
	"id_service" serial PRIMARY KEY NOT NULL,
	"titre_service" varchar(50) NOT NULL,
	"image" varchar(255) NOT NULL,
	"description" text NOT NULL,
	"id_employes" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "affiches" (
	"id_affiche" serial PRIMARY KEY NOT NULL,
	"image" varchar(255) NOT NULL,
	"titre" varchar(50) NOT NULL,
	"description" text NOT NULL,
	"id_employes" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "produits" (
	"id_produit" serial PRIMARY KEY NOT NULL,
	"code_produit" varchar(100) NOT NULL,
	"desi_produit" varchar(50) NOT NULL,
	"desc_produit" text NOT NULL,
	"image_produit" varchar(255) NOT NULL,
	"qte_produit" integer NOT NULL,
	"emplacement" varchar(50) NOT NULL,
	"id_categorie" integer NOT NULL,
	"id_type_produit" integer NOT NULL,
	"id_modele" integer NOT NULL,
	"id_famille" integer NOT NULL,
	"id_marque" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "produits_code_produit_unique" UNIQUE("code_produit")
);
--> statement-breakpoint
CREATE TABLE "partenaires" (
	"id_partenaire" serial PRIMARY KEY NOT NULL,
	"nom_partenaire" varchar(50) NOT NULL,
	"telephone_partenaire" varchar(50) NOT NULL,
	"email_partenaire" varchar(100) NOT NULL,
	"specialite" varchar(50) NOT NULL,
	"localisation" varchar(50) NOT NULL,
	"type_partenaire" varchar(50) NOT NULL,
	"statut" varchar(50) NOT NULL,
	"id_entite" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "partenaires_email_partenaire_unique" UNIQUE("email_partenaire")
);
--> statement-breakpoint
CREATE TABLE "contrats" (
	"id_contrat" serial PRIMARY KEY NOT NULL,
	"nom_contrat" varchar(50) NOT NULL,
	"duree_contrat" varchar(50) NOT NULL,
	"date_debut" date NOT NULL,
	"date_fin" date NOT NULL,
	"reference" varchar(50) NOT NULL,
	"type_de_contrat" varchar(50) NOT NULL,
	"statut" varchar(50) NOT NULL,
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "interlocuteurs" (
	"id_interlocuteur" serial PRIMARY KEY NOT NULL,
	"nom_interlocuteur" varchar(50) NOT NULL,
	"prenom_interlocuteur" varchar(75) NOT NULL,
	"contact_interlocuteur" varchar(50) NOT NULL,
	"email_interlocuteur" varchar(100) NOT NULL,
	"fonction_interlocuteur" varchar(50) NOT NULL,
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "interlocuteurs_email_interlocuteur_unique" UNIQUE("email_interlocuteur")
);
--> statement-breakpoint
CREATE TABLE "maintenances" (
	"id_maintenance" serial PRIMARY KEY NOT NULL,
	"recurrence" varchar(50) NOT NULL,
	"operations" text NOT NULL,
	"recommandations" text NOT NULL,
	"type_maintenance" varchar(50) NOT NULL,
	"autre_intervenant" varchar(50),
	"id_partenaire" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "livraisons" (
	"id_livraison" serial PRIMARY KEY NOT NULL,
	"frais_divers" numeric(10, 2),
	"periode_achat" varchar(50),
	"prix_achat" numeric(10, 2),
	"prix_de_revient" numeric(10, 2),
	"prix_de_vente" numeric(10, 2),
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "documents" (
	"id_documents" serial PRIMARY KEY NOT NULL,
	"libelle_document" varchar(100) NOT NULL,
	"classification_document" varchar(50) NOT NULL,
	"lien_document" varchar(255) NOT NULL,
	"etat_document" varchar(50) NOT NULL,
	"id_livrable" integer,
	"id_projet" integer,
	"id_demandes" integer,
	"id_contrat" integer,
	"id_employes" integer,
	"id_nature_document" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "interventions" (
	"id_intervention" serial PRIMARY KEY NOT NULL,
	"date_" timestamp NOT NULL,
	"cause_defaillance" varchar(50) NOT NULL,
	"rapport_intervention" text NOT NULL,
	"type_intervention" varchar(50) NOT NULL,
	"type_defaillance" varchar(50) NOT NULL,
	"duree" varchar(50) NOT NULL,
	"lieu" varchar(100) NOT NULL,
	"statut_intervention" varchar(50) NOT NULL,
	"recommandation" text NOT NULL,
	"probleme_signale" varchar(50) NOT NULL,
	"mode_intervention" varchar(50) NOT NULL,
	"detail_cause" text NOT NULL,
	"type" varchar(50) NOT NULL,
	"id_partenaire" integer NOT NULL,
	"id_contrat" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "exemplaires" (
	"id_exemplaire" serial PRIMARY KEY NOT NULL,
	"num_serie" varchar(50) NOT NULL,
	"prix_exemplaire" numeric(10, 2) NOT NULL,
	"date_entree" date NOT NULL,
	"etat_vente" boolean NOT NULL,
	"id_commande" integer,
	"id_livraison" integer NOT NULL,
	"id_produit" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "sortie_exemplaires" (
	"id_sortie_exemplaire" serial PRIMARY KEY NOT NULL,
	"type_sortie" varchar(50) NOT NULL,
	"reference_id" integer,
	"date_sortie" timestamp NOT NULL,
	"id_exemplaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "collaborer" (
	"id_projet" integer NOT NULL,
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "collaborer_id_projet_id_partenaire_pk" PRIMARY KEY("id_projet","id_partenaire")
);
--> statement-breakpoint
CREATE TABLE "intervention_employes" (
	"id_employes" integer NOT NULL,
	"id_intervention" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "intervention_employes_id_employes_id_intervention_pk" PRIMARY KEY("id_employes","id_intervention")
);
--> statement-breakpoint
CREATE TABLE "partenaire_commandes" (
	"id_partenaire" integer NOT NULL,
	"id_commande" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "partenaire_commandes_id_partenaire_id_commande_pk" PRIMARY KEY("id_partenaire","id_commande")
);
--> statement-breakpoint
CREATE TABLE "faire_entrer" (
	"id_exemplaire" integer NOT NULL,
	"id_employes" integer NOT NULL,
	"etat_apres" varchar(50) NOT NULL,
	"date_de_retour" timestamp NOT NULL,
	"commentaire" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "faire_entrer_id_exemplaire_id_employes_pk" PRIMARY KEY("id_exemplaire","id_employes")
);
--> statement-breakpoint
CREATE TABLE "effectuer" (
	"id_employes" integer NOT NULL,
	"id_prestation" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "effectuer_id_employes_id_prestation_pk" PRIMARY KEY("id_employes","id_prestation")
);
--> statement-breakpoint
CREATE TABLE "intervention_taches" (
	"id_employes" integer NOT NULL,
	"id_tache" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "intervention_taches_id_employes_id_tache_pk" PRIMARY KEY("id_employes","id_tache")
);
--> statement-breakpoint
CREATE TABLE "faire_sortir" (
	"id_exemplaire" integer NOT NULL,
	"id_employes" integer NOT NULL,
	"but_usage" varchar(50) NOT NULL,
	"etat_avant" varchar(50) NOT NULL,
	"date_de_sortie" timestamp NOT NULL,
	"site_intervention" varchar(100) NOT NULL,
	"commentaire" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "faire_sortir_id_exemplaire_id_employes_pk" PRIMARY KEY("id_exemplaire","id_employes")
);
--> statement-breakpoint
CREATE TABLE "maintenance_employes" (
	"id_employes" integer NOT NULL,
	"id_maintenance" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "maintenance_employes_id_employes_id_maintenance_pk" PRIMARY KEY("id_employes","id_maintenance")
);
--> statement-breakpoint
CREATE TABLE "maintenance_moyens_travail" (
	"id_moyens_de_travail" integer NOT NULL,
	"id_maintenance" integer NOT NULL,
	"date_maintenance" timestamp NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk" PRIMARY KEY("id_moyens_de_travail","id_maintenance")
);
--> statement-breakpoint
ALTER TABLE "employes" ADD CONSTRAINT "employes_id_fonction_fonctions_id_fonction_fk" FOREIGN KEY ("id_fonction") REFERENCES "public"."fonctions"("id_fonction") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "demandes" ADD CONSTRAINT "demandes_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "commandes" ADD CONSTRAINT "commandes_id_client_clients_en_ligne_id_client_fk" FOREIGN KEY ("id_client") REFERENCES "public"."clients_en_ligne"("id_client") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "projets" ADD CONSTRAINT "projets_id_famille_familles_id_famille_fk" FOREIGN KEY ("id_famille") REFERENCES "public"."familles"("id_famille") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "taches" ADD CONSTRAINT "taches_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "livrables" ADD CONSTRAINT "livrables_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "services" ADD CONSTRAINT "services_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "affiches" ADD CONSTRAINT "affiches_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_categorie_categories_id_categorie_fk" FOREIGN KEY ("id_categorie") REFERENCES "public"."categories"("id_categorie") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_type_produit_type_produits_id_type_produit_fk" FOREIGN KEY ("id_type_produit") REFERENCES "public"."type_produits"("id_type_produit") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_modele_modeles_id_modele_fk" FOREIGN KEY ("id_modele") REFERENCES "public"."modeles"("id_modele") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_famille_familles_id_famille_fk" FOREIGN KEY ("id_famille") REFERENCES "public"."familles"("id_famille") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produits" ADD CONSTRAINT "produits_id_marque_marques_id_marque_fk" FOREIGN KEY ("id_marque") REFERENCES "public"."marques"("id_marque") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "partenaires" ADD CONSTRAINT "partenaires_id_entite_entites_id_entite_fk" FOREIGN KEY ("id_entite") REFERENCES "public"."entites"("id_entite") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "contrats" ADD CONSTRAINT "contrats_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "interlocuteurs" ADD CONSTRAINT "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenances" ADD CONSTRAINT "maintenances_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "livraisons" ADD CONSTRAINT "livraisons_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_livrable_livrables_id_livrable_fk" FOREIGN KEY ("id_livrable") REFERENCES "public"."livrables"("id_livrable") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_demandes_demandes_id_demandes_fk" FOREIGN KEY ("id_demandes") REFERENCES "public"."demandes"("id_demandes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_contrat_contrats_id_contrat_fk" FOREIGN KEY ("id_contrat") REFERENCES "public"."contrats"("id_contrat") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_nature_document_nature_documents_id_nature_document_fk" FOREIGN KEY ("id_nature_document") REFERENCES "public"."nature_documents"("id_nature_document") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "interventions" ADD CONSTRAINT "interventions_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "interventions" ADD CONSTRAINT "interventions_id_contrat_contrats_id_contrat_fk" FOREIGN KEY ("id_contrat") REFERENCES "public"."contrats"("id_contrat") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaires" ADD CONSTRAINT "exemplaires_id_commande_commandes_id_commande_fk" FOREIGN KEY ("id_commande") REFERENCES "public"."commandes"("id_commande") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaires" ADD CONSTRAINT "exemplaires_id_livraison_livraisons_id_livraison_fk" FOREIGN KEY ("id_livraison") REFERENCES "public"."livraisons"("id_livraison") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaires" ADD CONSTRAINT "exemplaires_id_produit_produits_id_produit_fk" FOREIGN KEY ("id_produit") REFERENCES "public"."produits"("id_produit") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sortie_exemplaires" ADD CONSTRAINT "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk" FOREIGN KEY ("id_exemplaire") REFERENCES "public"."exemplaires"("id_exemplaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "collaborer" ADD CONSTRAINT "collaborer_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "collaborer" ADD CONSTRAINT "collaborer_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention_employes" ADD CONSTRAINT "intervention_employes_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention_employes" ADD CONSTRAINT "intervention_employes_id_intervention_interventions_id_intervention_fk" FOREIGN KEY ("id_intervention") REFERENCES "public"."interventions"("id_intervention") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "partenaire_commandes" ADD CONSTRAINT "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "partenaire_commandes" ADD CONSTRAINT "partenaire_commandes_id_commande_commandes_id_commande_fk" FOREIGN KEY ("id_commande") REFERENCES "public"."commandes"("id_commande") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "faire_entrer" ADD CONSTRAINT "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk" FOREIGN KEY ("id_exemplaire") REFERENCES "public"."exemplaires"("id_exemplaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "faire_entrer" ADD CONSTRAINT "faire_entrer_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "effectuer" ADD CONSTRAINT "effectuer_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "effectuer" ADD CONSTRAINT "effectuer_id_prestation_prestations_id_prestation_fk" FOREIGN KEY ("id_prestation") REFERENCES "public"."prestations"("id_prestation") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention_taches" ADD CONSTRAINT "intervention_taches_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention_taches" ADD CONSTRAINT "intervention_taches_id_tache_taches_id_tache_fk" FOREIGN KEY ("id_tache") REFERENCES "public"."taches"("id_tache") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "faire_sortir" ADD CONSTRAINT "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk" FOREIGN KEY ("id_exemplaire") REFERENCES "public"."exemplaires"("id_exemplaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "faire_sortir" ADD CONSTRAINT "faire_sortir_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenance_employes" ADD CONSTRAINT "maintenance_employes_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenance_employes" ADD CONSTRAINT "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk" FOREIGN KEY ("id_maintenance") REFERENCES "public"."maintenances"("id_maintenance") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenance_moyens_travail" ADD CONSTRAINT "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk" FOREIGN KEY ("id_moyens_de_travail") REFERENCES "public"."moyens_de_travail"("id_moyens_de_travail") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "maintenance_moyens_travail" ADD CONSTRAINT "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk" FOREIGN KEY ("id_maintenance") REFERENCES "public"."maintenances"("id_maintenance") ON DELETE no action ON UPDATE no action;


================================================
File: core/database/migrations/0001_worthless_venus.sql
================================================
ALTER TABLE "exemplaires" ADD COLUMN "etat_exemplaire" varchar(75) NOT NULL;--> statement-breakpoint
ALTER TABLE "exemplaires" DROP COLUMN "etat_vente";


================================================
File: core/database/migrations/0002_previous_wasp.sql
================================================
CREATE TABLE "partenaire_projets" (
	"id_projet" integer NOT NULL,
	"id_partenaire" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "partenaire_projets_id_projet_id_partenaire_pk" PRIMARY KEY("id_projet","id_partenaire")
);
--> statement-breakpoint
CREATE TABLE "employe_entrer_exemplaires" (
	"id_exemplaire" integer NOT NULL,
	"id_employes" integer NOT NULL,
	"etat_apres" varchar(50) NOT NULL,
	"date_de_retour" date NOT NULL,
	"commentaire" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "employe_entrer_exemplaires_id_exemplaire_id_employes_pk" PRIMARY KEY("id_exemplaire","id_employes")
);
--> statement-breakpoint
CREATE TABLE "employe_prestations" (
	"id_employes" integer NOT NULL,
	"id_prestation" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "employe_prestations_id_employes_id_prestation_pk" PRIMARY KEY("id_employes","id_prestation")
);
--> statement-breakpoint
CREATE TABLE "employe_sortir_exemplaires" (
	"id_exemplaire" integer NOT NULL,
	"id_employes" integer NOT NULL,
	"but_usage" varchar(50) NOT NULL,
	"etat_avant" varchar(50) NOT NULL,
	"date_de_sortie" date NOT NULL,
	"site_intervention" varchar(100) NOT NULL,
	"commentaire" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "employe_sortir_exemplaires_id_exemplaire_id_employes_pk" PRIMARY KEY("id_exemplaire","id_employes")
);
--> statement-breakpoint
CREATE TABLE "commande_produits" (
	"id_commande" integer NOT NULL,
	"id_produit" integer NOT NULL,
	"quantite" integer,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "commande_produits_id_commande_id_produit_pk" PRIMARY KEY("id_commande","id_produit")
);
--> statement-breakpoint
ALTER TABLE "collaborer" DISABLE ROW LEVEL SECURITY;--> statement-breakpoint
ALTER TABLE "faire_entrer" DISABLE ROW LEVEL SECURITY;--> statement-breakpoint
ALTER TABLE "effectuer" DISABLE ROW LEVEL SECURITY;--> statement-breakpoint
ALTER TABLE "faire_sortir" DISABLE ROW LEVEL SECURITY;--> statement-breakpoint
DROP TABLE "collaborer" CASCADE;--> statement-breakpoint
DROP TABLE "faire_entrer" CASCADE;--> statement-breakpoint
DROP TABLE "effectuer" CASCADE;--> statement-breakpoint
DROP TABLE "faire_sortir" CASCADE;--> statement-breakpoint
ALTER TABLE "exemplaires" DROP CONSTRAINT "exemplaires_id_commande_commandes_id_commande_fk";
--> statement-breakpoint
ALTER TABLE "familles" ALTER COLUMN "libelle_famille" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "marques" ALTER COLUMN "libelle_marque" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "employes" ALTER COLUMN "id_fonction" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "demandes" ALTER COLUMN "id_employes" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "entites" ALTER COLUMN "denomination" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "clients_en_ligne" ALTER COLUMN "nom_complet" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "clients_en_ligne" ALTER COLUMN "email" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "clients_en_ligne" ALTER COLUMN "mot_de_passe" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "clients_en_ligne" ALTER COLUMN "numero_de_telephone" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "commandes" ALTER COLUMN "date_de_commande" SET DATA TYPE date;--> statement-breakpoint
ALTER TABLE "commandes" ALTER COLUMN "date_de_commande" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "commandes" ALTER COLUMN "etat_commande" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "commandes" ALTER COLUMN "date_livraison" SET DATA TYPE date;--> statement-breakpoint
ALTER TABLE "commandes" ALTER COLUMN "lieu_de_livraison" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "commandes" ALTER COLUMN "mode_de_paiement" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "type_produits" ALTER COLUMN "libelle" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "categories" ALTER COLUMN "libelle" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "devis_estimatif" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "date_debut" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "date_fin" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "duree_prevu_projet" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "description_projet" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "etat" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "lieu" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "responsable" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "site" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "projets" ALTER COLUMN "id_famille" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "taches" ALTER COLUMN "nom_tache" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "taches" ALTER COLUMN "desc_tache" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "taches" ALTER COLUMN "statut" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "taches" ALTER COLUMN "date_debut" SET DATA TYPE date;--> statement-breakpoint
ALTER TABLE "taches" ALTER COLUMN "date_debut" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "taches" ALTER COLUMN "date_fin" SET DATA TYPE date;--> statement-breakpoint
ALTER TABLE "taches" ALTER COLUMN "priorite" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "taches" ALTER COLUMN "id_projet" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "prestations" ALTER COLUMN "date_de_maintenance" SET DATA TYPE date;--> statement-breakpoint
ALTER TABLE "prestations" ALTER COLUMN "date_de_maintenance" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "prestations" ALTER COLUMN "type_de_maintenance" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "prestations" ALTER COLUMN "description" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "prestations" ALTER COLUMN "responsable" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "prestations" ALTER COLUMN "pieces_remplacees" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "prestations" ALTER COLUMN "cout_maintenance" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "livrables" ALTER COLUMN "date" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "livrables" ALTER COLUMN "realisations" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "livrables" ALTER COLUMN "approbation" SET DATA TYPE text;--> statement-breakpoint
ALTER TABLE "livrables" ALTER COLUMN "approbation" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "moyens_de_travail" ALTER COLUMN "denomination" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "moyens_de_travail" ALTER COLUMN "date_acquisition" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "moyens_de_travail" ALTER COLUMN "section" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "services" ALTER COLUMN "titre_service" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "services" ALTER COLUMN "image" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "services" ALTER COLUMN "description" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "services" ALTER COLUMN "id_employes" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "affiches" ALTER COLUMN "image" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "affiches" ALTER COLUMN "titre" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "affiches" ALTER COLUMN "description" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "affiches" ALTER COLUMN "id_employes" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "code_produit" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "desi_produit" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "desc_produit" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "image_produit" SET DATA TYPE text;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "image_produit" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "qte_produit" SET DEFAULT 0;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "qte_produit" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "emplacement" SET DATA TYPE text;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "emplacement" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "id_categorie" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "id_type_produit" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "id_modele" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "id_famille" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "produits" ALTER COLUMN "id_marque" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "partenaires" ALTER COLUMN "nom_partenaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "partenaires" ALTER COLUMN "telephone_partenaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "partenaires" ALTER COLUMN "email_partenaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "partenaires" ALTER COLUMN "specialite" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "partenaires" ALTER COLUMN "localisation" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "partenaires" ALTER COLUMN "type_partenaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "partenaires" ALTER COLUMN "statut" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "partenaires" ALTER COLUMN "id_entite" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "contrats" ALTER COLUMN "nom_contrat" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "contrats" ALTER COLUMN "duree_contrat" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "contrats" ALTER COLUMN "date_debut" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "contrats" ALTER COLUMN "date_fin" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "contrats" ALTER COLUMN "reference" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "contrats" ALTER COLUMN "type_de_contrat" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "contrats" ALTER COLUMN "statut" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "contrats" ALTER COLUMN "id_partenaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interlocuteurs" ALTER COLUMN "nom_interlocuteur" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interlocuteurs" ALTER COLUMN "prenom_interlocuteur" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interlocuteurs" ALTER COLUMN "contact_interlocuteur" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interlocuteurs" ALTER COLUMN "email_interlocuteur" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interlocuteurs" ALTER COLUMN "fonction_interlocuteur" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interlocuteurs" ALTER COLUMN "id_partenaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "maintenances" ALTER COLUMN "recurrence" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "maintenances" ALTER COLUMN "operations" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "maintenances" ALTER COLUMN "recommandations" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "maintenances" ALTER COLUMN "type_maintenance" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "livraisons" ALTER COLUMN "id_partenaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "documents" ALTER COLUMN "libelle_document" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "documents" ALTER COLUMN "classification_document" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "documents" ALTER COLUMN "lien_document" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "documents" ALTER COLUMN "etat_document" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "documents" ALTER COLUMN "id_nature_document" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "cause_defaillance" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "rapport_intervention" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "type_intervention" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "type_defaillance" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "duree" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "lieu" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "statut_intervention" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "recommandation" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "probleme_signale" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "mode_intervention" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "detail_cause" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "type" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "interventions" ALTER COLUMN "id_partenaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "exemplaires" ALTER COLUMN "num_serie" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "exemplaires" ALTER COLUMN "date_entree" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "exemplaires" ALTER COLUMN "etat_exemplaire" SET DEFAULT 'Disponible';--> statement-breakpoint
ALTER TABLE "exemplaires" ALTER COLUMN "etat_exemplaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "exemplaires" ALTER COLUMN "id_livraison" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "exemplaires" ALTER COLUMN "id_produit" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "sortie_exemplaires" ALTER COLUMN "type_sortie" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "sortie_exemplaires" ALTER COLUMN "date_sortie" SET DATA TYPE date;--> statement-breakpoint
ALTER TABLE "sortie_exemplaires" ALTER COLUMN "date_sortie" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "sortie_exemplaires" ALTER COLUMN "id_exemplaire" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "maintenance_moyens_travail" ALTER COLUMN "date_maintenance" SET DATA TYPE date;--> statement-breakpoint
ALTER TABLE "maintenance_moyens_travail" ALTER COLUMN "date_maintenance" DROP NOT NULL;--> statement-breakpoint
ALTER TABLE "modeles" ADD COLUMN "libelle_modele" varchar(50);--> statement-breakpoint
ALTER TABLE "livrables" ADD COLUMN "libelle_livrable" varchar(100);--> statement-breakpoint
ALTER TABLE "produits" ADD COLUMN "caracteristiques" text;--> statement-breakpoint
ALTER TABLE "produits" ADD COLUMN "prix_produit" numeric(10, 2);--> statement-breakpoint
ALTER TABLE "livraisons" ADD COLUMN "reference_livraison" varchar(75);--> statement-breakpoint
ALTER TABLE "documents" ADD COLUMN "date_document" varchar(50);--> statement-breakpoint
ALTER TABLE "documents" ADD COLUMN "id_intervention" integer;--> statement-breakpoint
ALTER TABLE "interventions" ADD COLUMN "date_intervention" date;--> statement-breakpoint
ALTER TABLE "partenaire_projets" ADD CONSTRAINT "partenaire_projets_id_projet_projets_id_projet_fk" FOREIGN KEY ("id_projet") REFERENCES "public"."projets"("id_projet") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "partenaire_projets" ADD CONSTRAINT "partenaire_projets_id_partenaire_partenaires_id_partenaire_fk" FOREIGN KEY ("id_partenaire") REFERENCES "public"."partenaires"("id_partenaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "employe_entrer_exemplaires" ADD CONSTRAINT "employe_entrer_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk" FOREIGN KEY ("id_exemplaire") REFERENCES "public"."exemplaires"("id_exemplaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "employe_entrer_exemplaires" ADD CONSTRAINT "employe_entrer_exemplaires_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "employe_prestations" ADD CONSTRAINT "employe_prestations_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "employe_prestations" ADD CONSTRAINT "employe_prestations_id_prestation_prestations_id_prestation_fk" FOREIGN KEY ("id_prestation") REFERENCES "public"."prestations"("id_prestation") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "employe_sortir_exemplaires" ADD CONSTRAINT "employe_sortir_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk" FOREIGN KEY ("id_exemplaire") REFERENCES "public"."exemplaires"("id_exemplaire") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "employe_sortir_exemplaires" ADD CONSTRAINT "employe_sortir_exemplaires_id_employes_employes_id_employes_fk" FOREIGN KEY ("id_employes") REFERENCES "public"."employes"("id_employes") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "commande_produits" ADD CONSTRAINT "commande_produits_id_commande_commandes_id_commande_fk" FOREIGN KEY ("id_commande") REFERENCES "public"."commandes"("id_commande") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "commande_produits" ADD CONSTRAINT "commande_produits_id_produit_produits_id_produit_fk" FOREIGN KEY ("id_produit") REFERENCES "public"."produits"("id_produit") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_id_intervention_interventions_id_intervention_fk" FOREIGN KEY ("id_intervention") REFERENCES "public"."interventions"("id_intervention") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "modeles" DROP COLUMN "libelle";--> statement-breakpoint
ALTER TABLE "interventions" DROP COLUMN "date_";--> statement-breakpoint
ALTER TABLE "exemplaires" DROP COLUMN "prix_exemplaire";--> statement-breakpoint
ALTER TABLE "exemplaires" DROP COLUMN "id_commande";


================================================
File: core/database/migrations/meta/0000_snapshot.json
================================================
{
  "id": "32e964f9-448d-4e96-b687-83b35d419eff",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.familles": {
      "name": "familles",
      "schema": "",
      "columns": {
        "id_famille": {
          "name": "id_famille",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_famille": {
          "name": "libelle_famille",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.modeles": {
      "name": "modeles",
      "schema": "",
      "columns": {
        "id_modele": {
          "name": "id_modele",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.marques": {
      "name": "marques",
      "schema": "",
      "columns": {
        "id_marque": {
          "name": "id_marque",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_marque": {
          "name": "libelle_marque",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.fonctions": {
      "name": "fonctions",
      "schema": "",
      "columns": {
        "id_fonction": {
          "name": "id_fonction",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_fonction": {
          "name": "nom_fonction",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "fonctions_nom_fonction_unique": {
          "name": "fonctions_nom_fonction_unique",
          "nullsNotDistinct": false,
          "columns": [
            "nom_fonction"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employes": {
      "name": "employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "keycloak_id": {
          "name": "keycloak_id",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "nom_employes": {
          "name": "nom_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prenom_employes": {
          "name": "prenom_employes",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": false
        },
        "email_employes": {
          "name": "email_employes",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "contact_employes": {
          "name": "contact_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "adresse_employes": {
          "name": "adresse_employes",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status_employes": {
          "name": "status_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_embauche_employes": {
          "name": "date_embauche_employes",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "password_employes": {
          "name": "password_employes",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "date_de_naissance": {
          "name": "date_de_naissance",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "contrat": {
          "name": "contrat",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "id_fonction": {
          "name": "id_fonction",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employes_id_fonction_fonctions_id_fonction_fk": {
          "name": "employes_id_fonction_fonctions_id_fonction_fk",
          "tableFrom": "employes",
          "tableTo": "fonctions",
          "columnsFrom": [
            "id_fonction"
          ],
          "columnsTo": [
            "id_fonction"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "employes_keycloak_id_unique": {
          "name": "employes_keycloak_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "keycloak_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.demandes": {
      "name": "demandes",
      "schema": "",
      "columns": {
        "id_demandes": {
          "name": "id_demandes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_absence": {
          "name": "date_absence",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_retour": {
          "name": "date_retour",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "motif": {
          "name": "motif",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type_demande": {
          "name": "type_demande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "durÃ©e": {
          "name": "durÃ©e",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "heure_debut": {
          "name": "heure_debut",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "heure_fin": {
          "name": "heure_fin",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "demandes_id_employes_employes_id_employes_fk": {
          "name": "demandes_id_employes_employes_id_employes_fk",
          "tableFrom": "demandes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.nature_documents": {
      "name": "nature_documents",
      "schema": "",
      "columns": {
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.entites": {
      "name": "entites",
      "schema": "",
      "columns": {
        "id_entite": {
          "name": "id_entite",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.clients_en_ligne": {
      "name": "clients_en_ligne",
      "schema": "",
      "columns": {
        "id_client": {
          "name": "id_client",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_complet": {
          "name": "nom_complet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mot_de_passe": {
          "name": "mot_de_passe",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "numero_de_telephone": {
          "name": "numero_de_telephone",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "clients_en_ligne_email_unique": {
          "name": "clients_en_ligne_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.commandes": {
      "name": "commandes",
      "schema": "",
      "columns": {
        "id_commande": {
          "name": "id_commande",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_commande": {
          "name": "date_de_commande",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "etat_commande": {
          "name": "etat_commande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_livraison": {
          "name": "date_livraison",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "lieu_de_livraison": {
          "name": "lieu_de_livraison",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mode_de_paiement": {
          "name": "mode_de_paiement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_client": {
          "name": "id_client",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "commandes_id_client_clients_en_ligne_id_client_fk": {
          "name": "commandes_id_client_clients_en_ligne_id_client_fk",
          "tableFrom": "commandes",
          "tableTo": "clients_en_ligne",
          "columnsFrom": [
            "id_client"
          ],
          "columnsTo": [
            "id_client"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.type_produits": {
      "name": "type_produits",
      "schema": "",
      "columns": {
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.categories": {
      "name": "categories",
      "schema": "",
      "columns": {
        "id_categorie": {
          "name": "id_categorie",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.projets": {
      "name": "projets",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_projet": {
          "name": "nom_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_projet": {
          "name": "type_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "devis_estimatif": {
          "name": "devis_estimatif",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "duree_prevu_projet": {
          "name": "duree_prevu_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description_projet": {
          "name": "description_projet",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "etat": {
          "name": "etat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "site": {
          "name": "site",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "projets_id_famille_familles_id_famille_fk": {
          "name": "projets_id_famille_familles_id_famille_fk",
          "tableFrom": "projets",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.taches": {
      "name": "taches",
      "schema": "",
      "columns": {
        "id_tache": {
          "name": "id_tache",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_tache": {
          "name": "nom_tache",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "desc_tache": {
          "name": "desc_tache",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "priorite": {
          "name": "priorite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "taches_id_projet_projets_id_projet_fk": {
          "name": "taches_id_projet_projets_id_projet_fk",
          "tableFrom": "taches",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.prestations": {
      "name": "prestations",
      "schema": "",
      "columns": {
        "id_prestation": {
          "name": "id_prestation",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_maintenance": {
          "name": "date_de_maintenance",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "type_de_maintenance": {
          "name": "type_de_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "pieces_remplacees": {
          "name": "pieces_remplacees",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "cout_maintenance": {
          "name": "cout_maintenance",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livrables": {
      "name": "livrables",
      "schema": "",
      "columns": {
        "id_livrable": {
          "name": "id_livrable",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "realisations": {
          "name": "realisations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "reserves": {
          "name": "reserves",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "approbation": {
          "name": "approbation",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livrables_id_projet_projets_id_projet_fk": {
          "name": "livrables_id_projet_projets_id_projet_fk",
          "tableFrom": "livrables",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.moyens_de_travail": {
      "name": "moyens_de_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_acquisition": {
          "name": "date_acquisition",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "section": {
          "name": "section",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.services": {
      "name": "services",
      "schema": "",
      "columns": {
        "id_service": {
          "name": "id_service",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "titre_service": {
          "name": "titre_service",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "services_id_employes_employes_id_employes_fk": {
          "name": "services_id_employes_employes_id_employes_fk",
          "tableFrom": "services",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.affiches": {
      "name": "affiches",
      "schema": "",
      "columns": {
        "id_affiche": {
          "name": "id_affiche",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "titre": {
          "name": "titre",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "affiches_id_employes_employes_id_employes_fk": {
          "name": "affiches_id_employes_employes_id_employes_fk",
          "tableFrom": "affiches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.produits": {
      "name": "produits",
      "schema": "",
      "columns": {
        "id_produit": {
          "name": "id_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "code_produit": {
          "name": "code_produit",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "desi_produit": {
          "name": "desi_produit",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "desc_produit": {
          "name": "desc_produit",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "image_produit": {
          "name": "image_produit",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "qte_produit": {
          "name": "qte_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "emplacement": {
          "name": "emplacement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_categorie": {
          "name": "id_categorie",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_modele": {
          "name": "id_modele",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_marque": {
          "name": "id_marque",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "produits_id_categorie_categories_id_categorie_fk": {
          "name": "produits_id_categorie_categories_id_categorie_fk",
          "tableFrom": "produits",
          "tableTo": "categories",
          "columnsFrom": [
            "id_categorie"
          ],
          "columnsTo": [
            "id_categorie"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_type_produit_type_produits_id_type_produit_fk": {
          "name": "produits_id_type_produit_type_produits_id_type_produit_fk",
          "tableFrom": "produits",
          "tableTo": "type_produits",
          "columnsFrom": [
            "id_type_produit"
          ],
          "columnsTo": [
            "id_type_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_modele_modeles_id_modele_fk": {
          "name": "produits_id_modele_modeles_id_modele_fk",
          "tableFrom": "produits",
          "tableTo": "modeles",
          "columnsFrom": [
            "id_modele"
          ],
          "columnsTo": [
            "id_modele"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_famille_familles_id_famille_fk": {
          "name": "produits_id_famille_familles_id_famille_fk",
          "tableFrom": "produits",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_marque_marques_id_marque_fk": {
          "name": "produits_id_marque_marques_id_marque_fk",
          "tableFrom": "produits",
          "tableTo": "marques",
          "columnsFrom": [
            "id_marque"
          ],
          "columnsTo": [
            "id_marque"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "produits_code_produit_unique": {
          "name": "produits_code_produit_unique",
          "nullsNotDistinct": false,
          "columns": [
            "code_produit"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaires": {
      "name": "partenaires",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_partenaire": {
          "name": "nom_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "telephone_partenaire": {
          "name": "telephone_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email_partenaire": {
          "name": "email_partenaire",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "specialite": {
          "name": "specialite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "localisation": {
          "name": "localisation",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_partenaire": {
          "name": "type_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_entite": {
          "name": "id_entite",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaires_id_entite_entites_id_entite_fk": {
          "name": "partenaires_id_entite_entites_id_entite_fk",
          "tableFrom": "partenaires",
          "tableTo": "entites",
          "columnsFrom": [
            "id_entite"
          ],
          "columnsTo": [
            "id_entite"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "partenaires_email_partenaire_unique": {
          "name": "partenaires_email_partenaire_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_partenaire"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contrats": {
      "name": "contrats",
      "schema": "",
      "columns": {
        "id_contrat": {
          "name": "id_contrat",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_contrat": {
          "name": "nom_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "duree_contrat": {
          "name": "duree_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "reference": {
          "name": "reference",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_de_contrat": {
          "name": "type_de_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contrats_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "contrats_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "contrats",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interlocuteurs": {
      "name": "interlocuteurs",
      "schema": "",
      "columns": {
        "id_interlocuteur": {
          "name": "id_interlocuteur",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_interlocuteur": {
          "name": "nom_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "prenom_interlocuteur": {
          "name": "prenom_interlocuteur",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": true
        },
        "contact_interlocuteur": {
          "name": "contact_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email_interlocuteur": {
          "name": "email_interlocuteur",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "fonction_interlocuteur": {
          "name": "fonction_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interlocuteurs",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "interlocuteurs_email_interlocuteur_unique": {
          "name": "interlocuteurs_email_interlocuteur_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_interlocuteur"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenances": {
      "name": "maintenances",
      "schema": "",
      "columns": {
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "recurrence": {
          "name": "recurrence",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "operations": {
          "name": "operations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "recommandations": {
          "name": "recommandations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type_maintenance": {
          "name": "type_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "autre_intervenant": {
          "name": "autre_intervenant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenances_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "maintenances_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "maintenances",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livraisons": {
      "name": "livraisons",
      "schema": "",
      "columns": {
        "id_livraison": {
          "name": "id_livraison",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "frais_divers": {
          "name": "frais_divers",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "periode_achat": {
          "name": "periode_achat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_achat": {
          "name": "prix_achat",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_revient": {
          "name": "prix_de_revient",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_vente": {
          "name": "prix_de_vente",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livraisons_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "livraisons_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "livraisons",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.documents": {
      "name": "documents",
      "schema": "",
      "columns": {
        "id_documents": {
          "name": "id_documents",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_document": {
          "name": "libelle_document",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "classification_document": {
          "name": "classification_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lien_document": {
          "name": "lien_document",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_document": {
          "name": "etat_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_livrable": {
          "name": "id_livrable",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_demandes": {
          "name": "id_demandes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "documents_id_livrable_livrables_id_livrable_fk": {
          "name": "documents_id_livrable_livrables_id_livrable_fk",
          "tableFrom": "documents",
          "tableTo": "livrables",
          "columnsFrom": [
            "id_livrable"
          ],
          "columnsTo": [
            "id_livrable"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_projet_projets_id_projet_fk": {
          "name": "documents_id_projet_projets_id_projet_fk",
          "tableFrom": "documents",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_demandes_demandes_id_demandes_fk": {
          "name": "documents_id_demandes_demandes_id_demandes_fk",
          "tableFrom": "documents",
          "tableTo": "demandes",
          "columnsFrom": [
            "id_demandes"
          ],
          "columnsTo": [
            "id_demandes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_contrat_contrats_id_contrat_fk": {
          "name": "documents_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "documents",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_employes_employes_id_employes_fk": {
          "name": "documents_id_employes_employes_id_employes_fk",
          "tableFrom": "documents",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_nature_document_nature_documents_id_nature_document_fk": {
          "name": "documents_id_nature_document_nature_documents_id_nature_document_fk",
          "tableFrom": "documents",
          "tableTo": "nature_documents",
          "columnsFrom": [
            "id_nature_document"
          ],
          "columnsTo": [
            "id_nature_document"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interventions": {
      "name": "interventions",
      "schema": "",
      "columns": {
        "id_intervention": {
          "name": "id_intervention",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_": {
          "name": "date_",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "cause_defaillance": {
          "name": "cause_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "rapport_intervention": {
          "name": "rapport_intervention",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type_intervention": {
          "name": "type_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_defaillance": {
          "name": "type_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "duree": {
          "name": "duree",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "statut_intervention": {
          "name": "statut_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "probleme_signale": {
          "name": "probleme_signale",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mode_intervention": {
          "name": "mode_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "detail_cause": {
          "name": "detail_cause",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interventions_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interventions_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interventions",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "interventions_id_contrat_contrats_id_contrat_fk": {
          "name": "interventions_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "interventions",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.exemplaires": {
      "name": "exemplaires",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "num_serie": {
          "name": "num_serie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "prix_exemplaire": {
          "name": "prix_exemplaire",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "date_entree": {
          "name": "date_entree",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "etat_vente": {
          "name": "etat_vente",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_livraison": {
          "name": "id_livraison",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_produit": {
          "name": "id_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "exemplaires_id_commande_commandes_id_commande_fk": {
          "name": "exemplaires_id_commande_commandes_id_commande_fk",
          "tableFrom": "exemplaires",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_livraison_livraisons_id_livraison_fk": {
          "name": "exemplaires_id_livraison_livraisons_id_livraison_fk",
          "tableFrom": "exemplaires",
          "tableTo": "livraisons",
          "columnsFrom": [
            "id_livraison"
          ],
          "columnsTo": [
            "id_livraison"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_produit_produits_id_produit_fk": {
          "name": "exemplaires_id_produit_produits_id_produit_fk",
          "tableFrom": "exemplaires",
          "tableTo": "produits",
          "columnsFrom": [
            "id_produit"
          ],
          "columnsTo": [
            "id_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.sortie_exemplaires": {
      "name": "sortie_exemplaires",
      "schema": "",
      "columns": {
        "id_sortie_exemplaire": {
          "name": "id_sortie_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "type_sortie": {
          "name": "type_sortie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "reference_id": {
          "name": "reference_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "date_sortie": {
          "name": "date_sortie",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "sortie_exemplaires",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.collaborer": {
      "name": "collaborer",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "collaborer_id_projet_projets_id_projet_fk": {
          "name": "collaborer_id_projet_projets_id_projet_fk",
          "tableFrom": "collaborer",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "collaborer_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "collaborer_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "collaborer",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "collaborer_id_projet_id_partenaire_pk": {
          "name": "collaborer_id_projet_id_partenaire_pk",
          "columns": [
            "id_projet",
            "id_partenaire"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_employes": {
      "name": "intervention_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_intervention": {
          "name": "id_intervention",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_employes_id_employes_employes_id_employes_fk": {
          "name": "intervention_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_employes_id_intervention_interventions_id_intervention_fk": {
          "name": "intervention_employes_id_intervention_interventions_id_intervention_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "interventions",
          "columnsFrom": [
            "id_intervention"
          ],
          "columnsTo": [
            "id_intervention"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_employes_id_employes_id_intervention_pk": {
          "name": "intervention_employes_id_employes_id_intervention_pk",
          "columns": [
            "id_employes",
            "id_intervention"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaire_commandes": {
      "name": "partenaire_commandes",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "partenaire_commandes_id_commande_commandes_id_commande_fk": {
          "name": "partenaire_commandes_id_commande_commandes_id_commande_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "partenaire_commandes_id_partenaire_id_commande_pk": {
          "name": "partenaire_commandes_id_partenaire_id_commande_pk",
          "columns": [
            "id_partenaire",
            "id_commande"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.faire_entrer": {
      "name": "faire_entrer",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "etat_apres": {
          "name": "etat_apres",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_retour": {
          "name": "date_de_retour",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "faire_entrer",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "faire_entrer_id_employes_employes_id_employes_fk": {
          "name": "faire_entrer_id_employes_employes_id_employes_fk",
          "tableFrom": "faire_entrer",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "faire_entrer_id_exemplaire_id_employes_pk": {
          "name": "faire_entrer_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.effectuer": {
      "name": "effectuer",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_prestation": {
          "name": "id_prestation",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "effectuer_id_employes_employes_id_employes_fk": {
          "name": "effectuer_id_employes_employes_id_employes_fk",
          "tableFrom": "effectuer",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "effectuer_id_prestation_prestations_id_prestation_fk": {
          "name": "effectuer_id_prestation_prestations_id_prestation_fk",
          "tableFrom": "effectuer",
          "tableTo": "prestations",
          "columnsFrom": [
            "id_prestation"
          ],
          "columnsTo": [
            "id_prestation"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "effectuer_id_employes_id_prestation_pk": {
          "name": "effectuer_id_employes_id_prestation_pk",
          "columns": [
            "id_employes",
            "id_prestation"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_taches": {
      "name": "intervention_taches",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_tache": {
          "name": "id_tache",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_taches_id_employes_employes_id_employes_fk": {
          "name": "intervention_taches_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_taches_id_tache_taches_id_tache_fk": {
          "name": "intervention_taches_id_tache_taches_id_tache_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "taches",
          "columnsFrom": [
            "id_tache"
          ],
          "columnsTo": [
            "id_tache"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_taches_id_employes_id_tache_pk": {
          "name": "intervention_taches_id_employes_id_tache_pk",
          "columns": [
            "id_employes",
            "id_tache"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.faire_sortir": {
      "name": "faire_sortir",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "but_usage": {
          "name": "but_usage",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_avant": {
          "name": "etat_avant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_sortie": {
          "name": "date_de_sortie",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "site_intervention": {
          "name": "site_intervention",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "faire_sortir",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "faire_sortir_id_employes_employes_id_employes_fk": {
          "name": "faire_sortir_id_employes_employes_id_employes_fk",
          "tableFrom": "faire_sortir",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "faire_sortir_id_exemplaire_id_employes_pk": {
          "name": "faire_sortir_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_employes": {
      "name": "maintenance_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_employes_id_employes_employes_id_employes_fk": {
          "name": "maintenance_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_employes_id_employes_id_maintenance_pk": {
          "name": "maintenance_employes_id_employes_id_maintenance_pk",
          "columns": [
            "id_employes",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_moyens_travail": {
      "name": "maintenance_moyens_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "date_maintenance": {
          "name": "date_maintenance",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "moyens_de_travail",
          "columnsFrom": [
            "id_moyens_de_travail"
          ],
          "columnsTo": [
            "id_moyens_de_travail"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk",
          "columns": [
            "id_moyens_de_travail",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
File: core/database/migrations/meta/0001_snapshot.json
================================================
{
  "id": "5d9a7c7a-2c2d-41c3-bb75-5f22ab0d0204",
  "prevId": "32e964f9-448d-4e96-b687-83b35d419eff",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.familles": {
      "name": "familles",
      "schema": "",
      "columns": {
        "id_famille": {
          "name": "id_famille",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_famille": {
          "name": "libelle_famille",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.modeles": {
      "name": "modeles",
      "schema": "",
      "columns": {
        "id_modele": {
          "name": "id_modele",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.marques": {
      "name": "marques",
      "schema": "",
      "columns": {
        "id_marque": {
          "name": "id_marque",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_marque": {
          "name": "libelle_marque",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.fonctions": {
      "name": "fonctions",
      "schema": "",
      "columns": {
        "id_fonction": {
          "name": "id_fonction",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_fonction": {
          "name": "nom_fonction",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "fonctions_nom_fonction_unique": {
          "name": "fonctions_nom_fonction_unique",
          "nullsNotDistinct": false,
          "columns": [
            "nom_fonction"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employes": {
      "name": "employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "keycloak_id": {
          "name": "keycloak_id",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "nom_employes": {
          "name": "nom_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prenom_employes": {
          "name": "prenom_employes",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": false
        },
        "email_employes": {
          "name": "email_employes",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "contact_employes": {
          "name": "contact_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "adresse_employes": {
          "name": "adresse_employes",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status_employes": {
          "name": "status_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_embauche_employes": {
          "name": "date_embauche_employes",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "password_employes": {
          "name": "password_employes",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "date_de_naissance": {
          "name": "date_de_naissance",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "contrat": {
          "name": "contrat",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "id_fonction": {
          "name": "id_fonction",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employes_id_fonction_fonctions_id_fonction_fk": {
          "name": "employes_id_fonction_fonctions_id_fonction_fk",
          "tableFrom": "employes",
          "tableTo": "fonctions",
          "columnsFrom": [
            "id_fonction"
          ],
          "columnsTo": [
            "id_fonction"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "employes_keycloak_id_unique": {
          "name": "employes_keycloak_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "keycloak_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.demandes": {
      "name": "demandes",
      "schema": "",
      "columns": {
        "id_demandes": {
          "name": "id_demandes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_absence": {
          "name": "date_absence",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_retour": {
          "name": "date_retour",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "motif": {
          "name": "motif",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type_demande": {
          "name": "type_demande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "durÃ©e": {
          "name": "durÃ©e",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "heure_debut": {
          "name": "heure_debut",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "heure_fin": {
          "name": "heure_fin",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "demandes_id_employes_employes_id_employes_fk": {
          "name": "demandes_id_employes_employes_id_employes_fk",
          "tableFrom": "demandes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.nature_documents": {
      "name": "nature_documents",
      "schema": "",
      "columns": {
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.entites": {
      "name": "entites",
      "schema": "",
      "columns": {
        "id_entite": {
          "name": "id_entite",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.clients_en_ligne": {
      "name": "clients_en_ligne",
      "schema": "",
      "columns": {
        "id_client": {
          "name": "id_client",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_complet": {
          "name": "nom_complet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mot_de_passe": {
          "name": "mot_de_passe",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "numero_de_telephone": {
          "name": "numero_de_telephone",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "clients_en_ligne_email_unique": {
          "name": "clients_en_ligne_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.commandes": {
      "name": "commandes",
      "schema": "",
      "columns": {
        "id_commande": {
          "name": "id_commande",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_commande": {
          "name": "date_de_commande",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "etat_commande": {
          "name": "etat_commande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_livraison": {
          "name": "date_livraison",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "lieu_de_livraison": {
          "name": "lieu_de_livraison",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mode_de_paiement": {
          "name": "mode_de_paiement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_client": {
          "name": "id_client",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "commandes_id_client_clients_en_ligne_id_client_fk": {
          "name": "commandes_id_client_clients_en_ligne_id_client_fk",
          "tableFrom": "commandes",
          "tableTo": "clients_en_ligne",
          "columnsFrom": [
            "id_client"
          ],
          "columnsTo": [
            "id_client"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.type_produits": {
      "name": "type_produits",
      "schema": "",
      "columns": {
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.categories": {
      "name": "categories",
      "schema": "",
      "columns": {
        "id_categorie": {
          "name": "id_categorie",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.projets": {
      "name": "projets",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_projet": {
          "name": "nom_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_projet": {
          "name": "type_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "devis_estimatif": {
          "name": "devis_estimatif",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "duree_prevu_projet": {
          "name": "duree_prevu_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description_projet": {
          "name": "description_projet",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "etat": {
          "name": "etat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "site": {
          "name": "site",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "projets_id_famille_familles_id_famille_fk": {
          "name": "projets_id_famille_familles_id_famille_fk",
          "tableFrom": "projets",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.taches": {
      "name": "taches",
      "schema": "",
      "columns": {
        "id_tache": {
          "name": "id_tache",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_tache": {
          "name": "nom_tache",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "desc_tache": {
          "name": "desc_tache",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "priorite": {
          "name": "priorite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "taches_id_projet_projets_id_projet_fk": {
          "name": "taches_id_projet_projets_id_projet_fk",
          "tableFrom": "taches",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.prestations": {
      "name": "prestations",
      "schema": "",
      "columns": {
        "id_prestation": {
          "name": "id_prestation",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_maintenance": {
          "name": "date_de_maintenance",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "type_de_maintenance": {
          "name": "type_de_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "pieces_remplacees": {
          "name": "pieces_remplacees",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "cout_maintenance": {
          "name": "cout_maintenance",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livrables": {
      "name": "livrables",
      "schema": "",
      "columns": {
        "id_livrable": {
          "name": "id_livrable",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "realisations": {
          "name": "realisations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "reserves": {
          "name": "reserves",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "approbation": {
          "name": "approbation",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livrables_id_projet_projets_id_projet_fk": {
          "name": "livrables_id_projet_projets_id_projet_fk",
          "tableFrom": "livrables",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.moyens_de_travail": {
      "name": "moyens_de_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_acquisition": {
          "name": "date_acquisition",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "section": {
          "name": "section",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.services": {
      "name": "services",
      "schema": "",
      "columns": {
        "id_service": {
          "name": "id_service",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "titre_service": {
          "name": "titre_service",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "services_id_employes_employes_id_employes_fk": {
          "name": "services_id_employes_employes_id_employes_fk",
          "tableFrom": "services",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.affiches": {
      "name": "affiches",
      "schema": "",
      "columns": {
        "id_affiche": {
          "name": "id_affiche",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "titre": {
          "name": "titre",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "affiches_id_employes_employes_id_employes_fk": {
          "name": "affiches_id_employes_employes_id_employes_fk",
          "tableFrom": "affiches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.produits": {
      "name": "produits",
      "schema": "",
      "columns": {
        "id_produit": {
          "name": "id_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "code_produit": {
          "name": "code_produit",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "desi_produit": {
          "name": "desi_produit",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "desc_produit": {
          "name": "desc_produit",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "image_produit": {
          "name": "image_produit",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "qte_produit": {
          "name": "qte_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "emplacement": {
          "name": "emplacement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_categorie": {
          "name": "id_categorie",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_modele": {
          "name": "id_modele",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_marque": {
          "name": "id_marque",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "produits_id_categorie_categories_id_categorie_fk": {
          "name": "produits_id_categorie_categories_id_categorie_fk",
          "tableFrom": "produits",
          "tableTo": "categories",
          "columnsFrom": [
            "id_categorie"
          ],
          "columnsTo": [
            "id_categorie"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_type_produit_type_produits_id_type_produit_fk": {
          "name": "produits_id_type_produit_type_produits_id_type_produit_fk",
          "tableFrom": "produits",
          "tableTo": "type_produits",
          "columnsFrom": [
            "id_type_produit"
          ],
          "columnsTo": [
            "id_type_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_modele_modeles_id_modele_fk": {
          "name": "produits_id_modele_modeles_id_modele_fk",
          "tableFrom": "produits",
          "tableTo": "modeles",
          "columnsFrom": [
            "id_modele"
          ],
          "columnsTo": [
            "id_modele"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_famille_familles_id_famille_fk": {
          "name": "produits_id_famille_familles_id_famille_fk",
          "tableFrom": "produits",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_marque_marques_id_marque_fk": {
          "name": "produits_id_marque_marques_id_marque_fk",
          "tableFrom": "produits",
          "tableTo": "marques",
          "columnsFrom": [
            "id_marque"
          ],
          "columnsTo": [
            "id_marque"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "produits_code_produit_unique": {
          "name": "produits_code_produit_unique",
          "nullsNotDistinct": false,
          "columns": [
            "code_produit"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaires": {
      "name": "partenaires",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_partenaire": {
          "name": "nom_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "telephone_partenaire": {
          "name": "telephone_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email_partenaire": {
          "name": "email_partenaire",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "specialite": {
          "name": "specialite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "localisation": {
          "name": "localisation",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_partenaire": {
          "name": "type_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_entite": {
          "name": "id_entite",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaires_id_entite_entites_id_entite_fk": {
          "name": "partenaires_id_entite_entites_id_entite_fk",
          "tableFrom": "partenaires",
          "tableTo": "entites",
          "columnsFrom": [
            "id_entite"
          ],
          "columnsTo": [
            "id_entite"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "partenaires_email_partenaire_unique": {
          "name": "partenaires_email_partenaire_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_partenaire"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contrats": {
      "name": "contrats",
      "schema": "",
      "columns": {
        "id_contrat": {
          "name": "id_contrat",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_contrat": {
          "name": "nom_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "duree_contrat": {
          "name": "duree_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "reference": {
          "name": "reference",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_de_contrat": {
          "name": "type_de_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contrats_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "contrats_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "contrats",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interlocuteurs": {
      "name": "interlocuteurs",
      "schema": "",
      "columns": {
        "id_interlocuteur": {
          "name": "id_interlocuteur",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_interlocuteur": {
          "name": "nom_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "prenom_interlocuteur": {
          "name": "prenom_interlocuteur",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": true
        },
        "contact_interlocuteur": {
          "name": "contact_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email_interlocuteur": {
          "name": "email_interlocuteur",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "fonction_interlocuteur": {
          "name": "fonction_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interlocuteurs",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "interlocuteurs_email_interlocuteur_unique": {
          "name": "interlocuteurs_email_interlocuteur_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_interlocuteur"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenances": {
      "name": "maintenances",
      "schema": "",
      "columns": {
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "recurrence": {
          "name": "recurrence",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "operations": {
          "name": "operations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "recommandations": {
          "name": "recommandations",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type_maintenance": {
          "name": "type_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "autre_intervenant": {
          "name": "autre_intervenant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenances_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "maintenances_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "maintenances",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livraisons": {
      "name": "livraisons",
      "schema": "",
      "columns": {
        "id_livraison": {
          "name": "id_livraison",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "frais_divers": {
          "name": "frais_divers",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "periode_achat": {
          "name": "periode_achat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_achat": {
          "name": "prix_achat",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_revient": {
          "name": "prix_de_revient",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_vente": {
          "name": "prix_de_vente",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livraisons_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "livraisons_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "livraisons",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.documents": {
      "name": "documents",
      "schema": "",
      "columns": {
        "id_documents": {
          "name": "id_documents",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_document": {
          "name": "libelle_document",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "classification_document": {
          "name": "classification_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lien_document": {
          "name": "lien_document",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_document": {
          "name": "etat_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_livrable": {
          "name": "id_livrable",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_demandes": {
          "name": "id_demandes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "documents_id_livrable_livrables_id_livrable_fk": {
          "name": "documents_id_livrable_livrables_id_livrable_fk",
          "tableFrom": "documents",
          "tableTo": "livrables",
          "columnsFrom": [
            "id_livrable"
          ],
          "columnsTo": [
            "id_livrable"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_projet_projets_id_projet_fk": {
          "name": "documents_id_projet_projets_id_projet_fk",
          "tableFrom": "documents",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_demandes_demandes_id_demandes_fk": {
          "name": "documents_id_demandes_demandes_id_demandes_fk",
          "tableFrom": "documents",
          "tableTo": "demandes",
          "columnsFrom": [
            "id_demandes"
          ],
          "columnsTo": [
            "id_demandes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_contrat_contrats_id_contrat_fk": {
          "name": "documents_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "documents",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_employes_employes_id_employes_fk": {
          "name": "documents_id_employes_employes_id_employes_fk",
          "tableFrom": "documents",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_nature_document_nature_documents_id_nature_document_fk": {
          "name": "documents_id_nature_document_nature_documents_id_nature_document_fk",
          "tableFrom": "documents",
          "tableTo": "nature_documents",
          "columnsFrom": [
            "id_nature_document"
          ],
          "columnsTo": [
            "id_nature_document"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interventions": {
      "name": "interventions",
      "schema": "",
      "columns": {
        "id_intervention": {
          "name": "id_intervention",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_": {
          "name": "date_",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "cause_defaillance": {
          "name": "cause_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "rapport_intervention": {
          "name": "rapport_intervention",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type_intervention": {
          "name": "type_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_defaillance": {
          "name": "type_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "duree": {
          "name": "duree",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "statut_intervention": {
          "name": "statut_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "probleme_signale": {
          "name": "probleme_signale",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "mode_intervention": {
          "name": "mode_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "detail_cause": {
          "name": "detail_cause",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interventions_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interventions_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interventions",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "interventions_id_contrat_contrats_id_contrat_fk": {
          "name": "interventions_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "interventions",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.exemplaires": {
      "name": "exemplaires",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "num_serie": {
          "name": "num_serie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "prix_exemplaire": {
          "name": "prix_exemplaire",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": true
        },
        "date_entree": {
          "name": "date_entree",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "etat_exemplaire": {
          "name": "etat_exemplaire",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_livraison": {
          "name": "id_livraison",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_produit": {
          "name": "id_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "exemplaires_id_commande_commandes_id_commande_fk": {
          "name": "exemplaires_id_commande_commandes_id_commande_fk",
          "tableFrom": "exemplaires",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_livraison_livraisons_id_livraison_fk": {
          "name": "exemplaires_id_livraison_livraisons_id_livraison_fk",
          "tableFrom": "exemplaires",
          "tableTo": "livraisons",
          "columnsFrom": [
            "id_livraison"
          ],
          "columnsTo": [
            "id_livraison"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_produit_produits_id_produit_fk": {
          "name": "exemplaires_id_produit_produits_id_produit_fk",
          "tableFrom": "exemplaires",
          "tableTo": "produits",
          "columnsFrom": [
            "id_produit"
          ],
          "columnsTo": [
            "id_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.sortie_exemplaires": {
      "name": "sortie_exemplaires",
      "schema": "",
      "columns": {
        "id_sortie_exemplaire": {
          "name": "id_sortie_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "type_sortie": {
          "name": "type_sortie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "reference_id": {
          "name": "reference_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "date_sortie": {
          "name": "date_sortie",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "sortie_exemplaires",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.collaborer": {
      "name": "collaborer",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "collaborer_id_projet_projets_id_projet_fk": {
          "name": "collaborer_id_projet_projets_id_projet_fk",
          "tableFrom": "collaborer",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "collaborer_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "collaborer_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "collaborer",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "collaborer_id_projet_id_partenaire_pk": {
          "name": "collaborer_id_projet_id_partenaire_pk",
          "columns": [
            "id_projet",
            "id_partenaire"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_employes": {
      "name": "intervention_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_intervention": {
          "name": "id_intervention",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_employes_id_employes_employes_id_employes_fk": {
          "name": "intervention_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_employes_id_intervention_interventions_id_intervention_fk": {
          "name": "intervention_employes_id_intervention_interventions_id_intervention_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "interventions",
          "columnsFrom": [
            "id_intervention"
          ],
          "columnsTo": [
            "id_intervention"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_employes_id_employes_id_intervention_pk": {
          "name": "intervention_employes_id_employes_id_intervention_pk",
          "columns": [
            "id_employes",
            "id_intervention"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaire_commandes": {
      "name": "partenaire_commandes",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "partenaire_commandes_id_commande_commandes_id_commande_fk": {
          "name": "partenaire_commandes_id_commande_commandes_id_commande_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "partenaire_commandes_id_partenaire_id_commande_pk": {
          "name": "partenaire_commandes_id_partenaire_id_commande_pk",
          "columns": [
            "id_partenaire",
            "id_commande"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.faire_entrer": {
      "name": "faire_entrer",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "etat_apres": {
          "name": "etat_apres",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_retour": {
          "name": "date_de_retour",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "faire_entrer_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "faire_entrer",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "faire_entrer_id_employes_employes_id_employes_fk": {
          "name": "faire_entrer_id_employes_employes_id_employes_fk",
          "tableFrom": "faire_entrer",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "faire_entrer_id_exemplaire_id_employes_pk": {
          "name": "faire_entrer_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.effectuer": {
      "name": "effectuer",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_prestation": {
          "name": "id_prestation",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "effectuer_id_employes_employes_id_employes_fk": {
          "name": "effectuer_id_employes_employes_id_employes_fk",
          "tableFrom": "effectuer",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "effectuer_id_prestation_prestations_id_prestation_fk": {
          "name": "effectuer_id_prestation_prestations_id_prestation_fk",
          "tableFrom": "effectuer",
          "tableTo": "prestations",
          "columnsFrom": [
            "id_prestation"
          ],
          "columnsTo": [
            "id_prestation"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "effectuer_id_employes_id_prestation_pk": {
          "name": "effectuer_id_employes_id_prestation_pk",
          "columns": [
            "id_employes",
            "id_prestation"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_taches": {
      "name": "intervention_taches",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_tache": {
          "name": "id_tache",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_taches_id_employes_employes_id_employes_fk": {
          "name": "intervention_taches_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_taches_id_tache_taches_id_tache_fk": {
          "name": "intervention_taches_id_tache_taches_id_tache_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "taches",
          "columnsFrom": [
            "id_tache"
          ],
          "columnsTo": [
            "id_tache"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_taches_id_employes_id_tache_pk": {
          "name": "intervention_taches_id_employes_id_tache_pk",
          "columns": [
            "id_employes",
            "id_tache"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.faire_sortir": {
      "name": "faire_sortir",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "but_usage": {
          "name": "but_usage",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_avant": {
          "name": "etat_avant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_sortie": {
          "name": "date_de_sortie",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "site_intervention": {
          "name": "site_intervention",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "faire_sortir_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "faire_sortir",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "faire_sortir_id_employes_employes_id_employes_fk": {
          "name": "faire_sortir_id_employes_employes_id_employes_fk",
          "tableFrom": "faire_sortir",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "faire_sortir_id_exemplaire_id_employes_pk": {
          "name": "faire_sortir_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_employes": {
      "name": "maintenance_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_employes_id_employes_employes_id_employes_fk": {
          "name": "maintenance_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_employes_id_employes_id_maintenance_pk": {
          "name": "maintenance_employes_id_employes_id_maintenance_pk",
          "columns": [
            "id_employes",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_moyens_travail": {
      "name": "maintenance_moyens_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "date_maintenance": {
          "name": "date_maintenance",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "moyens_de_travail",
          "columnsFrom": [
            "id_moyens_de_travail"
          ],
          "columnsTo": [
            "id_moyens_de_travail"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk",
          "columns": [
            "id_moyens_de_travail",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
File: core/database/migrations/meta/0002_snapshot.json
================================================
{
  "id": "a91b9cba-2542-4653-9e79-9d0c24386a64",
  "prevId": "5d9a7c7a-2c2d-41c3-bb75-5f22ab0d0204",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.familles": {
      "name": "familles",
      "schema": "",
      "columns": {
        "id_famille": {
          "name": "id_famille",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_famille": {
          "name": "libelle_famille",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.modeles": {
      "name": "modeles",
      "schema": "",
      "columns": {
        "id_modele": {
          "name": "id_modele",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_modele": {
          "name": "libelle_modele",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.marques": {
      "name": "marques",
      "schema": "",
      "columns": {
        "id_marque": {
          "name": "id_marque",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_marque": {
          "name": "libelle_marque",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.fonctions": {
      "name": "fonctions",
      "schema": "",
      "columns": {
        "id_fonction": {
          "name": "id_fonction",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_fonction": {
          "name": "nom_fonction",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "fonctions_nom_fonction_unique": {
          "name": "fonctions_nom_fonction_unique",
          "nullsNotDistinct": false,
          "columns": [
            "nom_fonction"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employes": {
      "name": "employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "keycloak_id": {
          "name": "keycloak_id",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "nom_employes": {
          "name": "nom_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prenom_employes": {
          "name": "prenom_employes",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": false
        },
        "email_employes": {
          "name": "email_employes",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "contact_employes": {
          "name": "contact_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "adresse_employes": {
          "name": "adresse_employes",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status_employes": {
          "name": "status_employes",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_embauche_employes": {
          "name": "date_embauche_employes",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "password_employes": {
          "name": "password_employes",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "date_de_naissance": {
          "name": "date_de_naissance",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "contrat": {
          "name": "contrat",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "id_fonction": {
          "name": "id_fonction",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employes_id_fonction_fonctions_id_fonction_fk": {
          "name": "employes_id_fonction_fonctions_id_fonction_fk",
          "tableFrom": "employes",
          "tableTo": "fonctions",
          "columnsFrom": [
            "id_fonction"
          ],
          "columnsTo": [
            "id_fonction"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "employes_keycloak_id_unique": {
          "name": "employes_keycloak_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "keycloak_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.demandes": {
      "name": "demandes",
      "schema": "",
      "columns": {
        "id_demandes": {
          "name": "id_demandes",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_absence": {
          "name": "date_absence",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_retour": {
          "name": "date_retour",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "motif": {
          "name": "motif",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type_demande": {
          "name": "type_demande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "durÃ©e": {
          "name": "durÃ©e",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "heure_debut": {
          "name": "heure_debut",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "heure_fin": {
          "name": "heure_fin",
          "type": "time",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "demandes_id_employes_employes_id_employes_fk": {
          "name": "demandes_id_employes_employes_id_employes_fk",
          "tableFrom": "demandes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.nature_documents": {
      "name": "nature_documents",
      "schema": "",
      "columns": {
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.entites": {
      "name": "entites",
      "schema": "",
      "columns": {
        "id_entite": {
          "name": "id_entite",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.clients_en_ligne": {
      "name": "clients_en_ligne",
      "schema": "",
      "columns": {
        "id_client": {
          "name": "id_client",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_complet": {
          "name": "nom_complet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "mot_de_passe": {
          "name": "mot_de_passe",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "numero_de_telephone": {
          "name": "numero_de_telephone",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "clients_en_ligne_email_unique": {
          "name": "clients_en_ligne_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.commandes": {
      "name": "commandes",
      "schema": "",
      "columns": {
        "id_commande": {
          "name": "id_commande",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_commande": {
          "name": "date_de_commande",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "etat_commande": {
          "name": "etat_commande",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_livraison": {
          "name": "date_livraison",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "lieu_de_livraison": {
          "name": "lieu_de_livraison",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "mode_de_paiement": {
          "name": "mode_de_paiement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_client": {
          "name": "id_client",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "commandes_id_client_clients_en_ligne_id_client_fk": {
          "name": "commandes_id_client_clients_en_ligne_id_client_fk",
          "tableFrom": "commandes",
          "tableTo": "clients_en_ligne",
          "columnsFrom": [
            "id_client"
          ],
          "columnsTo": [
            "id_client"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.type_produits": {
      "name": "type_produits",
      "schema": "",
      "columns": {
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.categories": {
      "name": "categories",
      "schema": "",
      "columns": {
        "id_categorie": {
          "name": "id_categorie",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.projets": {
      "name": "projets",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_projet": {
          "name": "nom_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "type_projet": {
          "name": "type_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "devis_estimatif": {
          "name": "devis_estimatif",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "duree_prevu_projet": {
          "name": "duree_prevu_projet",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "description_projet": {
          "name": "description_projet",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "etat": {
          "name": "etat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "site": {
          "name": "site",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "projets_id_famille_familles_id_famille_fk": {
          "name": "projets_id_famille_familles_id_famille_fk",
          "tableFrom": "projets",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.taches": {
      "name": "taches",
      "schema": "",
      "columns": {
        "id_tache": {
          "name": "id_tache",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_tache": {
          "name": "nom_tache",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "desc_tache": {
          "name": "desc_tache",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "priorite": {
          "name": "priorite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "taches_id_projet_projets_id_projet_fk": {
          "name": "taches_id_projet_projets_id_projet_fk",
          "tableFrom": "taches",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.prestations": {
      "name": "prestations",
      "schema": "",
      "columns": {
        "id_prestation": {
          "name": "id_prestation",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_de_maintenance": {
          "name": "date_de_maintenance",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "type_de_maintenance": {
          "name": "type_de_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "pieces_remplacees": {
          "name": "pieces_remplacees",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "cout_maintenance": {
          "name": "cout_maintenance",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livrables": {
      "name": "livrables",
      "schema": "",
      "columns": {
        "id_livrable": {
          "name": "id_livrable",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_livrable": {
          "name": "libelle_livrable",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "realisations": {
          "name": "realisations",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "reserves": {
          "name": "reserves",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "approbation": {
          "name": "approbation",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livrables_id_projet_projets_id_projet_fk": {
          "name": "livrables_id_projet_projets_id_projet_fk",
          "tableFrom": "livrables",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.moyens_de_travail": {
      "name": "moyens_de_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "denomination": {
          "name": "denomination",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_acquisition": {
          "name": "date_acquisition",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "section": {
          "name": "section",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.services": {
      "name": "services",
      "schema": "",
      "columns": {
        "id_service": {
          "name": "id_service",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "titre_service": {
          "name": "titre_service",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "services_id_employes_employes_id_employes_fk": {
          "name": "services_id_employes_employes_id_employes_fk",
          "tableFrom": "services",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.affiches": {
      "name": "affiches",
      "schema": "",
      "columns": {
        "id_affiche": {
          "name": "id_affiche",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "titre": {
          "name": "titre",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "affiches_id_employes_employes_id_employes_fk": {
          "name": "affiches_id_employes_employes_id_employes_fk",
          "tableFrom": "affiches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.produits": {
      "name": "produits",
      "schema": "",
      "columns": {
        "id_produit": {
          "name": "id_produit",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "code_produit": {
          "name": "code_produit",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "desi_produit": {
          "name": "desi_produit",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "desc_produit": {
          "name": "desc_produit",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "image_produit": {
          "name": "image_produit",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "qte_produit": {
          "name": "qte_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "emplacement": {
          "name": "emplacement",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "caracteristiques": {
          "name": "caracteristiques",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "prix_produit": {
          "name": "prix_produit",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "id_categorie": {
          "name": "id_categorie",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_type_produit": {
          "name": "id_type_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_modele": {
          "name": "id_modele",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_famille": {
          "name": "id_famille",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_marque": {
          "name": "id_marque",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "produits_id_categorie_categories_id_categorie_fk": {
          "name": "produits_id_categorie_categories_id_categorie_fk",
          "tableFrom": "produits",
          "tableTo": "categories",
          "columnsFrom": [
            "id_categorie"
          ],
          "columnsTo": [
            "id_categorie"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_type_produit_type_produits_id_type_produit_fk": {
          "name": "produits_id_type_produit_type_produits_id_type_produit_fk",
          "tableFrom": "produits",
          "tableTo": "type_produits",
          "columnsFrom": [
            "id_type_produit"
          ],
          "columnsTo": [
            "id_type_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_modele_modeles_id_modele_fk": {
          "name": "produits_id_modele_modeles_id_modele_fk",
          "tableFrom": "produits",
          "tableTo": "modeles",
          "columnsFrom": [
            "id_modele"
          ],
          "columnsTo": [
            "id_modele"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_famille_familles_id_famille_fk": {
          "name": "produits_id_famille_familles_id_famille_fk",
          "tableFrom": "produits",
          "tableTo": "familles",
          "columnsFrom": [
            "id_famille"
          ],
          "columnsTo": [
            "id_famille"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produits_id_marque_marques_id_marque_fk": {
          "name": "produits_id_marque_marques_id_marque_fk",
          "tableFrom": "produits",
          "tableTo": "marques",
          "columnsFrom": [
            "id_marque"
          ],
          "columnsTo": [
            "id_marque"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "produits_code_produit_unique": {
          "name": "produits_code_produit_unique",
          "nullsNotDistinct": false,
          "columns": [
            "code_produit"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaires": {
      "name": "partenaires",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_partenaire": {
          "name": "nom_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "telephone_partenaire": {
          "name": "telephone_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "email_partenaire": {
          "name": "email_partenaire",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "specialite": {
          "name": "specialite",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "localisation": {
          "name": "localisation",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "type_partenaire": {
          "name": "type_partenaire",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_entite": {
          "name": "id_entite",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaires_id_entite_entites_id_entite_fk": {
          "name": "partenaires_id_entite_entites_id_entite_fk",
          "tableFrom": "partenaires",
          "tableTo": "entites",
          "columnsFrom": [
            "id_entite"
          ],
          "columnsTo": [
            "id_entite"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "partenaires_email_partenaire_unique": {
          "name": "partenaires_email_partenaire_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_partenaire"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contrats": {
      "name": "contrats",
      "schema": "",
      "columns": {
        "id_contrat": {
          "name": "id_contrat",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_contrat": {
          "name": "nom_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "duree_contrat": {
          "name": "duree_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_debut": {
          "name": "date_debut",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "date_fin": {
          "name": "date_fin",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "reference": {
          "name": "reference",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "type_de_contrat": {
          "name": "type_de_contrat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "statut": {
          "name": "statut",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contrats_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "contrats_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "contrats",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interlocuteurs": {
      "name": "interlocuteurs",
      "schema": "",
      "columns": {
        "id_interlocuteur": {
          "name": "id_interlocuteur",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom_interlocuteur": {
          "name": "nom_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prenom_interlocuteur": {
          "name": "prenom_interlocuteur",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": false
        },
        "contact_interlocuteur": {
          "name": "contact_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "email_interlocuteur": {
          "name": "email_interlocuteur",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "fonction_interlocuteur": {
          "name": "fonction_interlocuteur",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interlocuteurs_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interlocuteurs",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "interlocuteurs_email_interlocuteur_unique": {
          "name": "interlocuteurs_email_interlocuteur_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email_interlocuteur"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenances": {
      "name": "maintenances",
      "schema": "",
      "columns": {
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "recurrence": {
          "name": "recurrence",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "operations": {
          "name": "operations",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "recommandations": {
          "name": "recommandations",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type_maintenance": {
          "name": "type_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "autre_intervenant": {
          "name": "autre_intervenant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenances_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "maintenances_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "maintenances",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livraisons": {
      "name": "livraisons",
      "schema": "",
      "columns": {
        "id_livraison": {
          "name": "id_livraison",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "reference_livraison": {
          "name": "reference_livraison",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": false
        },
        "frais_divers": {
          "name": "frais_divers",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "periode_achat": {
          "name": "periode_achat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_achat": {
          "name": "prix_achat",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_revient": {
          "name": "prix_de_revient",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_de_vente": {
          "name": "prix_de_vente",
          "type": "numeric(10, 2)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livraisons_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "livraisons_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "livraisons",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.documents": {
      "name": "documents",
      "schema": "",
      "columns": {
        "id_documents": {
          "name": "id_documents",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle_document": {
          "name": "libelle_document",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "classification_document": {
          "name": "classification_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_document": {
          "name": "date_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "lien_document": {
          "name": "lien_document",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "etat_document": {
          "name": "etat_document",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_livrable": {
          "name": "id_livrable",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_demandes": {
          "name": "id_demandes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_intervention": {
          "name": "id_intervention",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_nature_document": {
          "name": "id_nature_document",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "documents_id_livrable_livrables_id_livrable_fk": {
          "name": "documents_id_livrable_livrables_id_livrable_fk",
          "tableFrom": "documents",
          "tableTo": "livrables",
          "columnsFrom": [
            "id_livrable"
          ],
          "columnsTo": [
            "id_livrable"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_projet_projets_id_projet_fk": {
          "name": "documents_id_projet_projets_id_projet_fk",
          "tableFrom": "documents",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_demandes_demandes_id_demandes_fk": {
          "name": "documents_id_demandes_demandes_id_demandes_fk",
          "tableFrom": "documents",
          "tableTo": "demandes",
          "columnsFrom": [
            "id_demandes"
          ],
          "columnsTo": [
            "id_demandes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_contrat_contrats_id_contrat_fk": {
          "name": "documents_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "documents",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_employes_employes_id_employes_fk": {
          "name": "documents_id_employes_employes_id_employes_fk",
          "tableFrom": "documents",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_intervention_interventions_id_intervention_fk": {
          "name": "documents_id_intervention_interventions_id_intervention_fk",
          "tableFrom": "documents",
          "tableTo": "interventions",
          "columnsFrom": [
            "id_intervention"
          ],
          "columnsTo": [
            "id_intervention"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_id_nature_document_nature_documents_id_nature_document_fk": {
          "name": "documents_id_nature_document_nature_documents_id_nature_document_fk",
          "tableFrom": "documents",
          "tableTo": "nature_documents",
          "columnsFrom": [
            "id_nature_document"
          ],
          "columnsTo": [
            "id_nature_document"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.interventions": {
      "name": "interventions",
      "schema": "",
      "columns": {
        "id_intervention": {
          "name": "id_intervention",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_intervention": {
          "name": "date_intervention",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "cause_defaillance": {
          "name": "cause_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "rapport_intervention": {
          "name": "rapport_intervention",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type_intervention": {
          "name": "type_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "type_defaillance": {
          "name": "type_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "duree": {
          "name": "duree",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "statut_intervention": {
          "name": "statut_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "recommandation": {
          "name": "recommandation",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "probleme_signale": {
          "name": "probleme_signale",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "mode_intervention": {
          "name": "mode_intervention",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "detail_cause": {
          "name": "detail_cause",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_contrat": {
          "name": "id_contrat",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "interventions_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "interventions_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "interventions",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "interventions_id_contrat_contrats_id_contrat_fk": {
          "name": "interventions_id_contrat_contrats_id_contrat_fk",
          "tableFrom": "interventions",
          "tableTo": "contrats",
          "columnsFrom": [
            "id_contrat"
          ],
          "columnsTo": [
            "id_contrat"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.exemplaires": {
      "name": "exemplaires",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "num_serie": {
          "name": "num_serie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_entree": {
          "name": "date_entree",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "etat_exemplaire": {
          "name": "etat_exemplaire",
          "type": "varchar(75)",
          "primaryKey": false,
          "notNull": false,
          "default": "'Disponible'"
        },
        "id_livraison": {
          "name": "id_livraison",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "id_produit": {
          "name": "id_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "exemplaires_id_livraison_livraisons_id_livraison_fk": {
          "name": "exemplaires_id_livraison_livraisons_id_livraison_fk",
          "tableFrom": "exemplaires",
          "tableTo": "livraisons",
          "columnsFrom": [
            "id_livraison"
          ],
          "columnsTo": [
            "id_livraison"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaires_id_produit_produits_id_produit_fk": {
          "name": "exemplaires_id_produit_produits_id_produit_fk",
          "tableFrom": "exemplaires",
          "tableTo": "produits",
          "columnsFrom": [
            "id_produit"
          ],
          "columnsTo": [
            "id_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.sortie_exemplaires": {
      "name": "sortie_exemplaires",
      "schema": "",
      "columns": {
        "id_sortie_exemplaire": {
          "name": "id_sortie_exemplaire",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "type_sortie": {
          "name": "type_sortie",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "reference_id": {
          "name": "reference_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "date_sortie": {
          "name": "date_sortie",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "sortie_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "sortie_exemplaires",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaire_projets": {
      "name": "partenaire_projets",
      "schema": "",
      "columns": {
        "id_projet": {
          "name": "id_projet",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaire_projets_id_projet_projets_id_projet_fk": {
          "name": "partenaire_projets_id_projet_projets_id_projet_fk",
          "tableFrom": "partenaire_projets",
          "tableTo": "projets",
          "columnsFrom": [
            "id_projet"
          ],
          "columnsTo": [
            "id_projet"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "partenaire_projets_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "partenaire_projets_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "partenaire_projets",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "partenaire_projets_id_projet_id_partenaire_pk": {
          "name": "partenaire_projets_id_projet_id_partenaire_pk",
          "columns": [
            "id_projet",
            "id_partenaire"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_employes": {
      "name": "intervention_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_intervention": {
          "name": "id_intervention",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_employes_id_employes_employes_id_employes_fk": {
          "name": "intervention_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_employes_id_intervention_interventions_id_intervention_fk": {
          "name": "intervention_employes_id_intervention_interventions_id_intervention_fk",
          "tableFrom": "intervention_employes",
          "tableTo": "interventions",
          "columnsFrom": [
            "id_intervention"
          ],
          "columnsTo": [
            "id_intervention"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_employes_id_employes_id_intervention_pk": {
          "name": "intervention_employes_id_employes_id_intervention_pk",
          "columns": [
            "id_employes",
            "id_intervention"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaire_commandes": {
      "name": "partenaire_commandes",
      "schema": "",
      "columns": {
        "id_partenaire": {
          "name": "id_partenaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk": {
          "name": "partenaire_commandes_id_partenaire_partenaires_id_partenaire_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "partenaires",
          "columnsFrom": [
            "id_partenaire"
          ],
          "columnsTo": [
            "id_partenaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "partenaire_commandes_id_commande_commandes_id_commande_fk": {
          "name": "partenaire_commandes_id_commande_commandes_id_commande_fk",
          "tableFrom": "partenaire_commandes",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "partenaire_commandes_id_partenaire_id_commande_pk": {
          "name": "partenaire_commandes_id_partenaire_id_commande_pk",
          "columns": [
            "id_partenaire",
            "id_commande"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employe_entrer_exemplaires": {
      "name": "employe_entrer_exemplaires",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "etat_apres": {
          "name": "etat_apres",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_retour": {
          "name": "date_de_retour",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employe_entrer_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "employe_entrer_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "employe_entrer_exemplaires",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "employe_entrer_exemplaires_id_employes_employes_id_employes_fk": {
          "name": "employe_entrer_exemplaires_id_employes_employes_id_employes_fk",
          "tableFrom": "employe_entrer_exemplaires",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "employe_entrer_exemplaires_id_exemplaire_id_employes_pk": {
          "name": "employe_entrer_exemplaires_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employe_prestations": {
      "name": "employe_prestations",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_prestation": {
          "name": "id_prestation",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employe_prestations_id_employes_employes_id_employes_fk": {
          "name": "employe_prestations_id_employes_employes_id_employes_fk",
          "tableFrom": "employe_prestations",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "employe_prestations_id_prestation_prestations_id_prestation_fk": {
          "name": "employe_prestations_id_prestation_prestations_id_prestation_fk",
          "tableFrom": "employe_prestations",
          "tableTo": "prestations",
          "columnsFrom": [
            "id_prestation"
          ],
          "columnsTo": [
            "id_prestation"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "employe_prestations_id_employes_id_prestation_pk": {
          "name": "employe_prestations_id_employes_id_prestation_pk",
          "columns": [
            "id_employes",
            "id_prestation"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention_taches": {
      "name": "intervention_taches",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_tache": {
          "name": "id_tache",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_taches_id_employes_employes_id_employes_fk": {
          "name": "intervention_taches_id_employes_employes_id_employes_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "intervention_taches_id_tache_taches_id_tache_fk": {
          "name": "intervention_taches_id_tache_taches_id_tache_fk",
          "tableFrom": "intervention_taches",
          "tableTo": "taches",
          "columnsFrom": [
            "id_tache"
          ],
          "columnsTo": [
            "id_tache"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "intervention_taches_id_employes_id_tache_pk": {
          "name": "intervention_taches_id_employes_id_tache_pk",
          "columns": [
            "id_employes",
            "id_tache"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employe_sortir_exemplaires": {
      "name": "employe_sortir_exemplaires",
      "schema": "",
      "columns": {
        "id_exemplaire": {
          "name": "id_exemplaire",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "but_usage": {
          "name": "but_usage",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "etat_avant": {
          "name": "etat_avant",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "date_de_sortie": {
          "name": "date_de_sortie",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "site_intervention": {
          "name": "site_intervention",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "commentaire": {
          "name": "commentaire",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employe_sortir_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk": {
          "name": "employe_sortir_exemplaires_id_exemplaire_exemplaires_id_exemplaire_fk",
          "tableFrom": "employe_sortir_exemplaires",
          "tableTo": "exemplaires",
          "columnsFrom": [
            "id_exemplaire"
          ],
          "columnsTo": [
            "id_exemplaire"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "employe_sortir_exemplaires_id_employes_employes_id_employes_fk": {
          "name": "employe_sortir_exemplaires_id_employes_employes_id_employes_fk",
          "tableFrom": "employe_sortir_exemplaires",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "employe_sortir_exemplaires_id_exemplaire_id_employes_pk": {
          "name": "employe_sortir_exemplaires_id_exemplaire_id_employes_pk",
          "columns": [
            "id_exemplaire",
            "id_employes"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_employes": {
      "name": "maintenance_employes",
      "schema": "",
      "columns": {
        "id_employes": {
          "name": "id_employes",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_employes_id_employes_employes_id_employes_fk": {
          "name": "maintenance_employes_id_employes_employes_id_employes_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "id_employes"
          ],
          "columnsTo": [
            "id_employes"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_employes_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_employes",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_employes_id_employes_id_maintenance_pk": {
          "name": "maintenance_employes_id_employes_id_maintenance_pk",
          "columns": [
            "id_employes",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.maintenance_moyens_travail": {
      "name": "maintenance_moyens_travail",
      "schema": "",
      "columns": {
        "id_moyens_de_travail": {
          "name": "id_moyens_de_travail",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_maintenance": {
          "name": "id_maintenance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "date_maintenance": {
          "name": "date_maintenance",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_moyens_de_travail_id_moyens_de_travail_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "moyens_de_travail",
          "columnsFrom": [
            "id_moyens_de_travail"
          ],
          "columnsTo": [
            "id_moyens_de_travail"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk": {
          "name": "maintenance_moyens_travail_id_maintenance_maintenances_id_maintenance_fk",
          "tableFrom": "maintenance_moyens_travail",
          "tableTo": "maintenances",
          "columnsFrom": [
            "id_maintenance"
          ],
          "columnsTo": [
            "id_maintenance"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk": {
          "name": "maintenance_moyens_travail_id_moyens_de_travail_id_maintenance_pk",
          "columns": [
            "id_moyens_de_travail",
            "id_maintenance"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.commande_produits": {
      "name": "commande_produits",
      "schema": "",
      "columns": {
        "id_commande": {
          "name": "id_commande",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "id_produit": {
          "name": "id_produit",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "quantite": {
          "name": "quantite",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "commande_produits_id_commande_commandes_id_commande_fk": {
          "name": "commande_produits_id_commande_commandes_id_commande_fk",
          "tableFrom": "commande_produits",
          "tableTo": "commandes",
          "columnsFrom": [
            "id_commande"
          ],
          "columnsTo": [
            "id_commande"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "commande_produits_id_produit_produits_id_produit_fk": {
          "name": "commande_produits_id_produit_produits_id_produit_fk",
          "tableFrom": "commande_produits",
          "tableTo": "produits",
          "columnsFrom": [
            "id_produit"
          ],
          "columnsTo": [
            "id_produit"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "commande_produits_id_commande_id_produit_pk": {
          "name": "commande_produits_id_commande_id_produit_pk",
          "columns": [
            "id_commande",
            "id_produit"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
File: core/database/migrations/meta/_journal.json
================================================
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1745405309311,
      "tag": "0000_cloudy_fat_cobra",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "7",
      "when": 1745409313787,
      "tag": "0001_worthless_venus",
      "breakpoints": true
    },
    {
      "idx": 2,
      "version": "7",
      "when": 1745843779955,
      "tag": "0002_previous_wasp",
      "breakpoints": true
    }
  ]
}


================================================
File: core/utils/logger.js
================================================
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

// Fonction pour formatter les messages d'erreur
logger.formatError = (error) => {
  if (error instanceof Error) {
    return {
      message: error.message,
      stack: error.stack,
      ...error
    };
  }
  return error;
};

module.exports = logger;


================================================
File: core/utils/swagger.js
================================================
const swaggerJSDoc = require('swagger-jsdoc');

// Configuration avec concatÃ©nation automatique du /api
const serverUrl = (process.env.NODE_ENV === 'production' 
  ? process.env.SERVER_URL_production 
  : process.env.SERVER_URL_development || 'http://localhost:2000') + '/api';

const swaggerDefinition = {
  openapi: '3.0.0',
  info: {
    title: 'API Gestion ERP-DCAT',
    version: '1.0.0',
    description: 'Documentation complÃ¨te de l\'API ',
  },
  servers: [
    {
      url: serverUrl,
      description: process.env.NODE_ENV === 'production' 
        ? 'Serveur de production' 
        : 'Serveur local de dÃ©veloppement'
    },
  ],
  components: {
    securitySchemes: {
      bearerAuth: {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
      }
    }
  },
  security: [{
    bearerAuth: []
  }]
};

const options = {
  swaggerDefinition,
  apis: [
    './modules/**/routes/*.js',
    './modules/**/controllers/*.js'
  ],
};

const swaggerSpec = swaggerJSDoc(options);

module.exports = swaggerSpec;


================================================
File: core/utils/swagger.routes.js
================================================
const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./swagger');

const router = express.Router();

router.use('/docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

module.exports = router;



================================================
File: init-db/nit-multiple-dbs.sh
================================================
#!/bin/bash
# set -e

# # Charge les variables depuis le fichier montÃ©
# source /tmp/.env

# # Debug: Affiche les variables chargÃ©es
# echo "KEYCLOAK_DB_USER: $KEYCLOAK_DB_USER" >&2
# echo "APP_DB_USER: $APP_DB_USER" >&2

# psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
#     CREATE USER "$KEYCLOAK_DB_USER" WITH PASSWORD '$KEYCLOAK_DB_PASSWORD';
#     CREATE DATABASE "$KEYCLOAK_DB_NAME" OWNER "$KEYCLOAK_DB_USER";
    
#     CREATE USER "$APP_DB_USER" WITH PASSWORD '$APP_DB_PASSWORD';
#     CREATE DATABASE "$APP_DB_NAME" OWNER "$APP_DB_USER";
# EOSQL



set -e

# Charge les variables depuis le fichier montÃ©
source /tmp/.env

# Debug: Affiche les variables chargÃ©es
echo "KEYCLOAK_DB_USER: $KEYCLOAK_DB_USER" >&2
echo "APP_DB_USER: $APP_DB_USER" >&2

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL

    CREATE DATABASE "$KEYCLOAK_DB_NAME" OWNER "$KEYCLOAK_DB_USER";
    
    CREATE USER "$APP_DB_USER" WITH PASSWORD '$APP_DB_PASSWORD';
    CREATE DATABASE "$APP_DB_NAME" OWNER "$APP_DB_USER";
EOSQL



# #!/bin/bash
# set -e

# # Charge les variables depuis le fichier montÃ©
# source /tmp/.env

# # Debug: Affiche les variables chargÃ©es
# echo "KEYCLOAK_DB_USER: $KEYCLOAK_DB_USER" >&2
# echo "APP_DB_USER: $APP_DB_USER" >&2

# psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
#     -- CrÃ©ation des utilisateurs
#     CREATE USER "$APP_DB_USER" WITH PASSWORD '$APP_DB_PASSWORD';
    
#     -- CrÃ©ation des bases de donnÃ©es
#     CREATE DATABASE "$KEYCLOAK_DB_NAME";
#     CREATE DATABASE "$APP_DB_NAME";
    
#     -- Attribution des propriÃ©taires des bases
#     \c "$KEYCLOAK_DB_NAME"
#     ALTER DATABASE "$KEYCLOAK_DB_NAME" OWNER TO "$KEYCLOAK_DB_USER";
    
#     \c "$APP_DB_NAME"
#     ALTER DATABASE "$APP_DB_NAME" OWNER TO "$APP_DB_USER";
    
#     -- Accorder des privilÃ¨ges superuser Ã  l'utilisateur Keycloak (nÃ©cessaire pour dblink)
#     ALTER USER "$KEYCLOAK_DB_USER" WITH SUPERUSER;
    
# EOSQL

# # Configuration spÃ©cifique Ã  la base de donnÃ©es Keycloak
# psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$KEYCLOAK_DB_NAME" <<-EOSQL
#     -- Accorder tous les privilÃ¨ges Ã  l'utilisateur Keycloak sur sa base
#     GRANT ALL PRIVILEGES ON SCHEMA public TO "$KEYCLOAK_DB_USER";
    
#     -- Installation de dblink extension dans la base Keycloak
#     CREATE EXTENSION IF NOT EXISTS dblink;
# EOSQL

# # Configuration spÃ©cifique Ã  la base de donnÃ©es d'application
# psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$APP_DB_NAME" <<-EOSQL
#     -- Accorder tous les privilÃ¨ges Ã  l'utilisateur App sur sa base
#     GRANT ALL PRIVILEGES ON SCHEMA public TO "$APP_DB_USER";
# EOSQL



================================================
File: keycloak-setup/backend_cli_id.json
================================================
{
  "clientId": "backend_cli_id",
  "name": "",
  "description": "",
  "surrogateAuthRequired": false,
  "enabled": true,
  "alwaysDisplayInConsole": false,
  "clientAuthenticatorType": "client-secret",
  "redirectUris": [
    "http://localhost:2000/*"
  ],
  "webOrigins": [
    "*"
  ],
  "notBefore": 0,
  "bearerOnly": true,
  "consentRequired": false,
  "standardFlowEnabled": true,
  "implicitFlowEnabled": false,
  "directAccessGrantsEnabled": true,
  "serviceAccountsEnabled": true,
  "publicClient": false,
  "frontchannelLogout": false,
  "protocol": "openid-connect",
  "attributes": {
    "realm_client": "false",
    "oidc.ciba.grant.enabled": "false",
    "backchannel.logout.session.required": "true",
    "post.logout.redirect.uris": "+",
    "oauth2.device.authorization.grant.enabled": "false",
    "backchannel.logout.revoke.offline.tokens": "false",
    "exclude.session.state.from.auth.response": "false"
  },
  "authenticationFlowBindingOverrides": {},
  "fullScopeAllowed": true,
  "nodeReRegistrationTimeout": -1,
  "defaultClientScopes": [
    "web-origins",
    "service_account",
    "acr",
    "profile",
    "roles",
    "basic",
    "email"
  ],
  "optionalClientScopes": [
    "address",
    "phone",
    "organization",
    "offline_access",
    "microprofile-jwt"
  ],
  "access": {
    "view": true,
    "configure": true,
    "manage": true
  }
}


================================================
File: keycloak-setup/frontend_cli_id.json
================================================
{
  "clientId": "frontend_cli_id",
  "surrogateAuthRequired": false,
  "enabled": true,
  "alwaysDisplayInConsole": false,
  "clientAuthenticatorType": "client-secret",
  "redirectUris": [
    "http://localhost:2000/*",
    "undefined/*",
    "http://localhost:5173/*"
  ],
  "webOrigins": [
    "*"
  ],
  "notBefore": 0,
  "bearerOnly": false,
  "consentRequired": false,
  "standardFlowEnabled": true,
  "implicitFlowEnabled": false,
  "directAccessGrantsEnabled": true,
  "serviceAccountsEnabled": false,
  "publicClient": true,
  "frontchannelLogout": false,
  "protocol": "openid-connect",
  "attributes": {
    "realm_client": "false",
    "post.logout.redirect.uris": "+",
    "exclude.session.state.from.auth.response": "false"
  },
  "authenticationFlowBindingOverrides": {},
  "fullScopeAllowed": true,
  "nodeReRegistrationTimeout": -1,
  "protocolMappers": [
    {
      "name": "backend-audience",
      "protocol": "openid-connect",
      "protocolMapper": "oidc-audience-mapper",
      "consentRequired": false,
      "config": {
        "included.client.audience": "backend_cli_id",
        "id.token.claim": "true",
        "lightweight.claim": "false",
        "access.token.claim": "true",
        "introspection.token.claim": "true"
      }
    }
  ],
  "defaultClientScopes": [
    "web-origins",
    "acr",
    "profile",
    "roles",
    "basic",
    "email"
  ],
  "optionalClientScopes": [
    "address",
    "phone",
    "organization",
    "offline_access",
    "microprofile-jwt"
  ],
  "access": {
    "view": true,
    "configure": true,
    "manage": true
  }
}


================================================
File: keycloak-setup/keycloak-setup.js
================================================
require('dotenv').config();


const KeycloakAdminClient = require('@keycloak/keycloak-admin-client').default;
const fs = require('fs');
const path = require('path');

// Configuration validation
const REQUIRED_ENV_VARS = [
  'KEYCLOAK_URL',
  'KEYCLOAK_ADMIN',
  'KEYCLOAK_ADMIN_PASSWORD',
  'KEYCLOAK_REALM'
];

// Verify all required variables are present
for (const envVar of REQUIRED_ENV_VARS) {
  if (!process.env[envVar]) {
    console.error(`❌ Missing environment variable: ${envVar}`);
    process.exit(1);
  }
}

const keycloakConfig = {
  baseUrl: process.env.KEYCLOAK_URL,
  realmName: 'master'
};

const adminClient = new KeycloakAdminClient(keycloakConfig);

const clients = [
  {
    file: 'backend_cli_id.json',
    type: 'backend'
  },
  {
    file: 'frontend_cli_id.json',
    type: 'frontend'
  }
];

const roles = [
  'gestion_adminitartive',
  'finance',
  'comptabilté',
  'rh',
  'stock_refference',
  'stock_entree_sortie',
  'stock_achat',
  'gestion_intervention_projet',
  'outil_reference',
  'outils_entre_sortie_retour',
  'maintenance_prestation',
  'marketing',
];

async function setupKeycloak() {
  try {
    console.info('🔑 Authenticating to Keycloak...');
    
    await adminClient.auth({
      username: process.env.KEYCLOAK_ADMIN,
      password: process.env.KEYCLOAK_ADMIN_PASSWORD,
      grantType: 'password',
      clientId: 'admin-cli'
    });

    console.info('✅ Successfully authenticated');

    // Realm setup
    console.info(`🔄 Checking realm ${process.env.KEYCLOAK_REALM}...`);
    const realmExists = (await adminClient.realms.find())
      .some(r => r.realm === process.env.KEYCLOAK_REALM);

    if (!realmExists) {
      await adminClient.realms.create({
        realm: process.env.KEYCLOAK_REALM,
        enabled: true,
        displayName: `${process.env.KEYCLOAK_REALM} Realm`,
        loginTheme: "keycloak",
        accountTheme: "keycloak"
      });
      console.info(`✨ Created realm: ${process.env.KEYCLOAK_REALM}`);
    } else {
      console.info(`ℹ️ Realm ${process.env.KEYCLOAK_REALM} already exists`);
    }

    // Clients setup
    for (const client of clients) {
      const clientConfig = JSON.parse(fs.readFileSync(path.join(__dirname, client.file), 'utf8'));
      console.info(`🔍 Checking client ${clientConfig.clientId}...`);
      const clientExists = (await adminClient.clients.find({
        realm: process.env.KEYCLOAK_REALM,
        clientId: clientConfig.clientId
      })).length > 0;

      if (!clientExists) {
        await adminClient.clients.create({
          realm: process.env.KEYCLOAK_REALM,
          ...clientConfig
        });
        console.info(`🎯 Created client: ${clientConfig.clientId}`);
      } else {
        console.info(`ℹ️ Client ${clientConfig.clientId} already exists`);
      }
    }

    // Roles setup
    for (const role of roles) {
      console.info(`🔍 Checking role ${role}...`);
      const roleExists = await adminClient.roles.findOneByName({
        realm: process.env.KEYCLOAK_REALM,
        name: role
      });

      if (!roleExists) {
        await adminClient.roles.create({
          realm: process.env.KEYCLOAK_REALM,
          name: role
        });
        console.info(`🎯 Created role: ${role}`);
      } else {
        console.info(`ℹ️ Role ${role} already exists`);
      }
    }

    console.info('🏁 Keycloak setup completed successfully');
  } catch (error) {
    console.error('💥 Keycloak setup failed:', error);
    process.exit(1);
  }
}

// Execute setup
setupKeycloak();






================================================
File: media/documents/technique/livrables/azerty_1745604679689.docx
================================================
[Non-text file]





================================================
File: modules/Administration&Finance/FinanceCompta/controllers/doc_Fc.controller.js
================================================
const fs = require('fs');
const path = require('path');
const documentService = require('../services/doc_FC.service');

/**
 * RÃ©cupÃ¨re tous les documents
 */
const getAllDocuments = async (req, res) => {
    try {
        const documents = await documentService.getDocument();
        
        if (!documents || documents.length === 0) {
            return res.status(404).json({
                success: false,
                message: "Aucun document trouvÃ©"
            });
        }
        
        return res.status(200).json({
            success: true,
            count: documents.length,
            data: documents
        });
    } catch (error) {
        console.error("Erreur lors de la rÃ©cupÃ©ration des documents:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur lors de la rÃ©cupÃ©ration des documents",
            error: error.message
        });
    }
};

/**
 * RÃ©cupÃ¨re un document par sa nature
 */
const getDocumentByNature = async (req, res) => {
    try {
        const { id_nature_document } = req.params;
        
        if (!id_nature_document || isNaN(parseInt(id_nature_document))) {
            return res.status(400).json({
                success: false,
                message: "ID de nature de document invalide"
            });
        }
        
        const document = await documentService.getDocumentbyNature(parseInt(id_nature_document));
        
        if (!document) {
            return res.status(404).json({
                success: false,
                message: `Aucun document trouvÃ© pour la nature d'ID ${id_nature_document}`
            });
        }
        
        return res.status(200).json({
            success: true,
            data: document
        });
    } catch (error) {
        console.error("Erreur lors de la rÃ©cupÃ©ration du document par nature:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur lors de la rÃ©cupÃ©ration du document par nature",
            error: error.message
        });
    }
};

/**
 * Ajoute un nouveau document
 */
const addDocument = async (req, res) => {
    try {
        // VÃ©rification si un fichier a Ã©tÃ© uploadÃ©
        if (!req.file) {
            return res.status(400).json({
                success: false,
                message: "Aucun fichier n'a Ã©tÃ© fourni"
            });
        }

        const { 
            libelle_document, 
            classification_document, 
            etat_document,  
            id_employes, 
            id_nature_document,
        } = req.body;

        // VÃ©rifications des donnÃ©es obligatoires
        if (!libelle_document) {
            // Supprimer le fichier uploadÃ©
            fs.unlinkSync(req.file.path);
            return res.status(400).json({
                success: false,
                message: "Le libellÃ© du document est obligatoire"
            });
        }

        // CrÃ©ation du chemin relatif
        const relativePath = req.file.path
            .replace(process.cwd(), '')
            .replace(/\\/g, '/')
            .replace(/^\//, '');

        const document = {
            libelle_document,
            classification_document: classification_document || "finance",
            lien_document: relativePath,
            etat_document: etat_document || "actif",
            id_employes: id_employes ? parseInt(id_employes) : null,
            id_nature_document: id_nature_document ? parseInt(id_nature_document) : null
        };

        const savedDocument = await documentService.addDocument(document);
        
        return res.status(201).json({
            success: true,
            message: "Document ajoutÃ© avec succÃ¨s",
            data: savedDocument
        });
    } catch (error) {
        // Supprimer le fichier en cas d'Ã©chec
        if (req.file && req.file.path) {
            fs.unlink(req.file.path, (err) => {
                if (err) console.error("Erreur lors de la suppression du fichier:", err);
            });
        }
        
        console.error("Erreur lors de l'ajout du document:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur lors de l'ajout du document",
            error: error.message
        });
    }
};

/**
 * Met Ã  jour un document existant
 */
const updateDocument = async (req, res) => {
    try {
        const { id } = req.params;
        
        if (!id || isNaN(parseInt(id))) {
            return res.status(400).json({
                success: false,
                message: "ID de document invalide"
            });
        }

        // DonnÃ©es Ã  mettre Ã  jour
        const updateData = { ...req.body };
        
        // Si un nouveau fichier est fourni
        if (req.file) {
            // RÃ©cupÃ©rer l'ancien lien avant la mise Ã  jour
            const oldDocument = await documentService.getDocumentbyId(parseInt(id));
            
            if (!oldDocument) {
                // Supprimer le nouveau fichier si l'ancien document n'existe pas
                fs.unlinkSync(req.file.path);
                return res.status(404).json({
                    success: false,
                    message: `Document avec l'ID ${id} non trouvÃ©`
                });
            }
            
            // Mettre Ã  jour le lien vers le nouveau fichier (chemin relatif)
            const relativePath = req.file.path
                .replace(process.cwd(), '')
                .replace(/\\/g, '/')
                .replace(/^\//, '');
            updateData.lien_document = relativePath;
            
            // Supprimer l'ancien fichier
            if (oldDocument.lien_document) {
                const oldFilePath = path.join(process.cwd(), oldDocument.lien_document);
                if (fs.existsSync(oldFilePath)) {
                    fs.unlinkSync(oldFilePath);
                }
            }
        }
        
        // Nettoyer les champs vides pour Ã©viter les erreurs SQL
        Object.keys(updateData).forEach(key => {
            if (updateData[key] === "") {
                delete updateData[key];
            }
        });

        // Mettre Ã  jour la date de modification
        updateData.updated_at = new Date();
        
        // Convertir les IDs en entiers
        if (updateData.id_employes) updateData.id_employes = parseInt(updateData.id_employes);
        if (updateData.id_nature_document) updateData.id_nature_document = parseInt(updateData.id_nature_document);
        
        const updatedDocument = await documentService.updateDocument(parseInt(id), updateData);
        
        if (!updatedDocument) {
            // Supprimer le nouveau fichier si la mise Ã  jour a Ã©chouÃ©
            if (req.file) {
                fs.unlinkSync(req.file.path);
            }
            return res.status(404).json({
                success: false,
                message: `Document avec l'ID ${id} non trouvÃ©`
            });
        }
        
        return res.status(200).json({
            success: true,
            message: "Document mis Ã  jour avec succÃ¨s",
            data: updatedDocument
        });
    } catch (error) {
        // Supprimer le nouveau fichier en cas d'erreur
        if (req.file && req.file.path) {
            fs.unlink(req.file.path, (err) => {
                if (err) console.error("Erreur lors de la suppression du fichier:", err);
            });
        }
        
        console.error("Erreur lors de la mise Ã  jour du document:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur lors de la mise Ã  jour du document",
            error: error.message
        });
    }
};

/**
 * Supprime un document
 */
const deleteDocument = async (req, res) => {
    try {
        const { id } = req.params;
        
        if (!id || isNaN(parseInt(id))) {
            return res.status(400).json({
                success: false,
                message: "ID de document invalide"
            });
        }
        
        // RÃ©cupÃ©rer le document avant suppression pour obtenir le chemin du fichier
        const documentToDelete = await documentService.getDocumentbyId(parseInt(id));
        
        if (!documentToDelete) {
            return res.status(404).json({
                success: false,
                message: `Document avec l'ID ${id} non trouvÃ©`
            });
        }
        
        // Supprimer le document de la base de donnÃ©es
        const deletedDocument = await documentService.deleteDocument(parseInt(id));
        
        if (!deletedDocument) {
            return res.status(404).json({
                success: false,
                message: `Erreur lors de la suppression du document avec l'ID ${id}`
            });
        }
        
        // Supprimer le fichier physique
        if (documentToDelete.lien_document) {
            const filePath = path.join(process.cwd(), documentToDelete.lien_document);
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
            }
        }
        
        return res.status(200).json({
            success: true,
            message: "Document supprimÃ© avec succÃ¨s",
            data: deletedDocument
        });
    } catch (error) {
        console.error("Erreur lors de la suppression du document:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur lors de la suppression du document",
            error: error.message
        });
    }
};

module.exports = {
    getAllDocuments,
    getDocumentByNature,
    addDocument,
    updateDocument,
    deleteDocument
};


================================================
File: modules/Administration&Finance/FinanceCompta/routes/doc_FC.route.js
================================================
const doc_FCController = require('../controllers/doc_Fc.controller');
const express = require('express');
const router = express.Router();
const upload = require('../../../utils/middleware/uploadMiddleware');
const path = require('path');
const fs = require('fs');

const UPLOAD_PATHS = {
  INTERVENTIONS: 'media/documents/administration/finance&compta'
};

// Middleware pour crÃ©er le dossier d'upload si nÃ©cessaire
const prepareUploadPath = (req, res, next) => {
  try {
    // DÃ©finir et crÃ©er le chemin avant l'upload
    const uploadPath = path.join(process.cwd(), UPLOAD_PATHS.INTERVENTIONS);
    

    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    req.uploadPath = uploadPath;
    next();
  } catch (error) {
    next(error);
  }
};

router.post('/ajouter', 
  prepareUploadPath,
  upload.single("document"), 
  doc_FCController.addDocument
);

router.get('/', doc_FCController.getAllDocuments);

router.get('/nature/:id_nature_document', doc_FCController.getDocumentByNature);

router.put('/modifier/:id', 
  prepareUploadPath,
  upload.single("document"),
  doc_FCController.updateDocument
);

router.delete('/supprimer/:id', doc_FCController.deleteDocument);

module.exports = router;


================================================
File: modules/Administration&Finance/FinanceCompta/services/doc_FC.service.js
================================================
const {eq} = require('drizzle-orm');
const {documents} = require('../../../../core/database/models');
const {db} = require('../../../../core/database/config');


const getDocument = async()=> {
    return await db
    .select()
    .from(documents);
}

const getDocumentbyId = async(id)=> {
    const [result] = await db
    .select()
    .from(documents)
    .where(eq(documents.id_documents, id));
    return result;
}

const getDocumentbyNature = async(id)=> {
    const result = await db
    .select()
    .from(documents)
    .where(eq(documents.id_nature_document, id));
    return result;
}

const addDocument = async(data)=> {
    const [result] = await db
    .insert(documents)
    .values(data)
    .returning();
    return result;
}

const updateDocument = async(id, data)=> {
    const [result] = await db
    .update(documents)
    .set({...data , updated_at: new Date()})
    .where(eq(documents.id_documents, id))
    .returning();
    return result;
}

const deleteDocument = async(id)=> {
    const [result] = await db
    .delete(documents)
    .where(eq(documents.id_documents, id))
    .returning();
    return result;
}

module.exports = {
    getDocument,
    getDocumentbyNature,
    getDocumentbyId,
    addDocument,
    updateDocument,
    deleteDocument
}


================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/contrat.controller.js
================================================
const contratService = require('../services/contrat.service');
const logger = require('../../../../core/utils/logger');
const fs = require('fs');

/**
 * Suppression sÃ©curisÃ©e d'un fichier
 */
async function safeUnlink(filePath) {
    try {
        await fs.promises.unlink(filePath);
        logger.info(`Fichier supprimÃ©: ${filePath}`);
    } catch (err) {
        logger.error(`Erreur suppression fichier ${filePath}:`, { error: err });
    }
}


const createContrats = async (req, res) => {
    try {
        logger.info("DÃ©but crÃ©ation contrat");
        logger.debug("Body reÃ§u:", { body: { ...req.body } });
        logger.debug("Fichier reÃ§u:", {
            file: req.file ? {
                filename: req.file.filename,
                path: req.file.path,
                size: req.file.size
            } : "Aucun fichier"
        });

        const data = req.body;
        if (!data || Object.keys(data).length === 0) {
            if (req.file) await safeUnlink(req.file.path);
            return res.status(400).json({ message: "DonnÃ©es contrat requises" });
        }

        const requiredFields = ['date_debut', 'date_fin', 'id_partenaire'];
        const missingFields = requiredFields.filter(field => !data[field]);
        
        if (missingFields.length > 0) {
            if (req.file) await safeUnlink(req.file.path);
            return res.status(400).json({ 
                message: "DonnÃ©es incomplÃ¨tes", 
                details: `Champs manquants: ${missingFields.join(', ')}` 
            });
        }

        const contratData = {
            nom_contrat: data.nom_contrat,
            reference: data.reference,
            date_debut: data.date_debut,
            duree_contrat: data.duree_contrat,
            date_fin: data.date_fin,
            statut_contrat: data.statut,
            id_partenaire: data.id_partenaire ? parseInt(data.id_partenaire) : null,
            type_contrat: data.type_contrat,
        };
        
        const contrat = await contratService.createContrat (contratData);

        
        if (!contrat) {
            if (req.file) await safeUnlink(req.file.path);
            return res.status(500).json({ message: "Erreur crÃ©ation contrat" });
        }

        const contratObj = Array.isArray(contrat) ? contrat[0] : contrat;
        const contratId = contratObj?.id_contrat;

        if (!contratId) {
            if (req.file) await safeUnlink(req.file.path);
            return res.status(500).json({ message: "Erreur: ID contrat manquant" });
        }

        let documentResult = null;
        if (req.file) {
            const { libelle_document, classification_document } = req.body;
            
            if (!libelle_document) {
                await safeUnlink(req.file.path);
                return res.status(400).json({ message: "LibellÃ© document obligatoire" });
            }

            const relativePath = req.file.path
                .replace(process.cwd(), '')
                .replace(/\\/g, '/')
                .replace(/^\//, '');

            const documentData = {
                libelle_document,
                classification_document: classification_document || "Contrat",
                lien_document: relativePath,
                etat_document: req.body.etat_document || "Actif",
                date_document: new Date().toISOString().split('T')[0],
                id_contrat: contratId,
                id_nature_document: data.id_nature_document ? parseInt(data.id_nature_document) : null,
            };

            documentResult = await contratService.addDocument(documentData);
            if (!documentResult) {
                await safeUnlink(req.file.path);
                return res.status(500).json({ message: "Contrat crÃ©Ã© mais document non ajoutÃ©" });
            }
        }
        
        res.status(201).json({
            success: true,
            message: documentResult ? "Contrat et document ajoutÃ©s" : "Contrat ajoutÃ©",
            data: { contrat, document: documentResult }
        });
    } catch (error) {
        logger.error("Erreur crÃ©ation contrat", { 
            error: {
                message: error.message,
                stack: error.stack,
                code: error.code
            }
        });
        
        if (req.file && req.file.path) {
            await safeUnlink(req.file.path);
        }
        
        let errorMessage = "Erreur interne";
        let statusCode = 500;
        
        if (error.code === '23505') {
            errorMessage = "Contrat dÃ©jÃ  existant";
            statusCode = 409;
        } else if (error.code === '23503') {
            errorMessage = "RÃ©fÃ©rence invalide";
            statusCode = 400;
        } else if (error.message && error.message.includes("invalid input")) {
            errorMessage = "DonnÃ©es invalides";
            statusCode = 400;
        }
        
        res.status(statusCode).json({
            success: false,
            message: errorMessage,
            details: error.message,
            type: error.name || "UnknownError"
        });
    }
};

const getAllContrats = async (req, res) => {
    try {
        const contrats = await contratService.getContrats();
        
        return res.status(200).json({
            success: true,
            count: contrats.length,
            data: contrats
        });
    } catch (error) {
        logger.error("Erreur rÃ©cupÃ©ration contrats", { 
            error: { message: error.message, stack: error.stack }
        });
        
        return res.status(500).json({
            success: false,
            message: 'Erreur rÃ©cupÃ©ration contrats',
            details: error.message
        });
    }
};

const getContratsByPartenaire = async (req, res) => {
    try {
        const { id } = req.params;
        
        if (!id) {
            return res.status(400).json({ success: false, message: "ID partenaire requis" });
        }

        const contrats = await contratService.getContratsbyPartenaire(id);
        
        if (!contrats || (Array.isArray(contrats) && contrats.length === 0)) {
            return res.status(404).json({
                success: false,
                message: `Aucun contrat trouvÃ© pour partenaire ID: ${id}`
            });
        }

        return res.status(200).json({
            success: true,
            count: Array.isArray(contrats) ? contrats.length : 1,
            data: contrats
        });
    } catch (error) {
        logger.error(`Erreur rÃ©cupÃ©ration contrats partenaire ID: ${req.params.id}`, { 
            error: { message: error.message, stack: error.stack }
        });
        
        return res.status(500).json({
            success: false,
            message: 'Erreur rÃ©cupÃ©ration contrats partenaire',
            details: error.message
        });
    }
};

const getContratById = async (req, res) => {
    try {
        const { id } = req.params;
        if (!id) {
            return res.status(400).json({ success: false, message: "ID contrat requis" });
        }
        const contrat = await contratService.getContratById(id); 

        if (!contrat) {
            return res.status(404).json({
                success: false,
                message: `Contrat ID: ${id} non trouvÃ©`
            });
        }

        return res.status(200).json({
            success: true,
            message: 'Contrat trouvÃ©',
            data: contrat
        });
    } catch (error) {   

        logger.error(`Erreur rÃ©cupÃ©ration contrat ID: ${req.params.id}`, {
            error: { message: error.message, stack: error.stack }
        });
        return res.status(500).json({
            success: false,
            message: 'Erreur rÃ©cupÃ©ration contrat',
            details: error.message
        });
    }
};

const updateContrat = async (req, res) => {
    try {
        const { id } = req.params;
        
        if (!id) {
            return res.status(400).json({ success: false, message: "ID contrat requis" });
        }
        
        if (!req.body || Object.keys(req.body).length === 0) {
            return res.status(400).json({ success: false, message: "Aucune donnÃ©e fournie" });
        }

        const updateData = { ...req.body };
        
        if (updateData.id_partenaire) updateData.id_partenaire = parseInt(updateData.id_partenaire);
        if (updateData.montant) updateData.montant = parseFloat(updateData.montant);
        updateData.updated_at = new Date();

        const result = await contratService.updateContrat(id, updateData);
        
        if (!result) {
            return res.status(404).json({
                success: false,
                message: `Contrat ID: ${id} non trouvÃ©`
            });
        }

        return res.status(200).json({
            success: true,
            message: 'Contrat mis Ã  jour',
            data: result
        });
    } catch (error) {
        logger.error(`Erreur mise Ã  jour contrat ID: ${req.params.id}`, { 
            error: { message: error.message, stack: error.stack, code: error.code }
        });
        
        let errorMessage = "Erreur mise Ã  jour contrat";
        let statusCode = 500;
        
        if (error.code === '23505') {
            errorMessage = "Contrat avec ces informations dÃ©jÃ  existant";
            statusCode = 409;
        } else if (error.code === '23503') {
            errorMessage = "RÃ©fÃ©rence invalide";
            statusCode = 400;
        }
        
        return res.status(statusCode).json({
            success: false,
            message: errorMessage,
            details: error.message
        });
    }
};

const deleteContrat = async (req, res) => {
    try {
        const { id } = req.params;
        
        if (!id) {
            return res.status(400).json({ success: false, message: "ID contrat requis" });
        }

        const result = await contratService.deleteContrat(id);
        
        if (!result) {
            return res.status(404).json({
                success: false,
                message: `Contrat ID: ${id} non trouvÃ©`
            });
        }

        return res.status(200).json({
            success: true,
            message: 'Contrat supprimÃ©',
            data: result
        });
    } catch (error) {
        logger.error(`Erreur suppression contrat ID: ${req.params.id}`, { 
            error: { message: error.message, stack: error.stack, code: error.code }
        });
        
        let errorMessage = "Erreur suppression contrat";
        let statusCode = 500;
        
        if (error.code === '23503') {
            errorMessage = "Impossible de supprimer ce contrat (rÃ©fÃ©rences existantes)";
            statusCode = 400;
        }
        
        return res.status(statusCode).json({
            success: false,
            message: errorMessage,
            details: error.message
        });
    }
};

module.exports = {
    createContrats, // <-- corriger ici
    getAllContrats,
    getContratsByPartenaire,
    updateContrat,
    deleteContrat,
    getContratById
};



================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/entite.controller.js
================================================
const entiteService = require('../services/entite.service');

const createEntite = async (req, res) => {
    try {   
        const entite = await entiteService.createEntite(req.body);
        res
        .status(201)
        .json(entite);
    }
    catch (error) {
        console.error("Error creating entite:", error);
        res
        .status(500)
        .json({ message: "Internal server error" });
    }
}

const getEntites = async (req, res) => {
    try {
        const entites = await entiteService.getEntites();
        res
        .status(200)
        .json(entites);
    } catch (error) {
        console.error("Error fetching entites:", error);
        res
        .status(500)
        .json({ message: "Internal server error" });
    }
}

const getEntiteById = async (req, res) => {
    try {                   
        const { id } = req.params;
        const entite = await entiteService.getEntiteById(id);
        if (!entite) {
            return res.status(404).json({ message: "Entite not found" });
        }
        res.status(200).json(entite);
    } catch (error) {
        console.error("Error fetching entite by ID:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}


const updateEntite = async (req, res) => {
    try {
        const { id } = req.params;
        const updatedEntite = await entiteService.updateEntite(id, req.body);
        if (!updatedEntite) {
            return res.status(404).json({ message: "Entite not found" });
        }
        res.status(200).json(updatedEntite);
    } catch (error) {
        console.error("Error updating entite:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}
const deleteEntite = async (req, res) => {
    try {
        const { id } = req.params;
        const deletedEntite = await entiteService.deleteEntite(id);
        if (!deletedEntite) {
            return res.status(404).json({ message: "Entite not found" });
        }
        res.status(200).json(deletedEntite);
    } catch (error) {
        console.error("Error deleting entite:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

module.exports = {
    createEntite,
    getEntites,
    getEntiteById,
    updateEntite,
    deleteEntite
}


================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/interlocuteur.controller.js
================================================
const interlocuteurService = require('../services/interlocuteur.service');

const createInterlocuteur = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.createInterlocuteur(req.body);
        res.status(201).json(interlocuteur);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const getInterlocuteurs = async (req, res) => {
    try {
        const interlocuteurs = await interlocuteurService.getInterlocuteurs();
        res.status(200).json(interlocuteurs);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const getInterlocuteurbyPartenaire = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.getInterlocuteurbyPartenaire(req.params.id);
        if (!interlocuteur) {
            return res.status(404).json({ message: 'Interlocuteur not found' });
        }
        res.status(200).json(interlocuteur);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const getInterlocuteurById = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.getInterlocuteurById(req.params.id);
        if (!interlocuteur) {
            return res.status(404).json({ message: 'Interlocuteur not found' });
        }
        res.status(200).json(interlocuteur);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const updateInterlocuteur = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.updateInterlocuteur(req.params.id, req.body);
        if (!interlocuteur) {
            return res.status(404).json({ message: 'Interlocuteur not found' });
        }
        res.status(200).json(interlocuteur);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

const deleteInterlocuteur = async (req, res) => {
    try {
        const interlocuteur = await interlocuteurService.deleteInterlocuteur(req.params.id);
        if (!interlocuteur) {
            return res.status(404).json({ message: 'Interlocuteur not found' });
        }
        res.status(200).json({ message: 'Interlocuteur deleted successfully' });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
}

module.exports = {
    createInterlocuteur,
    getInterlocuteurs,
    getInterlocuteurbyPartenaire,
    getInterlocuteurById,
    updateInterlocuteur,
    deleteInterlocuteur
}


================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/nature.controller.js
================================================
const natureService = require('../services/nature.service');

const createNature = async (req, res) => {
    try {
        const data = req.body;
        const result = await natureService.createNature(data);
        res.status(201).json(result);
    } catch (error) {
        console.error("Error creating nature:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const getAllNatures = async (req, res) => {
    try {
        const result = await natureService.getAllNatures();
        res.status(200).json(result);
    } catch (error) {
        console.error("Error fetching natures:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const getNaturebyId = async (req, res) => {
    try {
        const id = req.params.id;
        const result = await natureService.getNaturebyId(id);
        if (result.length === 0) {
            return res.status(404).json({ message: "Nature not found" });
        }
        res.status(200).json(result[0]);
    } catch (error) {
        console.error("Error fetching nature by ID:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const updateNature = async (req, res) => {
    try {
        const id = req.params.id;
        const data = req.body;
        const result = await natureService.updateNature(id, data);
        if (result.length === 0) {
            return res.status(404).json({ message: "Nature not found" });
        }
        res.status(200).json(result[0]);
    } catch (error) {
        console.error("Error updating nature:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}

const deleteNature = async (req, res) => {
    try {
        const id = req.params.id;
        const result = await natureService.deleteNature(id);
        if (result.length === 0) {
            return res.status(404).json({ message: "Nature not found" });
        }
        res.status(200).json({ message: "Nature deleted successfully" });
    } catch (error) {
        console.error("Error deleting nature:", error);
        res.status(500).json({ message: "Internal server error" });
    }
}


module.exports = {
    createNature,
    getAllNatures,
    getNaturebyId,
    updateNature,
    deleteNature
}



================================================
File: modules/Administration&Finance/GestionAdministrative/controllers/partenaire.controller.js
================================================
// const partenaireService = require("../services/partenaire.service");

// const createPartenaire = async (req, res) => {
//   try {
//     const result = await partenaireService.createPartenaire(req.body);
//     return res.status(201).json(result);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// const getPartenaires = async (req, res) => {
//   try {
//     const result = await partenaireService.getPartenaires();
//     return res.status(200).json(result || []);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// const getPartenaireById = async (req, res) => {
//   try {
//     const id = parseInt(req.params.id);
//     if (isNaN(id)) {
//       return res.status(400).json({ error: "ID invalide" });
//     }
//     const result = await partenaireService.getPartenaireById(Number(id));
//     return res.json(result);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// const updatePartenaire = async (req, res) => {
//   try {
//     const id = parseInt(req.params.id);
//     if (isNaN(id)) {
//       return res.status(400).json({ error: "ID invalide" });
//     }
//     const result = await partenaireService.updatePartenaire(id);
//     return res.json(result);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// const deletePartenaire = async (req, res) => {
//   try {
//     const id = parseInt(req.params.id);
//     if (isNaN(id)) {
//       return res.status(400).json({ error: "ID invalide" });
//     }
//     const result = await partenaireService.deletePartenaire(id);
//     return res.json(result);
//   } catch (error) {
//     res
//       .status(500)
//       .json({ error: "une erreur est survenue", details: error.message });
//   }
// };

// module.exports = {
//   createPartenaire,
//   getPartenaires,
//   getPartenaireById,
//   updatePartenaire,
//   deletePartenaire,
// };
//bonjour

const partenaireService = require("../services/partenaire.service");

const createPartenaire = async (req, res) => {
  try {
    const result = await partenaireService.createPartenaire(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

const getPartenaires = async (req, res) => {
  try {
    const result = await partenaireService.getPartenaires();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

const getPartenairebyType = async (req,res) =>{
  try{
    const type = req.params.type;
    const result = await partenaireService.getPartenaireByType(type);
    return res.status(200).json(result || []);
  }
  catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

const updatePartenaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await partenaireService.updatePartenaire(id, req.body);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

const deletePartenaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await partenaireService.deletePartenaire(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
}

module.exports = {
  createPartenaire,
  getPartenaires,
  getPartenairebyType,
  updatePartenaire,
  deletePartenaire,
};



================================================
File: modules/Administration&Finance/GestionAdministrative/routes/contrat.route.js
================================================
const path = require('path');
const fs = require('fs');
const contratcontroller = require('../controllers/contrat.controller');
const express = require('express');
const router = express.Router();
const upload = require('../../../utils/middleware/uploadMiddleware');

const UPLOAD_PATHS = {
  CONTRATS: 'media/documents/administration/contrat'
};

// Middleware pour crÃ©er le dossier d'upload si nÃ©cessaire
const prepareUploadPath = (req, res, next) => {
  try {
    // DÃ©finir et crÃ©er le chemin avant l'upload
    const uploadPath = path.join(process.cwd(), UPLOAD_PATHS.CONTRATS);
    

    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    req.uploadPath = uploadPath;
    next();
  } catch (error) {
    next(error);
  }
};

router.post("/",
    prepareUploadPath,
    upload.single("document"),
    contratcontroller.createContrats // <-- assurez-vous d'utiliser le mÃªme nom que dans l'export
);

router.get("/", contratcontroller.getAllContrats);
router.get("/:id", contratcontroller.getContratById);
router.put("/:id", contratcontroller.updateContrat);
router.delete("/:id", contratcontroller.deleteContrat);

module.exports = router;


================================================
File: modules/Administration&Finance/GestionAdministrative/routes/entite.route.js
================================================
const entiteController = require('../controllers/entite.controller');
const express = require('express');
const router = express.Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     Entite:
 *       type: object
 *       required:
 *         - name
 *       properties:
 *         id:
 *           type: string
 *           description: ID auto-gÃ©nÃ©rÃ© de l'entitÃ©
 *         name:
 *           type: string
 *           description: Nom de l'entitÃ©
 *         description:
 *           type: string
 *           description: Description de l'entitÃ©
 *         createdAt:
 *           type: string
 *           format: date-time
 *           description: Date de crÃ©ation
 *         updatedAt:
 *           type: string
 *           format: date-time
 *           description: Date de derniÃ¨re mise Ã  jour
 *       example:
 *         id: d5fE_asz
 *         name: Exemple d'entitÃ©
 *         description: Une description dÃ©taillÃ©e de l'entitÃ©
 *         createdAt: 2023-01-01T00:00:00.000Z
 *         updatedAt: 2023-01-01T00:00:00.000Z
 */

/**
 * @swagger
 * /entites:
 *   post:
 *     summary: CrÃ©er une nouvelle entitÃ©
 *     tags: [Entites]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/Entite'
 *     responses:
 *       201:
 *         description: EntitÃ© crÃ©Ã©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Entite'
 *       500:
 *         description: Erreur serveur
 */
router.post('/', entiteController.createEntite);

/**
 * @swagger
 * /entites:
 *   get:
 *     summary: RÃ©cupÃ©rer toutes les entitÃ©s
 *     tags: [Entites]
 *     responses:
 *       200:
 *         description: Liste des entitÃ©s
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Entite'
 *       500:
 *         description: Erreur serveur
 */
router.get('/', entiteController.getEntites);

/**
 * @swagger
 * /entites/{id}:
 *   get:
 *     summary: RÃ©cupÃ©rer une entitÃ© par son ID
 *     tags: [Entites]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID de l'entitÃ©
 *     responses:
 *       200:
 *         description: DÃ©tails de l'entitÃ©
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Entite'
 *       404:
 *         description: EntitÃ© non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.get('/:id', entiteController.getEntiteById);

/**
 * @swagger
 * /entites/{id}:
 *   put:
 *     summary: Mettre Ã  jour une entitÃ© existante
 *     tags: [Entites]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID de l'entitÃ© Ã  mettre Ã  jour
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/Entite'
 *     responses:
 *       200:
 *         description: EntitÃ© mise Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Entite'
 *       404:
 *         description: EntitÃ© non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.put('/:id', entiteController.updateEntite);

/**
 * @swagger
 * /entites/{id}:
 *   delete:
 *     summary: Supprimer une entitÃ©
 *     tags: [Entites]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID de l'entitÃ© Ã  supprimer
 *     responses:
 *       200:
 *         description: EntitÃ© supprimÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Entite'
 *       404:
 *         description: EntitÃ© non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.delete('/:id', entiteController.deleteEntite);

module.exports = router;



================================================
File: modules/Administration&Finance/GestionAdministrative/routes/interlocuteur.route.js
================================================
const interlocuteurController = require('../controllers/interlocuteur.controller');
const express = require('express');
const router = express.Router();

router.post("/", interlocuteurController.createInterlocuteur);
router.get("/", interlocuteurController.getInterlocuteurs);
router.get("/partenaire/:id", interlocuteurController.getInterlocuteurbyPartenaire);
router.get("/:id", interlocuteurController.getInterlocuteurById);
router.put("/:id", interlocuteurController.updateInterlocuteur);
router.delete("/:id", interlocuteurController.deleteInterlocuteur);

module.exports = router;




================================================
File: modules/Administration&Finance/GestionAdministrative/routes/nature.route.js
================================================
const natureController = require('../controllers/nature.controller');
const express = require('express');
const router = express.Router();


router.post('/', natureController.createNature);
router.get('/', natureController.getAllNatures);
router.get('/:id', natureController.getNaturebyId);
router.put('/:id', natureController.updateNature);
router.delete('/:id', natureController.deleteNature);

module.exports = router;


================================================
File: modules/Administration&Finance/GestionAdministrative/routes/partenaire.route.js
================================================
const express = require('express');
const router = express.Router();
const controller = require('../controllers/partenaire.controller');

/**
 * @swagger
 * tags:
 *   name: Partenaires
 *   description: Gestion des partenaires
 */

/**
 * @swagger
 * /administration/partenaires:
 *   post:
 *     summary: CrÃ©er un partenaire
 *     tags: [Partenaires]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               nom_partenaire:
 *                 type: string
 *                 nullable: true
 *               telephone_partenaire:
 *                 type: string
 *                 nullable: true
 *               email_partenaire:
 *                 type: string
 *                 nullable: true
 *               specialite:
 *                 type: string
 *                 nullable: true
 *               localisation:
 *                 type: string
 *               type_partenaire:
 *                 type: string
 *                 nullable: true
 *               statut:
 *                 type: string
 *                 nullable: true
 *               id_entite:
 *                 type: integer
 *                 nullable: true
 *             required:
 *               - localisation
 *     responses:
 *       201:
 *         description: Partenaire crÃ©Ã© avec succÃ¨s
 *       500:
 *         description: Erreur serveur
 *   get:
 *     summary: RÃ©cupÃ©rer tous les partenaires
 *     tags: [Partenaires]
 *     responses:
 *       200:
 *         description: Liste des partenaires
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Partenaire'
 *       500:
 *         description: Erreur serveur
 *
 * /administration/partenaires/{id}:
 *   get:
 *     summary: RÃ©cupÃ©rer un partenaire par ID
 *     tags: [Partenaires]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID du partenaire
 *     responses:
 *       200:
 *         description: DÃ©tails du partenaire
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Partenaire'
 *       400:
 *         description: ID invalide
 *       404:
 *         description: Partenaire non trouvÃ©
 *       500:
 *         description: Erreur serveur
 *
 * /administration/partenaires/{type}:
 *   get:
 *     summary: RÃ©cupÃ©rer les partenaires par type
 *     tags: [Partenaires]
 *     parameters:
 *       - in: path
 *         name: type
 *         schema:
 *           type: string
 *         required: true
 *         description: Type du partenaire
 *     responses:
 *       200:
 *         description: Liste des partenaires du type donnÃ©
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Partenaire'
 *       500:
 *         description: Erreur serveur
 *
 * components:
 *   schemas:
 *     Partenaire:
 *       type: object
 *       properties:
 *         id_partenaire:
 *           type: integer
 *         nom_partenaire:
 *           type: string
 *           nullable: true
 *         telephone_partenaire:
 *           type: string
 *           nullable: true
 *         email_partenaire:
 *           type: string
 *           nullable: true
 *         specialite:
 *           type: string
 *           nullable: true
 *         localisation:
 *           type: string
 *         type_partenaire:
 *           type: string
 *           nullable: true
 *         statut:
 *           type: string
 *           nullable: true
 *         id_entite:
 *           type: integer
 *           nullable: true
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /administration/partenaires/{id}:
 *   put:
 *     summary: Mettre Ã  jour un partenaire
 *     tags: [Partenaires]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID du partenaire
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               nom_partenaire:
 *                 type: string
 *                 nullable: true
 *               telephone_partenaire:
 *                 type: string
 *                 nullable: true
 *               email_partenaire:
 *                 type: string
 *                 nullable: true
 *               specialite:
 *                 type: string
 *                 nullable: true
 *               localisation:
 *                 type: string
 *               type_partenaire:
 *                 type: string
 *                 nullable: true
 *               statut:
 *                 type: string
 *                 nullable: true
 *               id_entite:
 *                 type: integer
 *                 nullable: true
 *     responses:
 *       200:
 *         description: Partenaire mis Ã  jour
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Partenaire'
 *       400:
 *         description: ID invalide
 *       404:
 *         description: Partenaire non trouvÃ©
 *       500:
 *         description: Erreur serveur
 *   delete:
 *     summary: Supprimer un partenaire
 *     tags: [Partenaires]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID du partenaire
 *     responses:
 *       200:
 *         description: Partenaire supprimÃ©
 *       400:
 *         description: ID invalide
 *       500:
 *         description: Erreur serveur
 */

router.post("/", controller.createPartenaire);
router.get("/", controller.getPartenaires);
router.get("/:type", controller.getPartenairebyType);
router.put("/:id", controller.updatePartenaire);
router.delete("/:id", controller.deletePartenaire);

module.exports = router;



================================================
File: modules/Administration&Finance/GestionAdministrative/services/contrat.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config")
const {contrats,documents} = require("../../../../core/database/models")

const createContrat=async(data)=>{
    const [result]=await db.insert(contrats).values(data).returning()
    return result
}

const addDocument=async(data)=>{
    const [result]=await db.insert(documents).values(data).returning()
    return result
}

const getContrats=async()=>{
    return await db.select().from(contrats);
}

const getContratsbyPartenaire=async(id)=>{
    const [result]=await db.select().from(contrats).where(eq(contrats.id_partenaire,id))
    return result
}

const getContratById=async(id)=>{
    const [result]=await db.select().from(contrats).where(eq(contrats.id_contrat,id))
    return result
}

const updateContrat=async(id,data)=>{
    const [result]=await db
    .update(contrats)
    .set({...data ,updated_at:new Date()})
    .where(eq(contrats.id_contrat,id)).returning()
    return result
}

const deleteContrat=async(id)=>{
    const [result]=await db.delete(contrats).where(eq(contrats.id_contrat,id)).returning()
    return result
}

module.exports={
    createContrat,
    getContrats,
    getContratsbyPartenaire,
    updateContrat,
    deleteContrat,
    addDocument,
    getContratById
}


================================================
File: modules/Administration&Finance/GestionAdministrative/services/entite.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config")
const {entites} = require("../../../../core/database/models")

const createEntite=async(data)=>{
    const [result]=await db
    .insert(entites)
    .values(data)
    .returning()
    return result
}   

const getEntites=async()=>{
    return await db
    .select()
    .from(entites);
}

const getEntiteById=async(id)=>{
    const [result]=await db
    .select()
    .from(entites)
    .where(eq(entites.id_entite,id))
    return result
}

const updateEntite=async(id,data)=>{
    const [result]=await db
    .update(entites)
    .set({...data,updated_at:new Date()})
    .where(eq(entites.id_entite,id)).returning()
    return result
}

const deleteEntite=async(id)=>{ 
    const [result]=await db
    .delete(entites)
    .where(eq(entites.id_entite,id))
    .returning()
    return result
}

module.exports={
    createEntite,
    getEntites, 
    getEntiteById, 
    updateEntite,
    deleteEntite
}



================================================
File: modules/Administration&Finance/GestionAdministrative/services/interlocuteur.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config");
const {interlocuteurs} = require("../../../../core/database/models");

const createInterlocuteur = async (data) => {
    const [result] = await db.insert(interlocuteurs).values(data).returning();
    return result;
}

const getInterlocuteurs = async () => {
    return await db.select().from(interlocuteurs);
}

const getInterlocuteurbyPartenaire = async (id) => {
    const result = await db.select().from(interlocuteurs).where(eq(interlocuteurs.id_partenaire, id));
    return result;
}

const getInterlocuteurById = async (id) => {
    const [result] = await db.select().from(interlocuteurs).where(eq(interlocuteurs.id_interlocuteur, id));
    return result;
}

const updateInterlocuteur = async (id, data) => {
    const [result] = await db
    .update(interlocuteurs)
    .set({...data, updated_at: new Date()})
    .where(eq(interlocuteurs.id_interlocuteur, id))
    .returning();
    return result;
}

const deleteInterlocuteur = async (id) => {
    const [result] = await db.delete(interlocuteurs).where(eq(interlocuteurs.id_interlocuteur, id)).returning();
    return result;
}

module.exports = {
    createInterlocuteur,
    getInterlocuteurs,
    getInterlocuteurbyPartenaire,
    getInterlocuteurById,
    updateInterlocuteur,
    deleteInterlocuteur
}


================================================
File: modules/Administration&Finance/GestionAdministrative/services/nature.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config")
const {nature_documents} = require("../../../../core/database/models")

const createNature = async (data) => {
    try {
        const result = await db
        .insert(nature_documents)
        .values(data)
        .returning();
        return result;
    } catch (error) {
        console.error("Error creating nature:", error);
        throw error;
    }
}

const getAllNatures = async () => {
    try {
        const result = await db
        .select()
        .from(nature_documents)
        return result;
    } catch (error) {
        console.error("Error fetching natures:", error);
        throw error;
    }
}

const getNaturebyId = async (id) => {
    try {
        const result = await db
        .select()
        .from(nature_documents)
        .where(eq(nature_documents.id, id))
        return result;
    } catch (error) {
        console.error("Error fetching nature by ID:", error);
        throw error;
    }
}

const updateNature = async (id, data) => {
    try {
        const result = await db
        .update(nature_documents)
        .set({...data, updated_at: new Date()})
        .where(eq(nature_documents.id_nature_document, id))
        .returning();
        return result;
    } catch (error) {
        console.error("Error updating nature:", error);
        throw error;
    }
}

const deleteNature = async (id) => {
    try {
        const result = await db
        .delete(nature_documents)
        .where(eq(nature_documents.id_nature_document, id))
        .returning();
        return result;
    } catch (error) {
        console.error("Error deleting nature:", error);
        throw error;
    }
}

module.exports = {
    createNature,
    getAllNatures,
    getNaturebyId,
    updateNature,
    deleteNature
}


================================================
File: modules/Administration&Finance/GestionAdministrative/services/partenaire.service.js
================================================
// const { eq } = require("drizzle-orm");
// const {db} = require('../../../core/database/config')
// const { partenaire } = require("../../../core/database/models");

// const createPartenaire=async(data)=>{
//     const [result]=await db.insert(partenaire).values(data).returning()
//     return result
// }

// const getPartenaires=async()=>{
//     return await db.select().from(partenaire);

// }

// const getPartenaireById=async(id)=>{
//     const [result]=await db.select().from(partenaire).where(eq(partenaire.id,id))
//     return result
// }

// const updatePartenaire=async(id,data)=>{
//     const [result]=await db.update(partenaire).set(data).where(eq(partenaire.id,id)).returning()
//     return result
// }

// const deletePartenaire=async(id)=>{
//     const [result]=await db.delete(partenaire).where(eq(partenaire.id,id)).returning()
//     return result
// }

// module.exports={
//     createPartenaire,
//     getPartenaires, 
//     getPartenaireById,
//     updatePartenaire,
//     deletePartenaire
// }

const { eq } = require("drizzle-orm");
const { db } = require("../../../../core/database/config");
const { partenaires } = require("../../../../core/database/models");

const createPartenaire = async (data) => {
  const [result] = await db.insert(partenaires).values(data).returning();
  return result;
}

const getPartenaires = async () => {
  return await db.select().from(partenaires);
}

const getPartenaireById = async (id) => {
  const [result] = await db.select().from(partenaires).where(eq(partenaires.id_partenaire, id));
  return result;
}

const updatePartenaire = async (id, data) => {
  const [result] = await db
  .update(partenaires)
  .set({...data, updated_at: new Date() })
  .where(eq(partenaires.id_partenaire, id)).returning();
  return result;
}

const deletePartenaire = async (id) => {
  const [result] = await db.delete(partenaires).where(eq(partenaires.id_partenaire, id)).returning();
  return result;
}

module.exports = {
  createPartenaire,
  getPartenaires,
  getPartenaireById,
  updatePartenaire,
  deletePartenaire
}


================================================
File: modules/Administration&Finance/RH/controllers/demande.controller.js
================================================
const fs = require('fs');
const demandeService = require('../services/demande.service');  
const logger = require('../../../../core/utils/logger');

// Fonction utilitaire pour supprimer un fichier de faÃ§on asynchrone
async function safeUnlink(filePath) {
    try {
        await fs.promises.unlink(filePath);
        logger.info(`Fichier supprimÃ© avec succÃ¨s: ${filePath}`);
    } catch (err) {
        logger.error(`Erreur lors de la suppression du fichier ${filePath}:`, { error: err });
    }
}

const createDemande = async (req, res) => {
    try {
        logger.info("DÃ©but de crÃ©ation de demande");
        
        // Log des donnÃ©es reÃ§ues (sans donnÃ©es sensibles)
        logger.debug("Body reÃ§u:", {
            body: { ...req.body },
            // Masquer les donnÃ©es sensibles si nÃ©cessaire
        });
        
        logger.debug("Fichier reÃ§u:", {
            file: req.file ? {
                filename: req.file.filename,
                path: req.file.path,
                size: req.file.size
            } : "Aucun fichier"
        });

        const data = req.body;
        if (!data || Object.keys(data).length === 0) {
            logger.warn("Aucune donnÃ©e reÃ§ue dans le corps de la requÃªte");
            if (req.file) await safeUnlink(req.file.path);
            return res.status(400).json({ message: "Les donnÃ©es de la demande sont requises." });
        }

        // Validation des champs requis
        const requiredFields = ['date_absence', 'date_retour', 'motif', 'type_demande', 'id_employes'];
        const missingFields = requiredFields.filter(field => !data[field]);
        
        if (missingFields.length > 0) {
            logger.warn(`Champs requis manquants: ${missingFields.join(', ')}`, { fields: missingFields });
            if (req.file) await safeUnlink(req.file.path);
            return res.status(400).json({ 
                message: "DonnÃ©es incomplÃ¨tes", 
                details: `Champs requis manquants: ${missingFields.join(', ')}` 
            });
        }

        // CrÃ©ation de la demande
        logger.debug("PrÃ©paration de la crÃ©ation de la demande avec les donnÃ©es validÃ©es");
        const demandeData = {
            date_absence: data.date_absence,
            status: data.status || "en attente",
            date_retour: data.date_retour,
            motif: data.motif,
            type_demande: data.type_demande,
            durÃ©e: data.durÃ©e,
            heure_debut: data.heure_debut,
            heure_fin: data.heure_fin,
            id_employes: parseInt(data.id_employes) 
        };
        
        logger.debug("Appel au service pour crÃ©er la demande", { demandeData });
        const demande = await demandeService.createDemande(demandeData);
        logger.debug("RÃ©sultat de la crÃ©ation de demande", { demande });
        
        if (!demande) {
            logger.error("Le service a retournÃ© un rÃ©sultat vide ou null");
            if (req.file) await safeUnlink(req.file.path);
            return res.status(500).json({ message: "Erreur lors de la crÃ©ation de la demande: le service n'a pas retournÃ© de rÃ©sultat." });
        }
        
        logger.debug("ClÃ©s de la demande retournÃ©e:", Object.keys(demande));

        // GÃ¨re le cas oÃ¹ le service retourne un tableau ou un objet
        let demandeObj = Array.isArray(demande) ? demande[0] : demande;
        const demandeId = demandeObj?.id_demandes || demandeObj?.id_demande || demandeObj?.id || demandeObj?.demandeId;

        if (!demandeId) {
            logger.error("ID de demande non retournÃ© dans le rÃ©sultat", { demande });
            if (req.file) await safeUnlink(req.file.path);
            return res.status(500).json({ 
                message: "Erreur lors de la crÃ©ation de la demande: ID manquant.",
                details: "La demande a peut-Ãªtre Ã©tÃ© crÃ©Ã©e mais l'ID n'a pas Ã©tÃ© retournÃ©."
            });
        }

        // Traitement du document si prÃ©sent
        let documentResult = null;
        if (req.file) {
            logger.info("Traitement du document joint", { fileInfo: req.file.filename });
            const { libelle_document, classification_document } = req.body;
            
            if (!libelle_document) {
                logger.warn("LibellÃ© du document manquant");
                await safeUnlink(req.file.path);
                return res.status(400).json({ 
                    message: "Le libellÃ© du document est obligatoire.",
                    details: "Le document a Ã©tÃ© reÃ§u mais pas enregistrÃ© car le libellÃ© manque." 
                });
            }

            // CrÃ©ation du chemin relatif
            const relativePath = req.file.path
                .replace(process.cwd(), '')
                .replace(/\\/g, '/')
                .replace(/^\//, '');

            const document = {
                libelle_document,
                classification_document: classification_document || "Demande",
                lien_document: relativePath,
                etat_document: req.body.etat_document || "actif",
                date_document: new Date().toISOString().split('T')[0],
                id_demandes: parseInt(demandeId), 
                id_employes: parseInt(data.id_employes),
                id_nature_document: parseInt(data.id_nature_document) || null
            };

            logger.debug("Appel au service pour ajouter le document", { document });
            documentResult = await demandeService.addDocumentToDemande(document);
            logger.debug("RÃ©sultat de l'ajout du document", { documentResult });

            if (!documentResult) {
                logger.error("Ã‰chec de l'ajout du document");
                await safeUnlink(req.file.path);
                return res.status(500).json({ 
                    message: "Demande crÃ©Ã©e mais document non ajoutÃ©.",
                    details: "Une erreur s'est produite lors de l'enregistrement du document."
                });
            }
        }

        logger.info("CrÃ©ation de demande terminÃ©e avec succÃ¨s", { 
            demandeId, 
            documentAdded: !!documentResult 
        });
        
        res.status(201).json({
            success: true,
            message: documentResult
                ? "Demande et document ajoutÃ©s avec succÃ¨s"
                : "Demande ajoutÃ©e avec succÃ¨s",
            data: {
                demande,
                document: documentResult
            }
        });
    } catch (error) {
        logger.error("Erreur lors de la crÃ©ation de la demande", { 
            error: {
                message: error.message,
                stack: error.stack,
                code: error.code,
                name: error.name
            }
        });
        
        if (req.file && req.file.path) {
            await safeUnlink(req.file.path);
        }
        
        // DÃ©terminer le type d'erreur
        let errorMessage = "Erreur interne lors de la crÃ©ation de la demande.";
        let statusCode = 500;
        
        // Personnaliser selon le type d'erreur
        if (error.code === '23505') {
            errorMessage = "Une demande identique existe dÃ©jÃ .";
            statusCode = 409; // Conflict
        } else if (error.code === '23503') {
            errorMessage = "RÃ©fÃ©rence invalide (clÃ© Ã©trangÃ¨re).";
            statusCode = 400; // Bad Request
        } else if (error.message && error.message.includes("invalid input")) {
            errorMessage = "DonnÃ©es d'entrÃ©e invalides.";
            statusCode = 400; // Bad Request
        }
        
        res.status(statusCode).json({
            message: errorMessage,
            details: error.message,
            type: error.name || "UnknownError"
        });
    }
};

const getAllDemandes = async (req, res) => {
    try {
        logger.info("RÃ©cupÃ©ration de toutes les demandes");
        const result = await demandeService.getAllDemandes();
        logger.info(`${result.length} demandes rÃ©cupÃ©rÃ©es`);
        res.status(200).json(result);
    } catch (error) {
        logger.error("Erreur lors de la rÃ©cupÃ©ration des demandes", {
            error: {
                message: error.message,
                stack: error.stack
            }
        });
        res.status(500).json({ 
            message: "Erreur interne lors de la rÃ©cupÃ©ration des demandes.",
            details: error.message 
        });
    }
};

const getDemandeByType = async (req, res) => {
    try {
        const { type } = req.params;
        logger.info(`Recherche de demandes par type: ${type}`);
        
        if (!type) {
            logger.warn("Type de demande non spÃ©cifiÃ©");
            return res.status(400).json({ message: "Le type de demande est requis." });
        }
        
        const result = await demandeService.getdemandeBytype(type);
        logger.info(`${result.length} demandes trouvÃ©es pour le type: ${type}`);
        
        if (!result || result.length === 0) {
            logger.info(`Aucune demande trouvÃ©e pour le type: ${type}`);
            return res.status(404).json({ 
                message: "Aucune demande trouvÃ©e pour ce type.",
                details: `Type recherchÃ©: ${type}` 
            });
        }
        
        res.status(200).json(result);
    } catch (error) {
        logger.error(`Erreur lors de la rÃ©cupÃ©ration des demandes de type ${req.params.type}`, {
            error: {
                message: error.message,
                stack: error.stack
            }
        });
        res.status(500).json({ 
            message: "Erreur interne lors de la rÃ©cupÃ©ration par type.",
            details: error.message 
        });
    }
};

const updateDemande = async (req, res) => {
    try {
        const { id } = req.params;
        const data = req.body;
        
        logger.info(`Mise Ã  jour de la demande ${id}`, { updateData: data });
        
        if (!id) {
            logger.warn("Tentative de mise Ã  jour sans ID");
            return res.status(400).json({ message: "L'ID de la demande est requis." });
        }
        
        if (!data || Object.keys(data).length === 0) {
            logger.warn(`Mise Ã  jour de la demande ${id} sans donnÃ©es`);
            return res.status(400).json({ message: "Aucune donnÃ©e fournie pour la mise Ã  jour." });
        }
        
        const result = await demandeService.updateDemande(id, data);
        logger.debug(`RÃ©sultat de la mise Ã  jour`, { result });
        
        if (!result) {
            logger.warn(`Demande ${id} non trouvÃ©e pour mise Ã  jour`);
            return res.status(404).json({ 
                message: "Demande Ã  mettre Ã  jour non trouvÃ©e.",
                details: `ID recherchÃ©: ${id}` 
            });
        }
        
        logger.info(`Demande ${id} mise Ã  jour avec succÃ¨s`);
        res.status(200).json({
            success: true,
            message: "Demande mise Ã  jour avec succÃ¨s",
            data: result
        });
    } catch (error) {
        logger.error(`Erreur lors de la mise Ã  jour de la demande ${req.params.id}`, {
            error: {
                message: error.message,
                stack: error.stack
            }
        });
        res.status(500).json({ 
            message: "Erreur interne lors de la mise Ã  jour de la demande.",
            details: error.message 
        });
    }
};

const deleteDemande = async (req, res) => {
    try {
        const { id } = req.params;
        logger.info(`Suppression de la demande ${id}`);
        
        if (!id) {
            logger.warn("Tentative de suppression sans ID");
            return res.status(400).json({ message: "L'ID de la demande est requis." });
        }
        
        // Optionnel: vÃ©rifier si la demande existe avant de tenter de la supprimer
        const demandeExists = await demandeService.getdemandeById(id);
        if (!demandeExists) {
            logger.warn(`La demande ${id} n'existe pas ou a dÃ©jÃ  Ã©tÃ© supprimÃ©e`);
            return res.status(404).json({ 
                message: "Demande Ã  supprimer non trouvÃ©e.",
                details: `ID recherchÃ©: ${id}` 
            });
        }
        
        const result = await demandeService.deleteDemande(id);
        logger.debug(`RÃ©sultat de la suppression`, { result });
        
        if (!result) {
            logger.error(`Ã‰chec de la suppression de la demande ${id}`);
            return res.status(500).json({ 
                message: "Ã‰chec de la suppression de la demande.",
                details: "La demande existe mais n'a pas pu Ãªtre supprimÃ©e." 
            });
        }
        
        logger.info(`Demande ${id} supprimÃ©e avec succÃ¨s`);
        res.status(200).json({
            success: true,
            message: "Demande supprimÃ©e avec succÃ¨s",
            data: result
        });
    } catch (error) {
        logger.error(`Erreur lors de la suppression de la demande ${req.params.id}`, {
            error: {
                message: error.message,
                stack: error.stack
            }
        });
        
        // Personnalisation selon le type d'erreur
        let errorMessage = "Erreur interne lors de la suppression de la demande.";
        let statusCode = 500;
        
        if (error.code === '23503') {
            errorMessage = "Impossible de supprimer cette demande car elle est rÃ©fÃ©rencÃ©e ailleurs.";
            statusCode = 400;
        }
        
        res.status(statusCode).json({ 
            message: errorMessage,
            details: error.message 
        });
    }
};

module.exports = {
    createDemande,
    getAllDemandes,
    getDemandeByType,
    updateDemande,
    deleteDemande
};


================================================
File: modules/Administration&Finance/RH/controllers/employes.controller.js
================================================
const employeservice = require('../services/employe.service');

const getEmployes = async (req, res) => {
    try {
        const employes = await employeservice.getEmployes();
        return res.status(200).json(employes);
    } catch (error) {
        console.error("Erreur lors de la rÃ©cupÃ©ration des employÃ©s:", error);
        return res.status(500).json({ message: "Erreur interne lors de la rÃ©cupÃ©ration des employÃ©s" });
    }
};

const getEmployeById = async (req, res) => {
    try {
        const {id} = req.params;
        if (!id || isNaN(Number(id))) {
            return res.status(400).json({ message: "ID invalide" });
        }
        const employe = await employeservice.getEmployeById(id);
        if (!employe) {
            return res.status(404).json({message: "EmployÃ© non trouvÃ©"});
        }
        return res.status(200).json(employe);
    } catch (error) {
        console.error("Erreur lors de la rÃ©cupÃ©ration de l'employÃ© par ID:", error);
        return res.status(500).json({ message: "Erreur interne lors de la rÃ©cupÃ©ration de l'employÃ©" });
    }
};

const getEmployeByFonction = async (req, res) => {
    try {
        const {id} = req.params;
        if (!id || isNaN(Number(id))) {
            return res.status(400).json({ message: "ID de fonction invalide" });
        }
        const employe = await employeservice.getEmployeByFonction(id);
        if (!employe) {
            return res.status(404).json({message: "Aucun employÃ© trouvÃ© pour cette fonction"});
        }
        return res.status(200).json(employe);
    } catch (error) {
        console.error("Erreur lors de la rÃ©cupÃ©ration par fonction:", error);
        return res.status(500).json({ message: "Erreur interne lors de la rÃ©cupÃ©ration par fonction" });
    }
};

const getEmployeByStatut = async (req, res) => {
    try {
        const {statut} = req.params;
        if (!statut) {
            return res.status(400).json({ message: "Statut manquant" });
        }
        const employe = await employeservice.getEmployeByStatut(statut);
        if (!employe) {
            return res.status(404).json({message: "Aucun employÃ© trouvÃ© pour ce statut"});
        }
        return res.status(200).json(employe);
    } catch (error) {
        console.error("Erreur lors de la rÃ©cupÃ©ration par statut:", error);
        return res.status(500).json({ message: "Erreur interne lors de la rÃ©cupÃ©ration par statut" });
    }
};

const updateEmploye = async (req, res) => {
    try {
        const {id} = req.params;
        const data = req.body;

        if (!id || isNaN(Number(id))) {
            return res.status(400).json({ message: "ID invalide" });
        }
        if (!data || Object.keys(data).length === 0) {
            return res.status(400).json({ message: "Aucune donnÃ©e Ã  mettre Ã  jour" });
        }
        Object.keys(data).forEach(key => {
            if (data[key] === "") {
                delete data[key];
            }
        });

        const employe = await employeservice.updateEmploye(id, data);
        if (!employe) {
            return res.status(404).json({message: "EmployÃ© non trouvÃ© ou aucune modification effectuÃ©e"});
        }
        return res.status(200).json(employe);
    } catch (error) {
        console.error("Erreur lors de la mise Ã  jour de l'employÃ©:", error);
        return res.status(500).json({ message: "Erreur interne lors de la mise Ã  jour de l'employÃ©" });
    }
};

module.exports = {
    getEmployes,
    getEmployeById,
    getEmployeByFonction,
    getEmployeByStatut,
    updateEmploye
};


================================================
File: modules/Administration&Finance/RH/controllers/fonction.controller.js
================================================
const fonctionsService = require("../services/fonction.service");

const createFonction = async (req, res) => {
    try {
        const data = req.body;
        const fonction = await fonctionsService.createFonction(data);
        return res.status(201).json(fonction);
    } catch (error) {
        return res.status(500).json({ message: error.message });
    }
}

const getFonctions = async (req, res) => {
    try {
        const fonctions = await fonctionsService.getFonctions();
        return res.status(200).json(fonctions);
    } catch (error) {
        return res.status(500).json({ message: error.message });
    }
}

const getFonctionById = async (req, res) => {
    try {
        const { id } = req.params;
        const fonction = await fonctionsService.getFonctionById(id);
        if (!fonction) {
            return res.status(404).json({ message: "Fonction not found" });
        }
        return res.status(200).json(fonction);
    } catch (error) {
        return res.status(500).json({ message: error.message });
    }
}

const updateFonction = async (req, res) => {
    try {
        const { id } = req.params;
        const data = req.body;
        const fonction = await fonctionsService.updateFonction(id, data);
        if (!fonction) {
            return res.status(404).json({ message: "Fonction not found" });
        }
        return res.status(200).json(fonction);
    } catch (error) {
        return res.status(500).json({ message: error.message });
    }
}

const deleteFonction = async (req, res) => {
    try {
        const { id } = req.params;
        const fonction = await fonctionsService.deleteFonction(id);
        if (!fonction) {
            return res.status(404).json({ message: "Fonction not found" });
        }
        return res.status(200).json(fonction);
    } catch (error) {
        return res.status(500).json({ message: error.message });
    }
}

module.exports = {
    createFonction,
    getFonctions,
    getFonctionById,
    updateFonction,
    deleteFonction
}


================================================
File: modules/Administration&Finance/RH/routes/demande.route.js
================================================
const demandeController = require('../controllers/demande.controller');
const express = require('express');
const router = express.Router();
const upload = require('../../../utils/middleware/uploadMiddleware');
const path = require('path');
const fs = require('fs');

const UPLOAD_PATHS = {
 DEMANDES: 'media/documents/administration/RH/demandes'
};


router.post(
  '/',
  (req, res, next) => {
    try {
      // DÃ©finir et crÃ©er le chemin avant l'upload
      const uploadPath = path.join(process.cwd(), UPLOAD_PATHS.DEMANDES);
      
      // CrÃ©er le dossier s'il n'existe pas
      if (!fs.existsSync(uploadPath)) {
        fs.mkdirSync(uploadPath, { recursive: true });
      }
      
      req.uploadPath = uploadPath;
      next();
    } catch (error) {
      next(error);
    }
  },
  upload.single("document"), 
  demandeController.createDemande
);
router.get('/', demandeController.getAllDemandes);
router.get('/:type', demandeController.getDemandeByType);
router.put('/:id', demandeController.updateDemande);
router.delete('/:id', demandeController.deleteDemande);

module.exports = router;


================================================
File: modules/Administration&Finance/RH/routes/employe.route.js
================================================
const employeController = require('../controllers/employes.controller');
const express = require('express');
const router = express.Router();


router.get('/', employeController.getEmployes);
router.get('/:id', employeController.getEmployeById);
router.get('/fonction/:id', employeController.getEmployeByFonction);
router.get('/statut/:statut', employeController.getEmployeByStatut);
router.put('/:id', employeController.updateEmploye);

module.exports = router;


================================================
File: modules/Administration&Finance/RH/routes/fonction.route.js
================================================
const fonctionController = require('../controllers/fonction.controller');
const express = require('express');
const router = express.Router();


router.post('/', fonctionController.createFonction);
router.get('/', fonctionController.getFonctions);
router.get('/:id', fonctionController.getFonctionById);
router.put('/:id', fonctionController.updateFonction);
router.delete('/:id', fonctionController.deleteFonction);


module.exports = router;


================================================
File: modules/Administration&Finance/RH/services/demande.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config")
const {demandes,documents} = require("../../../../core/database/models");

const createDemande = async (data) => {
    try {
        const result = await db
        .insert(demandes)
        .values(data)
        .returning();
        return result;
    } catch (error) {
        console.error("Error creating demande:", error);
        throw error;
    }
}

const getAllDemandes = async () => {
    try {
        const result = await db
        .select()
        .from(demandes)
        return result;
    } catch (error) {
        console.error("Error fetching demandes:", error);
        throw error;
    }
}

const getdemandeBytype = async (type) => {
    try {
        const result = await db
        .select()
        .from(demandes)
        .where(eq(demandes.type_demande, type))
        return result;
    } catch (error) {
        console.error("Error fetching demande by type:", error);
        throw error;
    }
}

const updateDemande = async (id, data) => {
    try {
        const result = await db
        .update(demandes)
        .set({...data, updated_at: new Date()})
        .where(eq(demandes.id_demandes, id))
        .returning();
        return result;
    } catch (error) {
        console.error("Error updating demande:", error);
        throw error;
    }
}

const deleteDemande = async (id) => {
    try {
        const result = await db
        .delete(demandes)
        .where(eq(demandes.id_demandes, id))
        .returning();
        return result;
    } catch (error) {
        console.error("Error deleting demande:", error);
        throw error;
    }
}

const addDocumentToDemande = async (documentData) => {

    const result = await db
    .insert(documents)
    .values(documentData)
    .returning();
    return result;
}

const getdemandeById = async (id) =>{
    const result = await db
    .select()
    .from(demandes)
    .where(eq(demandes.id_demandes, id))
    return result;
}


module.exports = {
    createDemande,
    getAllDemandes,
    getdemandeBytype,
    updateDemande,
    deleteDemande,
    addDocumentToDemande,
    getdemandeById
}


================================================
File: modules/Administration&Finance/RH/services/employe.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config");
const {employes} = require("../../../../core/database/models");


const getEmployes = async () => {
    return await db
    .select()
    .from(employes);
}

const getEmployeById = async (id) => {
    const [result] = await db
    .select()
    .from(employes)
    .where(eq(employes.id_employe, id));
    return result;
}

const getEmployeByFonction = async (id) => {
    const result = await db
    .select()
    .from(employes)
    .where(eq(employes.id_fonction, id));
    return result;
}


const getEmployeByStatut = async (statut) => {
    const result = await db
    .select()
    .from(employes)
    .where(eq(employes.status_employes, statut));
    return result;
}

const updateEmploye = async (id, data) => {
    if (!data || Object.keys(data).length === 0) return null;
    const [result] = await db
        .update(employes)
        .set({...data, updated_at: new Date()})
        .where(eq(employes.id_employes, id))
        .returning();
    return result;
}

module.exports = {
    getEmployes,
    getEmployeById,
    getEmployeByFonction,
    getEmployeByStatut,
    updateEmploye
}




================================================
File: modules/Administration&Finance/RH/services/fonction.service.js
================================================
const {eq} = require("drizzle-orm");
const {db} = require("../../../../core/database/config");
const {fonctions} = require("../../../../core/database/models");

const createFonction = async (data) => {
    const [result] = await db.insert(fonctions).values(data).returning();
    return result;
}

const getFonctions = async () => {
    return await db.select().from(fonctions);
}   

const getFonctionById = async (id) => {
    const [result] = await db.select().from(fonctions).where(eq(fonctions.id_fonction, id));
    return result;
}

const updateFonction = async (id, data) => {
    const [result] = await db
    .update(fonctions)
    .set({...data, updated_at: new Date()})
    .where(eq(fonctions.id_fonction, id))
    .returning();
    return result;
}

const deleteFonction = async (id) => {
    const [result] = await db.delete(fonctions).where(eq(fonctions.id_fonction, id)).returning();
    return result;
}

module.exports = {
    createFonction,
    getFonctions,
    getFonctionById,
    updateFonction,
    deleteFonction
}


================================================
File: modules/Administration&Finance/routes/Administration&Finance.routes.js
================================================
const express = require("express");
const router = express.Router();
const interlocuteurRoutes = require("../GestionAdministrative/routes/interlocuteur.route");
const partenaireRoutes = require("../GestionAdministrative/routes/partenaire.route");
const contratRoutes = require("../GestionAdministrative/routes/contrat.route");
const natureRoutes = require("../GestionAdministrative/routes/nature.route");
const entiteRoutes = require("../GestionAdministrative/routes/entite.route");
const demandeRoutes = require("../RH/routes/demande.route")
const docRoutes = require("../FinanceCompta/routes/doc_FC.route");
const employeRoutes = require("../RH/routes/employe.route");
const fonctionRoutes = require("../RH/routes/fonction.route");


router.use("/interlocuteurs", interlocuteurRoutes);
router.use("/partenaires", partenaireRoutes);
router.use("/contrats", contratRoutes);
router.use("/natures", natureRoutes);
router.use("/entites", entiteRoutes);
router.use("/demandes", demandeRoutes);
router.use("/documents", docRoutes);
router.use("/employes", employeRoutes);
router.use("/fonctions", fonctionRoutes);

module.exports = router;



================================================
File: modules/clients/controllers/clients.controller.js
================================================
ï»¿const db = require('../../core/database');
const Model = db.models.Clients;

exports.getAll = async (req, res) => {
    try {
        const data = await Model.findAll();
        res.json(data);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.create = async (req, res) => {
    try {
        const newItem = await Model.create(req.body);
        res.status(201).json(newItem);
    } catch (error) {
        res.status(400).json({ message: error.message });
    }
};

// Ajoutez ici les autres mÃƒÂ©thodes CRUD...



================================================
File: modules/clients/routes/clients.routes.js
================================================
ï»¿


================================================
File: modules/dashboard/controllers/dashboard.controller.js
================================================
ï»¿


================================================
File: modules/dashboard/routes/dashboard.routes.js
================================================
ï»¿



================================================
File: modules/marketing_commercial/controllers/affiches.controller.js
================================================
const affichesService = require('../services/affiches.service');
const path = require('path');

const affichesController = {
  getAllAffiches: async (req, res) => {
    try {
      const affiches = await affichesService.getAllAffiches();
      res.json({ success: true, data: affiches });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la rÃ©cupÃ©ration des affiches" 
      });
    }
  },

  getAfficheById: async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ success: false, error: "ID invalide" });
    }

    try {
      const affiche = await affichesService.getAfficheById(id);
      if (!affiche) {
        return res.status(404).json({ success: false, error: "Affiche non trouvÃ©e" });
      }
      res.json({ success: true, data: affiche });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la rÃ©cupÃ©ration de l'affiche" 
      });
    }
  },

  createAffiche: async (req, res) => {
    try {
      // Validation des champs requis
      if (!req.file || !req.body.titre || !req.body.sous_titre) {
        return res.status(400).json({ 
          success: false, 
          error: "Titre, sous-titre et image sont requis" 
        });
      }

      // Validation de la longueur du titre
      if (req.body.titre.length > 100) {
        return res.status(400).json({
          success: false,
          error: "Le titre ne doit pas dÃ©passer 100 caractÃ¨res"
        });
      }
      
      // Validation de la longueur du sous-titre
      if (req.body.sous_titre.length > 150) {
        return res.status(400).json({
          success: false,
          error: "Le sous-titre ne doit pas dÃ©passer 150 caractÃ¨res"
        });
      }

      const relativePath = path.join('media/images/affiches_dcat', req.file.filename)
        .replace(/\\/g, '/');

      const afficheData = {
        titre: req.body.titre.trim(),
        sous_titre: req.body.sous_titre.trim(),
        image: relativePath
      };

      const affiche = await affichesService.createAffiche(afficheData);
      res.status(201).json({ success: true, data: affiche });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la crÃ©ation de l'affiche" 
      });
    }
  },

  updateAffiche: async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ success: false, error: "ID invalide" });
    }

    try {
      if (!req.body.titre || !req.body.sous_titre) {
        return res.status(400).json({ 
          success: false, 
          error: "Titre et sous-titre sont requis" 
        });
      }

      if (req.body.titre.length > 100) {
        return res.status(400).json({
          success: false,
          error: "Le titre ne doit pas dÃ©passer 100 caractÃ¨res"
        });
      }
      
      if (req.body.sous_titre.length > 150) {
        return res.status(400).json({
          success: false,
          error: "Le sous-titre ne doit pas dÃ©passer 150 caractÃ¨res"
        });
      }

      const afficheData = {
        titre: req.body.titre.trim(),
        sous_titre: req.body.sous_titre.trim()
      };

      if (req.file) {
        const relativePath = path.join('media/images/affiches_dcat', req.file.filename)
          .replace(/\\/g, '/');
        afficheData.image = relativePath;
      }

      const affiche = await affichesService.updateAffiche(id, afficheData);
      if (!affiche) {
        return res.status(404).json({ success: false, error: "Affiche non trouvÃ©e" });
      }
      res.json({ success: true, data: affiche });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la mise Ã  jour de l'affiche" 
      });
    }
  },

  deleteAffiche: async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ success: false, error: "ID invalide" });
    }

    try {
      const deleted = await affichesService.deleteAffiche(id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: "Affiche non trouvÃ©e" });
      }
      res.json({ success: true, message: "Affiche supprimÃ©e avec succÃ¨s" });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la suppression de l'affiche" 
      });
    }
  }
};

module.exports = affichesController;


================================================
File: modules/marketing_commercial/controllers/clients.controller.js
================================================
const clientsService = require("../services/clients.service");
const jwt = require("jsonwebtoken");
const { db } = require('../../../core/database/config');
const { refresh_tokens } = require("../../../core/database/models");
const dayjs = require('dayjs');
const { eq } = require("drizzle-orm"); // Ajout de l'import manquant

const JWT_SECRET = process.env.JWT_SECRET || "sorosamuel";
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || "refresh_secret";

const clientsController = {
  register: async (req, res) => {
    try {
      const result = await clientsService.register(req.body);
      res.status(201).json({ success: true, ...result });
    } catch (error) {
      res.status(400).json({ success: false, error: error.message });
    }
  },

  //gere la connexion des clients
  login: async (req, res) => {
    try {
      // VÃ©rification des champs requis dÃ¨s le dÃ©but
      const { identifiant, password } = req.body;
      if (!identifiant || !password) {
        return res.status(400).json({ 
          success: false, 
          error: "L'identifiant et le mot de passe sont requis",
          errorCode: "MISSING_FIELDS"
        });
      }

      try {
        const { client, passwordOk } = await clientsService.login(req.body);

        if (!passwordOk) {
          return res.status(401).json({ 
            success: false, 
            error: "Mot de passe incorrect", 
            errorCode: "INVALID_PASSWORD"
          });
        }

        const token = jwt.sign(
          { id: client.id_client, role: client.role },
          JWT_SECRET,
          { expiresIn: "15m" }
        );
        
        const refreshToken = jwt.sign(
          { id: client.id_client, role: client.role },
          JWT_REFRESH_SECRET,
          { expiresIn: "7d" }
        );

        await db.insert(refresh_tokens).values({
          user_id: client.id_client,
          token: refreshToken,
          expires_at: dayjs().add(7, 'day').toDate(),
        });

        res.json({
          success: true,
          client: {
            id: client.id_client,
            nom: client.nom,
            email: client.email,
            contact: client.contact,
            role: client.role,
          },
          token,
          refreshToken,
        });
      } catch (error) {
        // Messages d'erreur plus prÃ©cis avec codes d'erreur
        if (error.message === "Aucun compte trouvÃ© avec cet identifiant") {
          return res.status(401).json({ 
            success: false, 
            error: error.message,
            errorCode: "USER_NOT_FOUND" 
          });
        } else if (error.message === "Mot de passe incorrect") {
          return res.status(401).json({ 
            success: false, 
            error: error.message,
            errorCode: "INVALID_PASSWORD" 
          });
        } else {
          return res.status(400).json({ 
            success: false, 
            error: error.message,
            errorCode: "LOGIN_ERROR"
          });
        }
      }
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur serveur: " + error.message,
        errorCode: "SERVER_ERROR"
      });
    }
  },

  verifyToken: async (req, res) => {
    const authHeader = req.headers.authorization;
    if (!authHeader) return res.status(401).json({ success: false, error: "Token manquant" });

    const token = authHeader.split(" ")[1];
    try {
      const decoded = jwt.verify(token, JWT_SECRET);
      res.json({ success: true, id: decoded.id, role: decoded.role });
    } catch (error) {
      res.status(401).json({ success: false, error: "Token invalide" });
    }
  },

  refreshToken: async (req, res) => {
    const { refreshToken } = req.body;
    if (!refreshToken) return res.status(401).json({ 
      success: false, 
      error: "Refresh token manquant" 
    });

    try {
      // 1. VÃ©rifier et supprimer l'ancien refresh token
      const tokens = await db.select().from(refresh_tokens)
        .where(eq(refresh_tokens.token, refreshToken));
      
      if (tokens.length === 0 || dayjs(tokens[0].expires_at).isBefore(dayjs())) {
        await db.delete(refresh_tokens)
          .where(eq(refresh_tokens.token, refreshToken));
        return res.status(403).json({ 
          success: false, 
          error: "Refresh token invalide ou expirÃ©" 
        });
      }

      const decoded = jwt.verify(refreshToken, JWT_REFRESH_SECRET);

      // 2. Supprimer l'ancien refresh token avant d'en crÃ©er un nouveau
      await db.delete(refresh_tokens)
        .where(eq(refresh_tokens.token, refreshToken));

      // 3. GÃ©nÃ©rer les nouveaux tokens
      const newAccessToken = jwt.sign(
        { id: decoded.id, role: decoded.role },
        JWT_SECRET,
        { expiresIn: "15m" }
      );
      const newRefreshToken = jwt.sign(
        { id: decoded.id, role: decoded.role },
        JWT_REFRESH_SECRET,
        { expiresIn: "7d" }
      );

      // 4. Sauvegarder le nouveau refresh token
      await db.insert(refresh_tokens).values({
        user_id: decoded.id,
        token: newRefreshToken,
        expires_at: dayjs().add(7, 'day').toDate(),
      });

      res.json({ 
        success: true, 
        token: newAccessToken, 
        refreshToken: newRefreshToken 
      });
    } catch (error) {
      res.status(401).json({ 
        success: false, 
        error: "Refresh token invalide" 
      });
    }
  },

  logout: async (req, res) => {
    const { refreshToken } = req.body;
    if (!refreshToken) return res.status(400).json({ success: false, error: "Refresh token manquant" });

    await db.delete(refresh_tokens).where(eq(refresh_tokens.token, refreshToken));
    res.json({ success: true, message: "DÃ©connexion rÃ©ussie" });
  },

  // RÃ©cupÃ©rer tous les clients (fonctionnalitÃ© admin)
  getAllClients: async (req, res) => {
    try {
      const clients = await clientsService.getAllClients();
      res.json({ success: true, clients });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la rÃ©cupÃ©ration des clients: " + error.message
      });
    }
  },
};

module.exports = clientsController;



================================================
File: modules/marketing_commercial/controllers/commandes.controller.js
================================================
const commandesService = require('../services/commandes.service');

const commandesController = {
  createCommande: async (req, res) => {
    try {
      // Validation des donnÃ©es
      if (!req.body.lieu_de_livraison || !req.body.mode_de_paiement || !req.body.id_client) {
        return res.status(400).json({ 
          success: false, 
          error: "Lieu de livraison, mode de paiement et ID client sont requis" 
        });
      }
      
      if (!req.body.produits || !Array.isArray(req.body.produits) || req.body.produits.length === 0) {
        return res.status(400).json({ 
          success: false, 
          error: "La commande doit contenir au moins un produit" 
        });
      }
      
      // VÃ©rifier que chaque produit a un id_produit et une quantitÃ© valide
      const produitsInvalides = req.body.produits.filter(
        produit => !produit.id_produit || !produit.quantite || produit.quantite < 1
      );
      
      if (produitsInvalides.length > 0) {
        return res.status(400).json({ 
          success: false, 
          error: "Certains produits ont des donnÃ©es invalides (id_produit ou quantitÃ© manquants)" 
        });
      }
      
      try {
        const commande = await commandesService.createCommande(req.body);
        
        if (!commande || !commande.id_commande) {
          return res.status(500).json({ 
            success: false, 
            error: "Erreur lors de la crÃ©ation de la commande: commande invalide retournÃ©e par le service" 
          });
        }
        
        // RÃ©cupÃ©rer la commande complÃ¨te avec les produits
        const commandeComplete = await commandesService.getCommandeById(commande.id_commande);
        
        res.status(201).json({ success: true, commande: commandeComplete });
      } catch (serviceError) {
        console.error("Erreur service commande:", serviceError);
        return res.status(500).json({ 
          success: false, 
          error: `Erreur du service lors de la crÃ©ation de la commande: ${serviceError.message}` 
        });
      }
    } catch (error) {
      console.error("Erreur globale crÃ©ation commande:", error);
      res.status(400).json({ 
        success: false, 
        error: `Erreur lors de la crÃ©ation de la commande: ${error.message || "Erreur inconnue"}`,
        details: error.stack
      });
    }
  },

  getCommandeById: async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de commande invalide" 
        });
      }
      
      const commande = await commandesService.getCommandeById(id);
      res.json({ success: true, commande });
    } catch (error) {
      if (error.message === "Commande non trouvÃ©e") {
        return res.status(404).json({ success: false, error: "Commande non trouvÃ©e" });
      }
      res.status(500).json({ success: false, error: "Erreur lors de la rÃ©cupÃ©ration de la commande" });
    }
  },

  getClientCommandes: async (req, res) => {
    try {
      const clientId = parseInt(req.params.clientId);
      
      if (isNaN(clientId)) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de client invalide" 
        });
      }
      
      const commandes = await commandesService.getClientCommandes(clientId);
      
      res.json({ success: true, commandes });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la rÃ©cupÃ©ration des commandes",
        details: error.message
      });
    }
  },

  getCommandesByStatus: async (req, res) => {
    try {
      const { status } = req.params;
      
      if (!status) {
        return res.status(400).json({ 
          success: false, 
          error: "Statut de commande requis" 
        });
      }
      
      const commandes = await commandesService.getCommandesByStatus(status);
      res.json({ success: true, commandes });
    } catch (error) {
      res.status(500).json({ success: false, error: "Erreur lors de la rÃ©cupÃ©ration des commandes" });
    }
  },

  getCommandeProducts: async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de commande invalide" 
        });
      }
      
      // VÃ©rifier d'abord si la commande existe
      try {
        await commandesService.getCommandeById(id);
      } catch (error) {
        if (error.message === "Commande non trouvÃ©e") {
          return res.status(404).json({ success: false, error: "Commande non trouvÃ©e" });
        }
        throw error;
      }
      
      const produits = await commandesService.getCommandeProducts(id);
      res.json({ success: true, produits });
    } catch (error) {
      res.status(500).json({ success: false, error: "Erreur lors de la rÃ©cupÃ©ration des produits de la commande" });
    }
  },

  updateCommandeStatus: async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { etat_commande } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de commande invalide" 
        });
      }
      
      if (!etat_commande) {
        return res.status(400).json({ 
          success: false, 
          error: "L'Ã©tat de la commande est requis" 
        });
      }
      
      const updatedCommande = await commandesService.updateCommandeStatus(id, etat_commande);
      
      res.json({ 
        success: true, 
        message: "Ã‰tat de la commande mis Ã  jour avec succÃ¨s",
        data: updatedCommande
      });
    } catch (error) {
      // Gestion spÃ©cifique des erreurs
      if (error.message.includes("Ã‰tat de commande invalide")) {
        return res.status(400).json({ 
          success: false, 
          error: "Ã‰tat de commande invalide" 
        });
      } else if (error.message === "Commande non trouvÃ©e") {
        return res.status(404).json({ 
          success: false, 
          error: "Commande non trouvÃ©e" 
        });
      }
      
      // Erreur gÃ©nÃ©rique
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la mise Ã  jour de l'Ã©tat de la commande" 
      });
    }
  },

  updateLivraisonDate: async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { date_livraison } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de commande invalide" 
        });
      }
      
      if (!date_livraison) {
        return res.status(400).json({ 
          success: false, 
          error: "La date de livraison est requise" 
        });
      }
      
      const updatedCommande = await commandesService.updateLivraisonDate(id, date_livraison);
      
      res.json({ 
        success: true, 
        message: "Date de livraison mise Ã  jour avec succÃ¨s",
        data: updatedCommande
      });
    } catch (error) {
      if (error.message === "Commande non trouvÃ©e") {
        return res.status(404).json({ 
          success: false, 
          error: "Commande non trouvÃ©e" 
        });
      } else if (error.message === "Date de livraison invalide") {
        return res.status(400).json({ 
          success: false, 
          error: "Date de livraison invalide" 
        });
      }
      
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la mise Ã  jour de la date de livraison" 
      });
    }
  },

  updateCommandeStatusAndDate: async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { etat_commande, date_livraison } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de commande invalide" 
        });
      }
      
      if (!etat_commande) {
        return res.status(400).json({ 
          success: false, 
          error: "L'Ã©tat de la commande est requis" 
        });
      }
      
      const updatedCommande = await commandesService.updateCommandeStatusAndDate(id, etat_commande, date_livraison);
      
      res.json({ 
        success: true, 
        message: "Commande mise Ã  jour avec succÃ¨s",
        data: updatedCommande
      });
    } catch (error) {
      if (error.message.includes("Ã‰tat de commande invalide")) {
        return res.status(400).json({ 
          success: false, 
          error: "Ã‰tat de commande invalide" 
        });
      } else if (error.message === "Commande non trouvÃ©e") {
        return res.status(404).json({ 
          success: false, 
          error: "Commande non trouvÃ©e" 
        });
      } else if (error.message === "Date de livraison invalide") {
        return res.status(400).json({ 
          success: false, 
          error: "Date de livraison invalide" 
        });
      }
      
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la mise Ã  jour de la commande" 
      });
    }
  }
};

module.exports = commandesController;


================================================
File: modules/marketing_commercial/controllers/produits.controller.js
================================================
const produitsService = require('../services/produits.service');

const produitsController = {
  getEquipementsByFamille: async (req, res) => {
    try {
      const { familleId } = req.params;
      const produits = await produitsService.getEquipementsByFamille(familleId);
      res.json({ success: true, produits });
    } catch (error) {
      res.status(400).json({ success: false, error: error.message });
    }
  },

  getAllEquipements: async (req, res) => {
    try {
      const produits = await produitsService.getAllEquipements();
      res.json({ success: true, produits });
    } catch (error) {
      res.status(400).json({ success: false, error: error.message });
    }
  },

  getLatestProducts: async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit) : 5;
      const produits = await produitsService.getLatestProducts(limit);
      res.json({ success: true, produits });
    } catch (error) {
      res.status(400).json({ success: false, error: error.message });
    }
  },

  getProductDetails: async (req, res) => {
    try {
      const { productId } = req.params;
      const produit = await produitsService.getProductDetails(productId);
      res.json({ success: true, produit });
    } catch (error) {
      res.status(404).json({ success: false, error: error.message });
    }
  },

  getAllFamilles: async (req, res) => {
    try {
      const familles = await produitsService.getAllFamilles();
      res.json({ success: true, familles });
    } catch (error) {
      res.status(400).json({ success: false, error: error.message });
    }
  },

  // RÃ©cupÃ©rer des produits similaires basÃ©s sur le libellÃ©
  getSimilarProductsByLibelle: async (req, res) => {
    try {
      const { productId } = req.params;
      const limit = req.query.limit ? parseInt(req.query.limit) : 4;
      
      const produits = await produitsService.getSimilarProductsByLibelle(productId, limit);
      res.json({ success: true, produits });
    } catch (error) {
      // Si le produit n'est pas trouvÃ©, renvoyer 404
      if (error.message.includes("trouvÃ©")) {
        return res.status(404).json({ success: false, error: error.message });
      }
      // Pour les autres erreurs, renvoyer 400
      res.status(400).json({ success: false, error: error.message });
    }
  },
};

module.exports = produitsController;


================================================
File: modules/marketing_commercial/controllers/services_dcat.controller.js
================================================
const servicesDcatService = require('../services/services_dcat.service');
const path = require('path');
const fs = require('fs').promises;

const servicesDcatController = {
  getAllServices: async (req, res) => {
    try {
      const services = await servicesDcatService.getAllServices();
      res.json({ success: true, data: services });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la rÃ©cupÃ©ration des services" 
      });
    }
  },

  getServiceById: async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ success: false, error: "ID invalide" });
    }

    try {
      const service = await servicesDcatService.getServiceById(id);
      if (!service) {
        return res.status(404).json({ success: false, error: "Service non trouvÃ©" });
      }
      res.json({ success: true, data: service });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la rÃ©cupÃ©ration du service" 
      });
    }
  },

  createService: async (req, res) => {
    let uploadedImagePath = null;

    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          error: "L'image est requise" 
        });
      }

      if (!req.body.titre_service || !req.body.sous_titre_service || !req.body.detail) {
        // Si l'image a Ã©tÃ© uploadÃ©e mais que les autres donnÃ©es sont manquantes,
        // on supprime l'image pour Ã©viter de la conserver inutilement
        if (req.file && req.file.path) {
          await fs.unlink(req.file.path);
        }
        
        return res.status(400).json({ 
          success: false, 
          error: "le titre, sous-titre et detail sont requis",
          received: {
            titre_service: !!req.body.titre_service,
            sous_titre_service: !!req.body.sous_titre_service,
            detail: !!req.body.detail
          }
        });
      }

      if (req.body.titre_service.length > 100) {
        // Supprimer l'image si la validation Ã©choue
        if (req.file && req.file.path) {
          await fs.unlink(req.file.path);
        }
        
        return res.status(400).json({
          success: false,
          error: "Le titre ne doit pas dÃ©passer 50 caractÃ¨res"
        });
      }
      
      if (req.body.sous_titre_service.length > 200) {
        // Supprimer l'image si la validation Ã©choue
        if (req.file && req.file.path) {
          await fs.unlink(req.file.path);
        }
        
        return res.status(400).json({
          success: false,
          error: "Le sous-titre ne doit pas dÃ©passer 50 caractÃ¨res"
        });
      }

      const relativePath = path.join('media/images/services_dcat', req.file.filename)
        .replace(/\\/g, '/');
      
      // Sauvegarder le chemin complet de l'image pour pouvoir la supprimer en cas d'erreur
      uploadedImagePath = path.join(process.cwd(), relativePath);

      const serviceData = {
        titre: req.body.titre_service.trim(),
        sous_titre: req.body.sous_titre_service.trim(),
        detail: req.body.detail.trim(),
        image: relativePath
      };

      const service = await servicesDcatService.createService(serviceData);
      res.status(201).json({ success: true, data: service });
    } catch (error) {
      // En cas d'erreur, on supprime l'image si elle a Ã©tÃ© uploadÃ©e
      if (uploadedImagePath) {
        try {
          await fs.unlink(uploadedImagePath);
        } catch (unlinkError) {
          // Si la suppression de l'image Ã©choue, on ne fait rien de plus
        }
      }
      
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la crÃ©ation du service",
        details: error.message
      });
    }
  },

  updateService: async (req, res) => {
    const id = parseInt(req.params.id);
    let uploadedImagePath = null;
    
    if (isNaN(id)) {
      // Supprimer l'image si la validation Ã©choue et qu'une nouvelle image a Ã©tÃ© envoyÃ©e
      if (req.file && req.file.path) {
        await fs.unlink(req.file.path);
      }
      
      return res.status(400).json({ success: false, error: "ID invalide" });
    }

    try {
      if (!req.body.titre_service || !req.body.detail || !req.body.sous_titre_service) {
        // Supprimer l'image si la validation Ã©choue et qu'une nouvelle image a Ã©tÃ© envoyÃ©e
        if (req.file && req.file.path) {
          await fs.unlink(req.file.path);
        }
        
        return res.status(400).json({ 
          success: false, 
          error: "Titre, sous-titre et detail sont requis" 
        });
      }

      if (req.body.titre_service.length > 50) {
        // Supprimer l'image si la validation Ã©choue et qu'une nouvelle image a Ã©tÃ© envoyÃ©e
        if (req.file && req.file.path) {
          await fs.unlink(req.file.path);
        }
        
        return res.status(400).json({
          success: false,
          error: "Le titre ne doit pas dÃ©passer 50 caractÃ¨res"
        });
      }
      
      if (req.body.sous_titre_service.length > 50) {
        // Supprimer l'image si la validation Ã©choue et qu'une nouvelle image a Ã©tÃ© envoyÃ©e
        if (req.file && req.file.path) {
          await fs.unlink(req.file.path);
        }
        
        return res.status(400).json({
          success: false,
          error: "Le sous-titre ne doit pas dÃ©passer 50 caractÃ¨res"
        });
      }

      const serviceData = {
        titre: req.body.titre_service.trim(),
        sous_titre: req.body.sous_titre_service.trim(),
        detail: req.body.detail.trim()
      };

      if (req.file) {
        const relativePath = path.join('media/images/services_dcat', req.file.filename)
          .replace(/\\/g, '/');
        serviceData.image = relativePath;
        
        // Sauvegarder le chemin complet de l'image pour pouvoir la supprimer en cas d'erreur
        uploadedImagePath = path.join(process.cwd(), relativePath);
      }

      const service = await servicesDcatService.updateService(id, serviceData);
      if (!service) {
        // Supprimer l'image si le service n'existe pas et qu'une nouvelle image a Ã©tÃ© envoyÃ©e
        if (uploadedImagePath) {
          await fs.unlink(uploadedImagePath);
        }
        
        return res.status(404).json({ success: false, error: "Service non trouvÃ©" });
      }
      
      res.json({ success: true, data: service });
    } catch (error) {
      // En cas d'erreur, on supprime la nouvelle image si elle a Ã©tÃ© uploadÃ©e
      if (uploadedImagePath) {
        try {
          await fs.unlink(uploadedImagePath);
        } catch (unlinkError) {
          // Si la suppression de l'image Ã©choue, on ne fait rien de plus
        }
      }
      
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la mise Ã  jour du service",
        details: error.message
      });
    }
  },

  deleteService: async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ success: false, error: "ID invalide" });
    }

    try {
      const deleted = await servicesDcatService.deleteService(id);
      if (!deleted) {
        return res.status(404).json({ success: false, error: "Service non trouvÃ©" });
      }
      res.json({ success: true, message: "Service supprimÃ© avec succÃ¨s" });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: "Erreur lors de la suppression du service",
        details: error.message 
      });
    }
  },
  
  /**
   * TÃ©lÃ©charge une image en conservant son nom original
   * Cet endpoint est utilisÃ© spÃ©cifiquement pour importer des images
   * de services DCAT sans modifier leur nom
   */
  uploadServiceImage: async (req, res) => {
    try {
      // VÃ©rifier qu'une image a Ã©tÃ© envoyÃ©e
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          error: "Aucune image n'a Ã©tÃ© tÃ©lÃ©chargÃ©e" 
        });
      }
      
      // Construire le chemin relatif de l'image
      const relativePath = path.join('media/images/services_dcat', req.file.originalname)
        .replace(/\\/g, '/');
      
      // Retourner le chemin d'accÃ¨s de l'image
      return res.status(201).json({
        success: true,
        imagePath: relativePath,
        message: "Image tÃ©lÃ©chargÃ©e avec succÃ¨s"
      });
    } catch (error) {
      // En cas d'erreur, on supprime l'image si elle a Ã©tÃ© uploadÃ©e
      if (req.file && req.file.path) {
        try {
          await fs.unlink(req.file.path);
        } catch (unlinkError) {
          // Si la suppression de l'image Ã©choue, on ne fait rien de plus
        }
      }
      
      return res.status(500).json({
        success: false,
        error: "Erreur lors du tÃ©lÃ©chargement de l'image",
        details: error.message
      });
    }
  }
};

module.exports = servicesDcatController;


================================================
File: modules/marketing_commercial/routes/affiches.routes.js
================================================
const express = require('express');
const router = express.Router();
const affichesController = require('../controllers/affiches.controller');
const uploadMiddleware = require('../../utils/middleware/uploadMiddleware');
const path = require('path');

// Configuration du chemin d'upload
router.use((req, res, next) => {
  req.uploadPath = path.join(process.cwd(), 'media/images/affiches_dcat');
  next();
});

/**
 * @swagger
 * components:
 *   schemas:
 *     Affiche:
 *       type: object
 *       properties:
 *         id_affiche:
 *           type: integer
 *           description: ID unique de l'affiche
 *         image:
 *           type: string
 *           description: Chemin vers l'image de l'affiche
 *         titre_promotion:
 *           type: string
 *           description: Titre principal de l'affiche promotionnelle
 *         sous_titre_promotion:
 *           type: string
 *           description: Sous-titre de l'affiche promotionnelle
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date de crÃ©ation de l'affiche
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: DerniÃ¨re date de mise Ã  jour de l'affiche
 * 
 * /api/marketing_commercial/affiches:
 *   get:
 *     summary: Liste toutes les affiches
 *     description: Retourne la liste complÃ¨te des affiches promotionnelles
 *     tags: [Affiches]
 *     responses:
 *       200:
 *         description: Liste des affiches rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Affiche'
 *       500:
 *         description: Erreur serveur
 */
router.get('/', affichesController.getAllAffiches);

/**
 * @swagger
 * /api/marketing_commercial/affiches/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une affiche par son ID
 *     description: Retourne les dÃ©tails d'une affiche promotionnelle spÃ©cifique
 *     tags: [Affiches]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'affiche
 *     responses:
 *       200:
 *         description: Affiche rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Affiche'
 *       404:
 *         description: Affiche non trouvÃ©e
 *       400:
 *         description: ID invalide
 *       500:
 *         description: Erreur serveur
 */
router.get('/:id', affichesController.getAfficheById);

/**
 * @swagger
 * /api/marketing_commercial/affiches:
 *   post:
 *     summary: CrÃ©e une nouvelle affiche
 *     description: Ajoute une nouvelle affiche promotionnelle avec image et textes
 *     tags: [Affiches]
 *     consumes:
 *       - multipart/form-data
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - image
 *               - titre_promotion
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: Fichier image de l'affiche (JPG, PNG)
 *               titre_promotion:
 *                 type: string
 *                 description: Titre principal de l'affiche
 *               sous_titre_promotion:
 *                 type: string
 *                 description: Sous-titre ou description de l'affiche
 *     responses:
 *       201:
 *         description: Affiche crÃ©Ã©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Affiche'
 *                 message:
 *                   type: string
 *                   example: Affiche crÃ©Ã©e avec succÃ¨s
 *       400:
 *         description: DonnÃ©es invalides
 *       500:
 *         description: Erreur serveur ou erreur d'upload
 */
router.post('/', uploadMiddleware.single('image'), affichesController.createAffiche);

/**
 * @swagger
 * /api/marketing_commercial/affiches/{id}:
 *   put:
 *     summary: Met Ã  jour une affiche
 *     description: Modifie une affiche promotionnelle existante
 *     tags: [Affiches]
 *     consumes:
 *       - multipart/form-data
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'affiche Ã  modifier
 *     requestBody:
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: Nouvelle image (optionnelle)
 *               titre_promotion:
 *                 type: string
 *                 description: Nouveau titre de l'affiche
 *               sous_titre_promotion:
 *                 type: string
 *                 description: Nouveau sous-titre de l'affiche
 *     responses:
 *       200:
 *         description: Affiche mise Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Affiche'
 *                 message:
 *                   type: string
 *                   example: Affiche mise Ã  jour avec succÃ¨s
 *       404:
 *         description: Affiche non trouvÃ©e
 *       400:
 *         description: DonnÃ©es invalides
 *       500:
 *         description: Erreur serveur ou erreur d'upload
 */
router.put('/:id', uploadMiddleware.single('image'), affichesController.updateAffiche);

/**
 * @swagger
 * /api/marketing_commercial/affiches/{id}:
 *   delete:
 *     summary: Supprime une affiche
 *     description: Supprime dÃ©finitivement une affiche promotionnelle et son image
 *     tags: [Affiches]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'affiche Ã  supprimer
 *     responses:
 *       200:
 *         description: Affiche supprimÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Affiche supprimÃ©e avec succÃ¨s
 *       404:
 *         description: Affiche non trouvÃ©e
 *       400:
 *         description: ID invalide
 *       500:
 *         description: Erreur serveur
 */
router.delete('/:id', affichesController.deleteAffiche);

module.exports = router;


================================================
File: modules/marketing_commercial/routes/clients.routes.js
================================================
const express = require("express");
const router = express.Router();
const clientsController = require("../controllers/clients.controller");

/**
 * @swagger
 * /api/marketing_commercial/clients/login:
 *   post:
 *     summary: Connecte un client
 *     description: Authentifie un client et renvoie un token d'accÃ¨s
 *     tags: [Clients]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 description: Adresse email du client
 *               password:
 *                 type: string
 *                 format: password
 *                 description: Mot de passe du client
 *     responses:
 *       200:
 *         description: Connexion rÃ©ussie
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 client:
 *                   $ref: '#/components/schemas/Client'
 *                 token:
 *                   type: string
 *                   description: JWT pour authentifier les requÃªtes ultÃ©rieures
 *                 refreshToken:
 *                   type: string
 *                   description: Token permettant de rafraÃ®chir le token d'accÃ¨s
 *       400:
 *         description: Identifiants invalides
 *       500:
 *         description: Erreur serveur
 */
router.post('/login', clientsController.login);

/**
 * @swagger
 * /api/marketing_commercial/clients/register:
 *   post:
 *     summary: Enregistre un nouveau client
 *     description: CrÃ©e un nouveau compte client
 *     tags: [Clients]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - nom
 *               - email
 *               - password
 *             properties:
 *               nom:
 *                 type: string
 *                 description: Nom complet du client
 *               email:
 *                 type: string
 *                 format: email
 *                 description: Adresse email du client
 *               password:
 *                 type: string
 *                 format: password
 *                 description: Mot de passe du client
 *               contact:
 *                 type: string
 *                 description: NumÃ©ro de tÃ©lÃ©phone du client
 *     responses:
 *       201:
 *         description: Client enregistrÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 client:
 *                   $ref: '#/components/schemas/Client'
 *                 token:
 *                   type: string
 *                   description: JWT pour authentifier les requÃªtes ultÃ©rieures
 *       400:
 *         description: DonnÃ©es invalides ou email dÃ©jÃ  utilisÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post('/register', clientsController.register);

/**
 * @swagger
 * /api/marketing_commercial/clients/verify-token:
 *   get:
 *     summary: VÃ©rifie la validitÃ© d'un token
 *     description: VÃ©rifie si le token d'authentification fourni est valide
 *     tags: [Clients]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Token valide
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 client:
 *                   $ref: '#/components/schemas/Client'
 *       401:
 *         description: Token invalide ou expirÃ©
 */
router.get('/verify-token', clientsController.verifyToken);

/**
 * @swagger
 * /api/marketing_commercial/clients/refresh-token:
 *   post:
 *     summary: RafraÃ®chit un token d'authentification
 *     description: GÃ©nÃ¨re un nouveau token d'accÃ¨s Ã  partir d'un refresh token
 *     tags: [Clients]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - refreshToken
 *             properties:
 *               refreshToken:
 *                 type: string
 *                 description: Refresh token prÃ©cÃ©demment obtenu
 *     responses:
 *       200:
 *         description: Nouveau token gÃ©nÃ©rÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 token:
 *                   type: string
 *                   description: Nouveau JWT pour authentifier les requÃªtes ultÃ©rieures
 *       401:
 *         description: Refresh token invalide ou expirÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post('/refresh-token', clientsController.refreshToken);

/**
 * @swagger
 * /api/marketing_commercial/clients/logout:
 *   post:
 *     summary: DÃ©connecte un client
 *     description: Invalide le refresh token du client
 *     tags: [Clients]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               refreshToken:
 *                 type: string
 *                 description: Refresh token Ã  invalider
 *     responses:
 *       200:
 *         description: DÃ©connexion rÃ©ussie
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: DÃ©connexion rÃ©ussie
 *       400:
 *         description: Refresh token non fourni
 *       500:
 *         description: Erreur serveur
 */
router.post('/logout', clientsController.logout);

/**
 * @swagger
 * /api/marketing_commercial/clients/admin/all:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les clients
 *     description: Liste tous les clients enregistrÃ©s (fonctionnalitÃ© admin)
 *     tags: [Clients Admin]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Liste des clients rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 clients:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Client'
 *       401:
 *         description: Non autorisÃ©
 *       500:
 *         description: Erreur serveur
 */
router.get('/admin/all', clientsController.getAllClients);

module.exports = router;



================================================
File: modules/marketing_commercial/routes/commandes.routes.js
================================================
const express = require('express');
const router = express.Router();
const commandesController = require('../controllers/commandes.controller');

/**
 * @swagger
 * components:
 *   schemas:
 *     ProduitCommande:
 *       type: object
 *       required:
 *         - id_produit
 *         - quantite
 *       properties:
 *         id_produit:
 *           type: integer
 *           description: ID du produit Ã  commander
 *         quantite:
 *           type: integer
 *           description: QuantitÃ© du produit Ã  commander
 *           minimum: 1
 *     Commande:
 *       type: object
 *       properties:
 *         id_commande:
 *           type: integer
 *           description: ID unique de la commande
 *         date_de_commande:
 *           type: string
 *           format: date
 *           description: Date Ã  laquelle la commande a Ã©tÃ© passÃ©e
 *         etat_commande:
 *           type: string
 *           description: Ã‰tat actuel de la commande (En attente, En cours, LivrÃ©e, AnnulÃ©e)
 *         date_livraison:
 *           type: string
 *           format: date
 *           description: Date prÃ©vue de livraison
 *         lieu_de_livraison:
 *           type: string
 *           description: Adresse de livraison de la commande
 *         mode_de_paiement:
 *           type: string
 *           description: MÃ©thode de paiement utilisÃ©e
 *         id_client:
 *           type: integer
 *           description: ID du client qui a passÃ© la commande
 *         montant_total:
 *           type: number
 *           format: float
 *           description: Montant total de la commande
 *         produits:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/ProduitDetail'
 *           description: Liste des produits dans la commande
 *     ProduitDetail:
 *       type: object
 *       properties:
 *         id_produit:
 *           type: integer
 *           description: ID du produit
 *         designation:
 *           type: string
 *           description: Nom du produit
 *         description:
 *           type: string
 *           description: Description du produit
 *         prix:
 *           type: number
 *           format: float
 *           description: Prix unitaire du produit
 *         quantite:
 *           type: integer
 *           description: QuantitÃ© commandÃ©e
 *         image:
 *           type: string
 *           description: URL de l'image du produit
 *         caracteristiques:
 *           type: string
 *           description: CaractÃ©ristiques techniques du produit
 *         famille_libelle:
 *           type: string
 *           description: LibellÃ© de la famille du produit
 *         marque_libelle:
 *           type: string
 *           description: LibellÃ© de la marque du produit
 *         modele_libelle:
 *           type: string
 *           description: LibellÃ© du modÃ¨le du produit
 * 
 * /api/marketing_commercial/commandes:
 *   post:
 *     summary: CrÃ©e une nouvelle commande
 *     description: CrÃ©e une nouvelle commande avec les produits spÃ©cifiÃ©s
 *     tags: [Commandes Marketing]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - lieu_de_livraison
 *               - mode_de_paiement
 *               - id_client
 *               - produits
 *             properties:
 *               lieu_de_livraison:
 *                 type: string
 *                 description: Adresse de livraison
 *               mode_de_paiement:
 *                 type: string
 *                 description: MÃ©thode de paiement (EspÃ¨ce, Wave, Orange Money, etc.)
 *               id_client:
 *                 type: integer
 *                 description: ID du client qui passe la commande
 *               produits:
 *                 type: array
 *                 items:
 *                   $ref: '#/components/schemas/ProduitCommande'
 *                 description: Liste des produits Ã  commander
 *     responses:
 *       201:
 *         description: Commande crÃ©Ã©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 commande:
 *                   $ref: '#/components/schemas/Commande'
 *       400:
 *         description: DonnÃ©es de commande invalides
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 error:
 *                   type: string
 *       500:
 *         description: Erreur serveur
 */
router.post('/', commandesController.createCommande);

/**
 * @swagger
 * /api/marketing_commercial/commandes/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une commande par son ID
 *     description: Retourne les dÃ©tails d'une commande spÃ©cifique avec ses produits
 *     tags: [Commandes Marketing]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la commande
 *     responses:
 *       200:
 *         description: Commande rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 commande:
 *                   $ref: '#/components/schemas/Commande'
 *       404:
 *         description: Commande non trouvÃ©e
 *       400:
 *         description: ID de commande invalide
 */
router.get('/:id', commandesController.getCommandeById);

/**
 * @swagger
 * /api/marketing_commercial/commandes/client/{clientId}:
 *   get:
 *     summary: RÃ©cupÃ¨re les commandes d'un client
 *     description: Retourne l'historique des commandes d'un client spÃ©cifique
 *     tags: [Commandes Marketing]
 *     parameters:
 *       - in: path
 *         name: clientId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du client
 *     responses:
 *       200:
 *         description: Commandes rÃ©cupÃ©rÃ©es avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 commandes:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Commande'
 *       400:
 *         description: ID de client invalide
 *       500:
 *         description: Erreur serveur
 */
router.get('/client/:clientId', commandesController.getClientCommandes);

/**
 * @swagger
 * /api/marketing_commercial/commandes/status/{status}:
 *   get:
 *     summary: RÃ©cupÃ¨re les commandes par statut
 *     description: Retourne toutes les commandes ayant un statut spÃ©cifique
 *     tags: [Commandes Marketing]
 *     parameters:
 *       - in: path
 *         name: status
 *         required: true
 *         schema:
 *           type: string
 *           enum: [En attente, En cours, LivrÃ©e, AnnulÃ©e]
 *         description: Statut des commandes Ã  rÃ©cupÃ©rer
 *     responses:
 *       200:
 *         description: Commandes rÃ©cupÃ©rÃ©es avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 commandes:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Commande'
 *       400:
 *         description: Statut invalide
 *       500:
 *         description: Erreur serveur
 */
router.get('/status/:status', commandesController.getCommandesByStatus);

/**
 * @swagger
 * /api/marketing_commercial/commandes/{id}/products:
 *   get:
 *     summary: RÃ©cupÃ¨re les produits d'une commande
 *     description: Retourne la liste dÃ©taillÃ©e des produits dans une commande spÃ©cifique
 *     tags: [Commandes Marketing]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la commande
 *     responses:
 *       200:
 *         description: Produits rÃ©cupÃ©rÃ©s avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 produits:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/ProduitDetail'
 *       404:
 *         description: Commande non trouvÃ©e
 *       400:
 *         description: ID de commande invalide
 *       500:
 *         description: Erreur serveur
 */
router.get('/:id/products', commandesController.getCommandeProducts);

/**
 * @swagger
 * /api/marketing_commercial/commandes/{id}/update-status:
 *   patch:
 *     summary: Met Ã  jour le statut d'une commande
 *     description: Modifie le statut d'une commande existante
 *     tags: [Commandes Marketing]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la commande
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - etat_commande
 *             properties:
 *               etat_commande:
 *                 type: string
 *                 enum: [En attente, En cours, LivrÃ©e, AnnulÃ©e]
 *                 description: Nouveau statut de la commande
 *     responses:
 *       200:
 *         description: Statut mis Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Ã‰tat de la commande mis Ã  jour avec succÃ¨s
 *                 data:
 *                   $ref: '#/components/schemas/Commande'
 *       400:
 *         description: DonnÃ©es invalides
 *       404:
 *         description: Commande non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.patch('/:id/update-status', commandesController.updateCommandeStatus);

/**
 * @swagger
 * /api/marketing_commercial/commandes/{id}/update-date:
 *   patch:
 *     summary: Met Ã  jour la date de livraison d'une commande
 *     description: Modifie la date de livraison prÃ©vue d'une commande existante
 *     tags: [Commandes Marketing]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la commande
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - date_livraison
 *             properties:
 *               date_livraison:
 *                 type: string
 *                 format: date
 *                 description: Nouvelle date de livraison (YYYY-MM-DD)
 *     responses:
 *       200:
 *         description: Date de livraison mise Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Date de livraison mise Ã  jour avec succÃ¨s
 *                 data:
 *                   $ref: '#/components/schemas/Commande'
 *       400:
 *         description: DonnÃ©es invalides
 *       404:
 *         description: Commande non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.patch('/:id/update-date', commandesController.updateLivraisonDate);

/**
 * @swagger
 * /api/marketing_commercial/commandes/{id}/update:
 *   patch:
 *     summary: Met Ã  jour le statut et la date de livraison d'une commande
 *     description: Modifie Ã  la fois le statut et la date de livraison d'une commande existante
 *     tags: [Commandes Marketing]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la commande
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - etat_commande
 *             properties:
 *               etat_commande:
 *                 type: string
 *                 enum: [En attente, En cours, LivrÃ©e, AnnulÃ©e]
 *                 description: Nouveau statut de la commande
 *               date_livraison:
 *                 type: string
 *                 format: date
 *                 description: Nouvelle date de livraison (YYYY-MM-DD)
 *     responses:
 *       200:
 *         description: Commande mise Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Commande mise Ã  jour avec succÃ¨s
 *                 data:
 *                   $ref: '#/components/schemas/Commande'
 *       400:
 *         description: DonnÃ©es invalides
 *       404:
 *         description: Commande non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.patch('/:id/update', commandesController.updateCommandeStatusAndDate);

module.exports = router;


================================================
File: modules/marketing_commercial/routes/marketing_commercial.routes.js
================================================
const express = require("express");
const router = express.Router();


// Import des sous-routes
const clientsRoutes = require("./clients.routes");
const produitsRoutes = require("./produits.routes");
const commandesRoutes = require("./commandes.routes");
const servicesDcatRoutes = require("./services_dcat.routes");
const affichesRoutes = require("./affiches.routes");

/**
 * @swagger
 * /api/marketing_commercial/clients:
 *   description: Routes liÃ©es aux clients
 *   get:
 *     summary: AccÃ¨de Ã  la gestion des clients
 *     tags: [Clients]
 */
router.use("/clients", clientsRoutes);

/**
 * @swagger
 * /api/marketing_commercial/produits:
 *   description: Routes liÃ©es aux produits marketing
 *   get:
 *     summary: AccÃ¨de au catalogue de produits marketing
 *     tags: [Produits Marketing]
 */
router.use("/produits", produitsRoutes);

/**
 * @swagger
 * /api/marketing_commercial/commandes:
 *   description: Routes liÃ©es aux commandes marketing
 *   get:
 *     summary: AccÃ¨de aux commandes clients marketing
 *     tags: [Commandes Marketing]
 */
router.use("/commandes", commandesRoutes);

/**
 * @swagger
 * /api/marketing_commercial/services:
 *   description: Routes liÃ©es aux services DCAT
 *   get:
 *     summary: AccÃ¨de aux services proposÃ©s par DCAT
 *     tags: [Services DCAT]
 */
router.use("/services", servicesDcatRoutes);

/**
 * @swagger
 * /api/marketing_commercial/affiches:
 *   description: Routes liÃ©es aux affiches promotionnelles
 *   get:
 *     summary: AccÃ¨de aux affiches promotionnelles
 *     tags: [Affiches]
 */
router.use("/affiches", affichesRoutes);

module.exports = router;



================================================
File: modules/marketing_commercial/routes/produits.routes.js
================================================
const express = require('express');
const router = express.Router();
const produitsController = require('../controllers/produits.controller');

/**
 * @swagger
 * components:
 *   schemas:
 *     Produit:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           description: ID unique du produit
 *         designation:
 *           type: string
 *           description: Nom commercial du produit
 *         description:
 *           type: string
 *           description: Description dÃ©taillÃ©e du produit
 *         image:
 *           type: string
 *           description: Chemin vers l'image du produit
 *         prix:
 *           type: number
 *           format: float
 *           description: Prix de vente du produit
 *         caracteristiques:
 *           type: string
 *           description: CaractÃ©ristiques techniques du produit
 *         famille_id:
 *           type: integer
 *           description: ID de la famille du produit
 *         famille_libelle:
 *           type: string
 *           description: LibellÃ© de la famille du produit
 *     Famille:
 *       type: object
 *       properties:
 *         id_famille:
 *           type: integer
 *           description: ID unique de la famille
 *         libelle_famille:
 *           type: string
 *           description: Nom de la famille/catÃ©gorie
 *
 * /api/marketing_commercial/produits/famille/{familleId}:
 *   get:
 *     summary: RÃ©cupÃ¨re les Ã©quipements par famille
 *     description: Retourne tous les produits de type Ã©quipement appartenant Ã  une famille spÃ©cifique
 *     tags: [Produits Marketing]
 *     parameters:
 *       - in: path
 *         name: familleId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la famille de produits
 *     responses:
 *       200:
 *         description: Liste des produits rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 produits:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Produit'
 *       400:
 *         description: Erreur de requÃªte
 *       500:
 *         description: Erreur serveur
 */
router.get('/famille/:familleId', produitsController.getEquipementsByFamille);

/**
 * @swagger
 * /api/marketing_commercial/produits:
 *   get:
 *     summary: Liste tous les Ã©quipements
 *     description: Retourne tous les produits de type Ã©quipement disponibles dans le catalogue
 *     tags: [Produits Marketing]
 *     responses:
 *       200:
 *         description: Liste des Ã©quipements rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 produits:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Produit'
 *       400:
 *         description: Erreur de requÃªte
 *       500:
 *         description: Erreur serveur
 */
router.get('/', produitsController.getAllEquipements);

/**
 * @swagger
 * /api/marketing_commercial/produits/nouveautes:
 *   get:
 *     summary: RÃ©cupÃ¨re les derniers produits ajoutÃ©s
 *     description: Retourne les produits les plus rÃ©cemment ajoutÃ©s au catalogue
 *     tags: [Produits Marketing]
 *     parameters:
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 5
 *         description: Nombre maximum de produits Ã  retourner
 *     responses:
 *       200:
 *         description: Liste des nouveaux produits rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 produits:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Produit'
 *       400:
 *         description: Erreur de requÃªte
 *       500:
 *         description: Erreur serveur
 */
router.get('/nouveautes', produitsController.getLatestProducts);

/**
 * @swagger
 * /api/marketing_commercial/produits/{productId}/details:
 *   get:
 *     summary: RÃ©cupÃ¨re les dÃ©tails d'un produit
 *     description: Retourne les informations dÃ©taillÃ©es d'un produit spÃ©cifique
 *     tags: [Produits Marketing]
 *     parameters:
 *       - in: path
 *         name: productId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du produit
 *     responses:
 *       200:
 *         description: DÃ©tails du produit rÃ©cupÃ©rÃ©s avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 produit:
 *                   $ref: '#/components/schemas/Produit'
 *       404:
 *         description: Produit non trouvÃ©
 *       400:
 *         description: Erreur de requÃªte
 *       500:
 *         description: Erreur serveur
 */
router.get('/:productId/details', produitsController.getProductDetails);

/**
 * @swagger
 * /api/marketing_commercial/produits/familles:
 *   get:
 *     summary: Liste toutes les familles de produits
 *     description: Retourne toutes les familles/catÃ©gories disponibles pour les produits
 *     tags: [Produits Marketing]
 *     responses:
 *       200:
 *         description: Liste des familles rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 familles:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Famille'
 *       400:
 *         description: Erreur de requÃªte
 *       500:
 *         description: Erreur serveur
 */
router.get('/familles', produitsController.getAllFamilles);

/**
 * @swagger
 * /api/marketing_commercial/produits/{productId}/similaires:
 *   get:
 *     summary: RÃ©cupÃ¨re des produits similaires
 *     description: Utilise les mots-clÃ©s du libellÃ© et de la description pour trouver des produits similaires
 *     tags: [Produits Marketing]
 *     parameters:
 *       - in: path
 *         name: productId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du produit de rÃ©fÃ©rence
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 4
 *         description: Nombre maximum de produits similaires Ã  retourner
 *     responses:
 *       200:
 *         description: Liste des produits similaires rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 produits:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Produit'
 *       404:
 *         description: Produit de rÃ©fÃ©rence non trouvÃ©
 *       400:
 *         description: Erreur de requÃªte
 *       500:
 *         description: Erreur serveur
 */
router.get('/:productId/similaires', produitsController.getSimilarProductsByLibelle);

module.exports = router;


================================================
File: modules/marketing_commercial/routes/services_dcat.routes.js
================================================
const express = require('express');
const router = express.Router();
const servicesDcatController = require('../controllers/services_dcat.controller');
const uploadMiddleware = require('../../utils/middleware/uploadMiddleware');
const uploadOriginalNameMiddleware = require('../../utils/middleware/uploadOriginalNameMiddleware');
const path = require('path');

// Configuration du chemin d'upload
router.use((req, res, next) => {
  req.uploadPath = path.join(process.cwd(), 'media/images/services_dcat');
  next();
});

/**
 * @swagger
 * components:
 *   schemas:
 *     Service:
 *       type: object
 *       properties:
 *         id_service:
 *           type: integer
 *           description: ID unique du service
 *         titre_service:
 *           type: string
 *           description: Titre principal du service proposÃ©
 *         sous_titre_service:
 *           type: string
 *           description: Sous-titre ou brÃ¨ve description du service
 *         detail_service:
 *           type: string
 *           description: Description dÃ©taillÃ©e du service
 *         image_service:
 *           type: string
 *           description: Chemin vers l'image illustrant le service
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date de crÃ©ation du service
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: DerniÃ¨re date de mise Ã  jour du service
 *
 * /api/marketing_commercial/services:
 *   get:
 *     summary: Liste tous les services DCAT
 *     description: Retourne la liste complÃ¨te des services proposÃ©s par DCAT
 *     tags: [Services DCAT]
 *     responses:
 *       200:
 *         description: Liste des services rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 services:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Service'
 *       500:
 *         description: Erreur serveur
 */
router.get('/', servicesDcatController.getAllServices);

/**
 * @swagger
 * /api/marketing_commercial/services/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un service DCAT par son ID
 *     description: Retourne les dÃ©tails d'un service spÃ©cifique
 *     tags: [Services DCAT]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du service
 *     responses:
 *       200:
 *         description: Service rÃ©cupÃ©rÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 service:
 *                   $ref: '#/components/schemas/Service'
 *       404:
 *         description: Service non trouvÃ©
 *       400:
 *         description: ID invalide
 *       500:
 *         description: Erreur serveur
 */
router.get('/:id', servicesDcatController.getServiceById);

/**
 * @swagger
 * /api/marketing_commercial/services:
 *   post:
 *     summary: CrÃ©e un nouveau service DCAT
 *     description: Ajoute un nouveau service avec son image et sa description
 *     tags: [Services DCAT]
 *     consumes:
 *       - multipart/form-data
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - titre_service
 *               - detail_service
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: Image illustrant le service (JPG, PNG)
 *               titre_service:
 *                 type: string
 *                 description: Titre principal du service
 *               sous_titre_service:
 *                 type: string
 *                 description: Sous-titre ou brÃ¨ve description du service
 *               detail_service:
 *                 type: string
 *                 description: Description dÃ©taillÃ©e du service
 *     responses:
 *       201:
 *         description: Service crÃ©Ã© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 service:
 *                   $ref: '#/components/schemas/Service'
 *                 message:
 *                   type: string
 *                   example: Service crÃ©Ã© avec succÃ¨s
 *       400:
 *         description: DonnÃ©es invalides
 *       500:
 *         description: Erreur serveur ou erreur d'upload
 */
router.post('/', uploadMiddleware.single('image'), servicesDcatController.createService);

/**
 * @swagger
 * /api/marketing_commercial/services/{id}:
 *   put:
 *     summary: Met Ã  jour un service DCAT
 *     description: Modifie un service existant
 *     tags: [Services DCAT]
 *     consumes:
 *       - multipart/form-data
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du service Ã  modifier
 *     requestBody:
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: Nouvelle image (optionnelle)
 *               titre_service:
 *                 type: string
 *                 description: Nouveau titre du service
 *               sous_titre_service:
 *                 type: string
 *                 description: Nouveau sous-titre du service
 *               detail_service:
 *                 type: string
 *                 description: Nouvelle description dÃ©taillÃ©e du service
 *     responses:
 *       200:
 *         description: Service mis Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 service:
 *                   $ref: '#/components/schemas/Service'
 *                 message:
 *                   type: string
 *                   example: Service mis Ã  jour avec succÃ¨s
 *       404:
 *         description: Service non trouvÃ©
 *       400:
 *         description: DonnÃ©es invalides
 *       500:
 *         description: Erreur serveur ou erreur d'upload
 */
router.put('/:id', uploadMiddleware.single('image'), servicesDcatController.updateService);

/**
 * @swagger
 * /api/marketing_commercial/services/{id}:
 *   delete:
 *     summary: Supprime un service DCAT
 *     description: Supprime dÃ©finitivement un service et son image
 *     tags: [Services DCAT]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du service Ã  supprimer
 *     responses:
 *       200:
 *         description: Service supprimÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Service supprimÃ© avec succÃ¨s
 *       404:
 *         description: Service non trouvÃ©
 *       400:
 *         description: ID invalide
 *       500:
 *         description: Erreur serveur
 */
router.delete('/:id', servicesDcatController.deleteService);

/**
 * @swagger
 * /api/marketing_commercial/services/upload-image:
 *   post:
 *     summary: TÃ©lÃ©charge une image de service DCAT
 *     description: TÃ©lÃ©charge une image en conservant son nom original
 *     tags: [Services DCAT]
 *     consumes:
 *       - multipart/form-data
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - image
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: Image Ã  tÃ©lÃ©charger (JPG, PNG)
 *     responses:
 *       201:
 *         description: Image tÃ©lÃ©chargÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 imagePath:
 *                   type: string
 *                   example: "media/images/services_dcat/image.jpg"
 *                 message:
 *                   type: string
 *                   example: "Image tÃ©lÃ©chargÃ©e avec succÃ¨s"
 *       400:
 *         description: Aucune image envoyÃ©e ou format invalide
 *       500:
 *         description: Erreur serveur
 */
router.post('/upload-image', uploadOriginalNameMiddleware.single('image'), servicesDcatController.uploadServiceImage);

module.exports = router;


================================================
File: modules/marketing_commercial/services/affiches.service.js
================================================
const { db } = require('../../../core/database/config');
const { affiches } = require("../../../core/database/models");
const { eq, desc } = require("drizzle-orm");
const fs = require('fs').promises;

const affichesService = {
  getAllAffiches: async () => {
    return await db
      .select({
        id: affiches.id_affiche,
        titre: affiches.titre_promotion,
        sous_titre: affiches.sous_titre_promotion,
        image: affiches.image,
        created_at: affiches.created_at
      })
      .from(affiches)
      .orderBy(desc(affiches.created_at));
  },

  getAfficheById: async (id) => {
    const result = await db
      .select({
        id: affiches.id_affiche,
        titre: affiches.titre_promotion,
        sous_titre: affiches.sous_titre_promotion,
        image: affiches.image,
        created_at: affiches.created_at
      })
      .from(affiches)
      .where(eq(affiches.id_affiche, id))
      .limit(1);
    
    return result[0];
  },

  createAffiche: async (afficheData) => {
    const result = await db
      .insert(affiches)
      .values({
        titre_promotion: afficheData.titre,
        sous_titre_promotion: afficheData.sous_titre,
        image: afficheData.image
      })
      .returning();
    return result[0];
  },

  updateAffiche: async (id, afficheData) => {
    const affiche = await db
      .select()
      .from(affiches)
      .where(eq(affiches.id_affiche, id))
      .limit(1);

    if (affiche.length === 0) return null;

    // Suppression de l'ancienne image si une nouvelle est fournie
    if (afficheData.image && affiche[0].image) {
      try {
        await fs.unlink(affiche[0].image);
      } catch (error) {
        console.error("Erreur lors de la suppression de l'ancienne image:", error);
      }
    }

    const result = await db
      .update(affiches)
      .set({
        titre_promotion: afficheData.titre,
        sous_titre_promotion: afficheData.sous_titre,
        image: afficheData.image || affiche[0].image,
        updated_at: new Date()
      })
      .where(eq(affiches.id_affiche, id))
      .returning();
    
    return result[0];
  },

  deleteAffiche: async (id) => {
    const affiche = await db
      .select()
      .from(affiches)
      .where(eq(affiches.id_affiche, id))
      .limit(1);

    if (affiche.length === 0) return false;

    // Suppression du fichier image
    if (affiche[0].image) {
      try {
        await fs.unlink(affiche[0].image);
      } catch (error) {
        console.error("Erreur lors de la suppression de l'image:", error);
      }
    }

    await db.delete(affiches).where(eq(affiches.id_affiche, id));
    return true;
  }
};

module.exports = affichesService;


================================================
File: modules/marketing_commercial/services/clients.service.js
================================================
const { db } = require('../../../core/database/config');
const { clients_en_ligne } = require("../../../core/database/models");
const bcrypt = require('bcryptjs');
const { eq, or } = require("drizzle-orm");

const clientsService = {
  
  login: async ({ identifiant, password }) => {
    // Validation des champs
    if (!identifiant || !password) {
      throw new Error("L'identifiant et le mot de passe sont requis");
    }

    const user = await db.select().from(clients_en_ligne)
      .where(
        or(
          eq(clients_en_ligne.email, identifiant),
          eq(clients_en_ligne.contact, identifiant)
        )
      ).limit(1);

    if (user.length === 0) {
      throw new Error("Aucun compte trouvÃ© avec cet identifiant");
    }

    const passwordOk = await bcrypt.compare(password, user[0].password);
    if (!passwordOk) {
      throw new Error("Mot de passe incorrect");
    }

    return { client: user[0], passwordOk };
  },
  
  // Inscription d'un client
  register: async ({ nom, email, contact, password }) => {
    const exist = await db.select().from(clients_en_ligne).where(eq(clients_en_ligne.email, email)).limit(1);
    
    if (exist.length > 0) throw new Error("Email dÃ©jÃ  utilisÃ©");

    const hashedPassword = await bcrypt.hash(password, 10);

    await db.insert(clients_en_ligne).values({
      nom: nom,
      email: email,
      contact: contact,
      password: hashedPassword,
      role: "client",
    });

    return { message: "Inscription rÃ©ussie" };
  },

  // RÃ©cupÃ©rer tous les clients (pour admin)
  getAllClients: async () => {
    try {
      const allClients = await db.select({
        id_client: clients_en_ligne.id_client,
        nom: clients_en_ligne.nom,
        email: clients_en_ligne.email,
        contact: clients_en_ligne.contact,
        role: clients_en_ligne.role,
        created_at: clients_en_ligne.created_at,
      })
      .from(clients_en_ligne)
      .orderBy(clients_en_ligne.created_at);
      
      return allClients;
    } catch (error) {
      throw new Error("Erreur lors de la rÃ©cupÃ©ration des clients: " + error.message);
    }
  }
};

module.exports = clientsService;


================================================
File: modules/marketing_commercial/services/commandes.service.js
================================================
const { db } = require('../../../core/database/config');
const { commandes, commande_produits, clients_en_ligne, produits, familles, marques, modeles, type_produits } = require("../../../core/database/models");
const { eq, desc, and, sql } = require("drizzle-orm");
const nodemailer = require('nodemailer');


// Configuration de Nodemailer avec les variables d'environnement
const transporter = nodemailer.createTransport({
  host: process.env.EMAIL_HOST || 'node180-eu.n0c.com',
  port: process.env.EMAIL_PORT || 465,
  secure: true, // true pour le port 465, false pour les autres ports comme 587
  auth: {
    user: process.env.EMAIL_USER || 'sales@dcat.ci',
    pass: process.env.EMAIL_PASSWORD || 'Dcat@2018!'
  }
});

// Adresse email d'expÃ©dition
const emailFrom = '"DCAT" <sales@dcat.ci>';

// Chemin vers le logo de l'entreprise - utiliser un chemin d'URL absolue
const baseUrl = 'erpback.dcat.ci';
// Utiliser le chemin avec des slashes pour les URLs (compatible avec tous les OS)
const logoPath = 'media/images/services_dcat/entreprise_logo.png';
const logoUrl = `${baseUrl}/${logoPath}`;

// Style commun pour les emails
const emailStyles = `
  body { font-family: 'Arial', sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; }
  .container { max-width: 600px; margin: 0 auto; padding: 20px; }
  .header { text-align: center; padding: 20px 0; }
  .logo { max-width: 150px; height: auto; }
  h1 { color: #0056b3; margin-top: 20px; }
  .content { padding: 20px; background-color: #f9f9f9; border-radius: 5px; }
  .footer { padding: 20px; text-align: center; font-size: 12px; color: #777; margin-top: 20px; }
  ul { padding-left: 20px; }
  li { margin-bottom: 8px; }
  .highlight { background-color: #f5f5f5; padding: 10px; border-left: 4px solid #0056b3; margin: 10px 0; }
  .button { display: inline-block; background-color: #0056b3; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; margin-top: 15px; }
`;

// Fonction utilitaire pour valider les dates
function isValidDate(dateString) {
  if (!dateString) return false;
  if (dateString instanceof Date) {
    return !isNaN(dateString.getTime());
  }
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(dateString)) return false;
  const date = new Date(dateString);
  return !isNaN(date.getTime());
}

// Fonction utilitaire pour formater les dates en JJ/MM/AAAA tel qu'on a 
function formatDate(date) {
  if (!date) return 'Non dÃ©finie';
  try {
    const d = new Date(date);
    if (isNaN(d.getTime())) return 'Date invalide';
    return d.toLocaleDateString('fr-FR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  } catch (e) {
    return 'Date invalide';
  }
}

// Fonction pour envoyer une notification email structurÃ©e au client
async function notifyClient(clientId, notification) {
  try {
    // RÃ©cupÃ©rer les informations du client
    const client = await db
      .select({
        email: clients_en_ligne.email,
        nom: clients_en_ligne.nom,
      })
      .from(clients_en_ligne)
      .where(eq(clients_en_ligne.id_client, clientId))
      .limit(1);
    
    if (client.length === 0 || !client[0].email) {
      console.log(`Client ID ${clientId} non trouvÃ© ou email manquant pour la notification.`);
      return;
    }
    
    const clientEmail = client[0].email;
    const clientName = client[0].nom || 'Client';
    
    // Variables pour le contenu de l'email
    let subject = '';
    let htmlContent = '';
    
    // Construire le sujet et le contenu en fonction du type de notification
    switch (notification.type) {
      case 'status_update':
      case 'commande_update':
        if (notification.newStatus === 'LivrÃ©') {
          subject = `Votre commande a Ã©tÃ© livrÃ©e`;
          htmlContent = `
            <h1>Commande livrÃ©e !</h1>
            <p>Cher(e) <strong>${clientName}</strong>,</p>
            <p>Bonne nouvelle ! Votre commande a Ã©tÃ© marquÃ©e comme <strong>livrÃ©e</strong>.</p>
            ${notification.newDate ? `<p class="highlight">Date de livraison effective : ${notification.newDate}</p>` : ''}
            <p>Nous espÃ©rons que vous Ãªtes satisfait(e) de vos produits. N'hÃ©sitez pas Ã  nous contacter pour toute question ou assistance.</p>
            <p>Merci d'avoir choisi DCAT !</p>
          `;
        } else if (notification.newStatus === 'AnnulÃ©') {
          subject = `Annulation de votre commande`;
          htmlContent = `
            <h1>Commande annulÃ©e</h1>
            <p>Cher(e) <strong>${clientName}</strong>,</p>
            <p>Nous vous informons que votre commande a Ã©tÃ© <strong>annulÃ©e</strong>.</p>
            <p>Si vous n'Ãªtes pas Ã  l'origine de cette annulation ou si vous avez des questions, veuillez contacter notre service client.</p>
          `;
        } else if (notification.newDate) { // Commande validÃ©e (implicitement car newDate est dÃ©fini)
          subject = `Votre commande est validÃ©e`;
          htmlContent = `
            <h1>Commande validÃ©e !</h1>
            <p>Cher(e) <strong>${clientName}</strong>,</p>
            <p>Excellente nouvelle ! Votre commande a Ã©tÃ© <strong>validÃ©e</strong>.</p>
            <div class="highlight">
              <p><strong>Date de livraison prÃ©vue : ${notification.newDate}</strong></p>
            </div>
            <p>Nous prÃ©parons votre commande pour expÃ©dition. Vous serez informÃ©(e) dÃ¨s qu'elle sera en route.</p>
          `;
        } else { // Mise Ã  jour de statut gÃ©nÃ©rique (sans date)
           subject = `Mise Ã  jour de votre commande`;
           htmlContent = `
            <h1>Mise Ã  jour de commande</h1>
            <p>Cher(e) <strong>${clientName}</strong>,</p>
            <p>Le statut de votre commande a Ã©tÃ© mis Ã  jour.</p>
            <p class="highlight">Nouveau statut : <strong>${notification.newStatus || 'Inconnu'}</strong></p>
            <p>Vous pouvez suivre l'Ã©volution de votre commande depuis votre espace client.</p>
          `;
        }
        break;
        
      case 'date_update': // UtilisÃ© spÃ©cifiquement si seule la date est mise Ã  jour
         subject = `Votre commande est validÃ©e`;
         htmlContent = `
            <h1>Commande validÃ©e !</h1>
            <p>Cher(e) <strong>${clientName}</strong>,</p>
            <p>Excellente nouvelle ! Votre commande a Ã©tÃ© <strong>validÃ©e</strong>.</p>
            <div class="highlight">
              <p><strong>Date de livraison prÃ©vue : ${notification.newDate}</strong></p>
            </div>
            <p>Nous prÃ©parons votre commande pour expÃ©dition. Vous serez informÃ©(e) dÃ¨s qu'elle sera en route.</p>
          `;
        break;
        
      default:
        console.log(`Type de notification inconnu: ${notification.type}`);
        return; // Ne pas envoyer d'email si le type est inconnu
    }
    
    // Envoyer l'email HTML
    await transporter.sendMail({
      from: emailFrom,
      to: clientEmail,
      subject: `${subject} - DCAT`,
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${subject}</title>
          <style>${emailStyles}</style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <img src="${logoUrl}" alt="DCAT Logo" class="logo">
            </div>
            <div class="footer">
              <p>Merci de votre confiance,<br><strong>L'Ã©quipe DCAT</strong></p>
              <p>Â© ${new Date().getFullYear()} DCAT - Tous droits rÃ©servÃ©s</p>
              <p>Cocody AngrÃ© 7Ã¨me Tranche, Abidjan, CÃ´te d'Ivoire | +225 27 21 24 16 84</p>
            </div>
          </div>
        </body>
        </html>
      `
    });
    
    console.log(`Email de notification envoyÃ© avec succÃ¨s Ã  ${clientEmail} pour la commande ${notification.commandeId}`);
    
  } catch (error) {
    console.error(`Erreur lors de l'envoi de l'email de notification pour la commande ${notification.commandeId}:`, error);
  }
}

const commandesService = {
  // CrÃ©er une nouvelle commande
  createCommande: async (commandeData) => {
    // Commencer une transaction pour assurer l'intÃ©gritÃ© des donnÃ©es
    return await db.transaction(async (tx) => {
      try {
        // 1. InsÃ©rer la commande
        const commandeInserted = await tx.insert(commandes).values({
      date_de_commande: new Date(),
          etat_commande: 'En attente', // Etat initial corrigÃ©
      lieu_de_livraison: commandeData.lieu_de_livraison,
      mode_de_paiement: commandeData.mode_de_paiement,
      id_client: commandeData.id_client,
    }).returning();
        
        if (!commandeInserted || commandeInserted.length === 0) {
          throw new Error("Ã‰chec de l'insertion de la commande");
        }
        
        const commande = commandeInserted[0];
        
        // 2. InsÃ©rer les produits de la commande
        if (commandeData.produits && commandeData.produits.length > 0) {
          for (const produitItem of commandeData.produits) {
            // RÃ©cupÃ©rer le prix actuel du produit
            const productDetails = await tx.select({ prix_produit: produits.prix_produit })
              .from(produits)
              .where(eq(produits.id_produit, produitItem.id_produit))
              .limit(1);

            if (productDetails.length === 0) {
              throw new Error(`Produit avec ID ${produitItem.id_produit} non trouvÃ©.`);
            }
            
            const prixUnitaire = productDetails[0].prix_produit;

            await tx.insert(commande_produits).values({
              id_commande: commande.id_commande,
              id_produit: produitItem.id_produit,
              quantite: produitItem.quantite,
              prix_unitaire: prixUnitaire // Utiliser le prix rÃ©cupÃ©rÃ©
            });
          }
        }
        
        // 3. RÃ©cupÃ©rer les informations pour les notifications
        const client = await tx.select().from(clients_en_ligne)
          .where(eq(clients_en_ligne.id_client, commandeData.id_client))
          .limit(1);
        
        const admins = await tx.select().from(clients_en_ligne)
          .where(eq(clients_en_ligne.role, 'admin'));
        
        // 4. Retourner toutes les donnÃ©es nÃ©cessaires
        return {
          commande: commande,
          client: client.length > 0 ? client[0] : null,
          admins: admins
        };
      } catch (error) {
        throw error;
      }
    }).then(async (result) => {
      try {
        // Envoi des notifications aprÃ¨s la transaction rÃ©ussie, mais ne pas bloquer le retour
        
        // Envoi des notifications de maniÃ¨re asynchrone
        if (result.client) {
          commandesService.sendCommandeNotificationToClient(result.commande, result.client)
            .catch(err => {});
        }
        
        if (result.admins && result.admins.length > 0) {
          commandesService.sendCommandeNotificationToAdmin(result.commande, result.client, result.admins)
            .catch(err => {});
        }
        
        return result.commande;
      } catch (error) {
        // On renvoie quand mÃªme la commande car elle a Ã©tÃ© crÃ©Ã©e avec succÃ¨s
        return result.commande;
      }
    });
  },

  // Envoyer une notification par email au client
  sendCommandeNotificationToClient: async (commande, client) => {
    if (!client || !client.email) {
      return;
    }
    
    try {
      const formattedDate = new Date(commande.date_de_commande).toLocaleDateString('fr-FR', {
        day: 'numeric', 
        month: 'long', 
        year: 'numeric'
      });
      
      await transporter.sendMail({
        from: emailFrom,
        to: client.email,
        subject: `Confirmation de votre commande - DCAT`,
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Confirmation de commande</title>
            <style>${emailStyles}</style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <img src="${logoUrl}" alt="DCAT Logo" class="logo">
              </div>
              <div class="content">
                <h1>Confirmation de commande</h1>
                <p>Cher(e) <strong>${client.nom}</strong>,</p>
                <p>Nous vous remercions pour votre commande sur notre plateforme. Nous avons bien reÃ§u votre commande et nous nous engageons Ã  la traiter dans les plus brefs dÃ©lais.</p>
                
                <div class="highlight">
                  <p><strong>Date:</strong> ${formattedDate}</p>
                  <p><strong>Lieu de livraison:</strong> ${commande.lieu_de_livraison}</p>
                  <p><strong>Mode de paiement:</strong> ${commande.mode_de_paiement}</p>
                </div>
                
                <p>Un de nos agents vous contactera prochainement pour confirmer les dÃ©tails de la livraison et rÃ©pondre Ã  toutes vos questions.</p>
                
                <p>Pour toute question concernant votre commande, n'hÃ©sitez pas Ã  nous contacter par email Ã  <a href="mailto:sales@dcat.ci">sales@dcat.ci</a> ou par tÃ©lÃ©phone au +225 27 21 24 16 84.</p>
              </div>
              <div class="footer">
                <p>Merci de votre confiance,<br><strong>L'Ã©quipe DCAT</strong></p>
                <p>Â© ${new Date().getFullYear()} DCAT - Tous droits rÃ©servÃ©s</p>
                <p>Cocody AngrÃ© 7Ã¨me Tranche, Abidjan, CÃ´te d'Ivoire</p>
              </div>
            </div>
          </body>
          </html>
        `
      });
    } catch (error) {
      // Ne pas bloquer le processus si l'envoi d'email Ã©choue
      console.error('Erreur d\'envoi d\'email au client:', error);
    }
  },

  // Envoyer une notification par email aux administrateurs
  sendCommandeNotificationToAdmin: async (commande, client, admins) => {
    if (!admins || admins.length === 0) {
      return;
    }
    
    try {
      const adminEmails = admins.map(admin => admin.email).filter(email => email);
      
      if (adminEmails.length === 0) {
        return;
      }
      
      const formattedDate = new Date(commande.date_de_commande).toLocaleDateString('fr-FR', {
        day: 'numeric', 
        month: 'long', 
        year: 'numeric'
      });
      
      await transporter.sendMail({
        from: emailFrom,
        to: adminEmails.join(','),
        subject: `Nouvelle commande - Action requise`,
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Nouvelle commande</title>
            <style>${emailStyles}</style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <img src="${logoUrl}" alt="DCAT Logo" class="logo">
              </div>
              <div class="content">
                <h1>Nouvelle commande Ã  traiter</h1>
                <p>Une nouvelle commande a Ã©tÃ© passÃ©e et nÃ©cessite votre attention.</p>
                
                <div class="highlight">
                  <p><strong>Client:</strong> ${client ? client.nom : 'N/A'}</p>
                  <p><strong>Email client:</strong> ${client ? client.email : 'N/A'}</p>
                  <p><strong>TÃ©lÃ©phone client:</strong> ${client ? client.contact || 'N/A' : 'N/A'}</p>
                  <p><strong>Date:</strong> ${formattedDate}</p>
                  <p><strong>Lieu de livraison:</strong> ${commande.lieu_de_livraison}</p>
                  <p><strong>Mode de paiement:</strong> ${commande.mode_de_paiement}</p>
                </div>
                
                <p>Veuillez contacter le client dans les plus brefs dÃ©lais pour confirmer les dÃ©tails de livraison et traiter cette commande.</p>
                
              </div>
              <div class="footer">
                <p>Â© ${new Date().getFullYear()} DCAT - Tous droits rÃ©servÃ©s</p>
                <p>SystÃ¨me automatique de notification - Ne pas rÃ©pondre Ã  cet email</p>
              </div>
            </div>
          </body>
          </html>
        `
      });
    } catch (error) {
      // Ne pas bloquer le processus si l'envoi d'email Ã©choue
      console.error('Erreur d\'envoi d\'email aux administrateurs:', error);
    }
  },

  // Fonction combinÃ©e pour la rÃ©trocompatibilitÃ©
  sendNotifications: async (commande, client, admins) => {
    try {
      // Appeler les deux nouvelles fonctions
      await commandesService.sendCommandeNotificationToClient(commande, client);
      await commandesService.sendCommandeNotificationToAdmin(commande, client, admins);
    } catch (error) {
      // Ne pas bloquer le processus si l'envoi d'email Ã©choue
    }
  },

  // RÃ©cupÃ©rer une commande par son ID
  getCommandeById: async (id) => {
    const commandeResult = await db
      .select({
        id_commande: commandes.id_commande,
        date_de_commande: commandes.date_de_commande,
        etat_commande: commandes.etat_commande,
        date_livraison: commandes.date_livraison,
        lieu_de_livraison: commandes.lieu_de_livraison,
        mode_de_paiement: commandes.mode_de_paiement,
        id_client: commandes.id_client,
        created_at: commandes.created_at,
        updated_at: commandes.updated_at,
        client_nom: clients_en_ligne.nom, // Joindre le nom du client
        client_contact: clients_en_ligne.contact, // Joindre le contact du client
        client_email: clients_en_ligne.email, // Joindre l'email du client
      })
      .from(commandes)
      .leftJoin(clients_en_ligne, eq(commandes.id_client, clients_en_ligne.id_client))
      .where(eq(commandes.id_commande, id))
      .limit(1);
    
    if (commandeResult.length === 0) {
      throw new Error("Commande non trouvÃ©e");
    }
    
    const commande = commandeResult[0];
    
    // RÃ©cupÃ©rer les produits associÃ©s Ã  la commande
    const produitsResult = await commandesService.getCommandeProducts(id);
    
    // Calculer le montant total en utilisant le prix_unitaire
    let montantTotal = 0;
    if (produitsResult.length > 0) {
      montantTotal = produitsResult.reduce((total, item) => {
        // item.prix contient maintenant le prix_unitaire de commande_produits
        return total + (parseFloat(item.prix) * item.quantite);
      }, 0);
    }
    
    // S'assurer de retourner un objet unique et non un tableau
    return {
      ...commande,
      produits: produitsResult,
      montant_total: montantTotal
    };
  },

  // RÃ©cupÃ©rer les produits d'une commande
  getCommandeProducts: async (commandeId) => {
    const result = await db
      .select({
        id_produit: produits.id_produit,
        designation: produits.desi_produit,
        description: produits.desc_produit,
        prix: commande_produits.prix_unitaire, // Utiliser le prix_unitaire de la table commande_produits
        quantite: commande_produits.quantite,
        image: produits.image_produit,
        caracteristiques: produits.caracteristiques_produit,
        famille_libelle: familles.libelle_famille,
        marque_libelle: marques.libelle_marque,
        modele_libelle: modeles.libelle_modele
      })
      .from(commande_produits)
      .innerJoin(produits, eq(commande_produits.id_produit, produits.id_produit))
      .leftJoin(familles, eq(produits.id_famille, familles.id_famille))
      .leftJoin(marques, eq(produits.id_marque, marques.id_marque))
      .leftJoin(modeles, eq(produits.id_modele, modeles.id_modele))
      .where(eq(commande_produits.id_commande, commandeId));
    
    return result;
  },

  // RÃ©cupÃ©rer l'historique des commandes d'un client
  getClientCommandes: async (clientId) => {
    try {
    // Obtenir les commandes avec information du client
    const commandesList = await db
      .select({
        id_commande: commandes.id_commande,
        date_de_commande: commandes.date_de_commande,
        etat_commande: commandes.etat_commande,
        date_livraison: commandes.date_livraison,
        lieu_de_livraison: commandes.lieu_de_livraison,
        mode_de_paiement: commandes.mode_de_paiement,
        id_client: commandes.id_client,
        created_at: commandes.created_at,
        updated_at: commandes.updated_at,
        client_nom: clients_en_ligne.nom, // Joindre le nom du client
        client_contact: clients_en_ligne.contact, // Joindre le contact du client
        client_email: clients_en_ligne.email, // Joindre l'email du client
      })
      .from(commandes)
      .leftJoin(clients_en_ligne, eq(commandes.id_client, clients_en_ligne.id_client))
      .where(eq(commandes.id_client, clientId))
      .orderBy(desc(commandes.created_at));
        
      if (commandesList.length === 0) {
        return [];
      }
    
    // Pour chaque commande, calculer le montant total
    const commandesWithTotal = await Promise.all(commandesList.map(async (commande) => {
      // RÃ©cupÃ©rer les produits pour cette commande avec leur prix unitaire et quantitÃ©
      const commandeProduits = await db
        .select({
          prix_unitaire: commande_produits.prix_unitaire,
          quantite: commande_produits.quantite,
        })
        .from(commande_produits)
        .where(eq(commande_produits.id_commande, commande.id_commande));
      
      // Calculer le montant total
      let montantTotal = 0;
      if (commandeProduits.length > 0) {
        montantTotal = commandeProduits.reduce((total, item) => {
          return total + (parseFloat(item.prix_unitaire) * item.quantite);
        }, 0);
      }
      
      // Ajouter le montant total Ã  l'objet commande
      return {
        ...commande,
        montant_total: montantTotal
      };
    }));
    
    return commandesWithTotal;
    } catch (error) {
      throw error;
    }
  },

  // RÃ©cupÃ©rer les commandes par Ã©tat
  getCommandesByStatus: async (status) => {
    // Obtenir les commandes avec information du client
    const commandesList = await db
      .select({
        id_commande: commandes.id_commande,
        date_de_commande: commandes.date_de_commande,
        etat_commande: commandes.etat_commande,
        date_livraison: commandes.date_livraison,
        lieu_de_livraison: commandes.lieu_de_livraison,
        mode_de_paiement: commandes.mode_de_paiement,
        id_client: commandes.id_client,
        created_at: commandes.created_at,
        updated_at: commandes.updated_at,
        client_nom: clients_en_ligne.nom, // Joindre le nom du client
        client_contact: clients_en_ligne.contact, // Joindre le contact du client
        client_email: clients_en_ligne.email, // Joindre l'email du client
      })
      .from(commandes)
      .leftJoin(clients_en_ligne, eq(commandes.id_client, clients_en_ligne.id_client))
      .where(eq(commandes.etat_commande, status))
      .orderBy(desc(commandes.created_at));
    
    // Pour chaque commande, calculer le montant total
    const commandesWithTotal = await Promise.all(commandesList.map(async (commande) => {
      // RÃ©cupÃ©rer les produits pour cette commande avec leur prix unitaire et quantitÃ©
      const commandeProduits = await db
        .select({
          prix_unitaire: commande_produits.prix_unitaire,
          quantite: commande_produits.quantite,
        })
        .from(commande_produits)
        .where(eq(commande_produits.id_commande, commande.id_commande));
      
      // Calculer le montant total
      let montantTotal = 0;
      if (commandeProduits.length > 0) {
        montantTotal = commandeProduits.reduce((total, item) => {
          return total + (parseFloat(item.prix_unitaire) * item.quantite);
        }, 0);
      }
      
      // Ajouter le montant total Ã  l'objet commande
      return {
        ...commande,
        montant_total: montantTotal
      };
    }));
    
    return commandesWithTotal;
  },

  // Mettre Ã  jour le statut d'une commande
  updateCommandeStatus: async (id, newStatus) => {
    // Validation du statut
    const validStatuses = ['En attente', 'LivrÃ©', 'AnnulÃ©', 'RetournÃ©'];
    if (!validStatuses.includes(newStatus)) {
      throw new Error(`Ã‰tat de commande invalide. Les valeurs autorisÃ©es sont: ${validStatuses.join(', ')}`);
    }
    
    // VÃ©rifier si la commande existe
    const existingCommande = await db
      .select({
        id_commande: commandes.id_commande,
        etat_commande: commandes.etat_commande,
        id_client: commandes.id_client
      })
      .from(commandes)
      .where(eq(commandes.id_commande, id))
      .limit(1);
      
    if (existingCommande.length === 0) {
      throw new Error("Commande non trouvÃ©e");
    }
    
    const oldStatus = existingCommande[0].etat_commande;
    
    if (oldStatus === newStatus) {
       return await commandesService.getCommandeById(id); // Pas de changement, pas de notif
    }

    // Mettre Ã  jour le statut
    await db.update(commandes)
      .set({ etat_commande: newStatus, updated_at: new Date() }) // Ajouter updated_at
      .where(eq(commandes.id_commande, id));
    
    // Envoyer une notification au client
    let notificationMessage = "";
    
    if (newStatus === 'LivrÃ©') {
      notificationMessage = "Votre commande a Ã©tÃ© marquÃ©e comme livrÃ©e.";
    } else if (newStatus === 'AnnulÃ©') {
      notificationMessage = "Votre commande a Ã©tÃ© annulÃ©e.";
    } // Pas de notif pour 'En attente' sans date
    
    if (notificationMessage) {
      await notifyClient(existingCommande[0].id_client, {
        type: 'status_update', // Conserver type pour la fonction notifyClient
        message: notificationMessage, // Message brut (utilisÃ© si l'email Ã©choue)
        commandeId: id,
        newStatus: newStatus
      }).catch(err => console.error("Erreur d'envoi notification (status):", err));
    }
      
    return await commandesService.getCommandeById(id);
  },

  // Mettre Ã  jour la date de livraison
  updateLivraisonDate: async (id, dateLivraison) => {
    // VÃ©rifier si la commande existe
    const commandeExistante = await db
      .select({
        id_commande: commandes.id_commande,
        date_livraison: commandes.date_livraison,
        id_client: commandes.id_client
      })
      .from(commandes)
      .where(eq(commandes.id_commande, id))
      .limit(1);
    
    if (commandeExistante.length === 0) {
      throw new Error("Commande non trouvÃ©e");
    }
    
    // Valider la date de livraison
    const dateObj = new Date(dateLivraison);
    if (isNaN(dateObj.getTime())) {
      throw new Error("Date de livraison invalide");
    }
    
    const oldDate = commandeExistante[0].date_livraison;
    const newDateFormatted = formatDate(dateObj);
    const oldDateFormatted = formatDate(oldDate);

    // Ne pas mettre Ã  jour si la date est identique
    if (oldDate && oldDateFormatted === newDateFormatted) {
        return commandeExistante[0]; // Retourner la commande existante sans notif
    }

    // Mettre Ã  jour la date de livraison
    const result = await db
      .update(commandes)
      .set({
        date_livraison: dateObj,
        updated_at: new Date()
      })
      .where(eq(commandes.id_commande, id))
      .returning();
    
    // Envoyer une notification de validation au client
    await notifyClient(commandeExistante[0].id_client, {
      type: 'date_update', // Conserver type pour la fonction notifyClient
      message: `Votre commande a Ã©tÃ© validÃ©e. Date de livraison prÃ©vue: ${newDateFormatted}.`, // Message brut
      commandeId: id,
      newDate: newDateFormatted
    }).catch(err => console.error("Erreur d'envoi notification (date):", err));
    
    return result[0];
  },

  // Mettre Ã  jour le statut et la date de livraison d'une commande
  updateCommandeStatusAndDate: async (id, newStatus, dateLivraison = null) => {
    // Validation du statut
    const validStatuses = ['En attente', 'LivrÃ©', 'AnnulÃ©', 'RetournÃ©'];
    if (!validStatuses.includes(newStatus)) {
      throw new Error(`Ã‰tat de commande invalide. Les valeurs autorisÃ©es sont: ${validStatuses.join(', ')}`);
    }
    
    // Valider la date si elle est fournie
    if (dateLivraison && !isValidDate(dateLivraison)) {
      throw new Error("Date de livraison invalide");
    }
    
    // VÃ©rifier si la commande existe
    const existingCommande = await db
      .select({
        id_commande: commandes.id_commande,
        etat_commande: commandes.etat_commande,
        date_livraison: commandes.date_livraison,
        id_client: commandes.id_client
      })
      .from(commandes)
      .where(eq(commandes.id_commande, id))
      .limit(1);
      
    if (existingCommande.length === 0) {
      throw new Error("Commande non trouvÃ©e");
    }
    
    const oldStatus = existingCommande[0].etat_commande;
    const oldDate = existingCommande[0].date_livraison;
    let newDateFormatted = null;
    let dateObj = null;

    // Valider la date si elle est fournie
    if (dateLivraison) {
      dateObj = new Date(dateLivraison);
       if (isNaN(dateObj.getTime())) {
         throw new Error("Date de livraison invalide");
       }
       newDateFormatted = formatDate(dateObj);
    }
    const oldDateFormatted = formatDate(oldDate);

    const statusChanged = newStatus !== oldStatus;
    const dateChanged = dateLivraison && (!oldDate || oldDateFormatted !== newDateFormatted);

    // Si rien n'a changÃ©, retourner la commande existante
    if (!statusChanged && !dateChanged) {
       return await commandesService.getCommandeById(id);
    }

    // PrÃ©parer les donnÃ©es Ã  mettre Ã  jour
    const updateData = { updated_at: new Date() };
    if (statusChanged) {
      updateData.etat_commande = newStatus;
    }
    if (dateLivraison) { // Mettre Ã  jour la date seulement si fournie
      updateData.date_livraison = dateObj;
    }
    
    // Mettre Ã  jour la commande
    await db.update(commandes)
      .set(updateData)
      .where(eq(commandes.id_commande, id));
    
    // Envoyer une notification au client si nÃ©cessaire
    let notificationMessage = "";
    let notificationType = 'commande_update';

    if (newStatus === 'LivrÃ©' && statusChanged) {
      notificationMessage = "Votre commande a Ã©tÃ© marquÃ©e comme livrÃ©e.";
      notificationType = 'status_update';
    } else if (newStatus === 'AnnulÃ©' && statusChanged) {
      notificationMessage = "Votre commande a Ã©tÃ© annulÃ©e.";
      notificationType = 'status_update';
    } else if (newStatus === 'En attente' && dateChanged) { // Cas de validation
      notificationMessage = `Votre commande a Ã©tÃ© validÃ©e. Date de livraison prÃ©vue: ${newDateFormatted}.`;
      notificationType = 'date_update';
    } else if (statusChanged || dateChanged) { // Autres mises Ã  jour combinÃ©es
      notificationMessage = `Votre commande a Ã©tÃ© mise Ã  jour. ${statusChanged ? `Nouveau statut: ${newStatus}.` : ''} ${dateChanged ? `Nouvelle date de livraison prÃ©vue: ${newDateFormatted}.` : ''}`;
    }
    
    if (notificationMessage) {
      await notifyClient(existingCommande[0].id_client, {
        type: notificationType,
        message: notificationMessage, // Message brut
        commandeId: id,
        newStatus: statusChanged ? newStatus : undefined,
        newDate: newDateFormatted // Toujours envoyer la date formatÃ©e si disponible
      }).catch(err => console.error("Erreur d'envoi notification (combined):", err));
    }
      
    return await commandesService.getCommandeById(id);
  }
};

module.exports = commandesService;


================================================
File: modules/marketing_commercial/services/produits.service.js
================================================
const { db } = require('../../../core/database/config');
const { produits, type_produits, familles, marques, modeles } = require("../../../core/database/models");
const { eq, and, isNotNull, desc } = require("drizzle-orm");

const produitsService = {
  // RÃ©cupÃ©rer tous les produits de type Ã©quipement par famille
  getEquipementsByFamille: async (familleId) => {
    return await db
      .select({
        id: produits.id_produit,
        designation: produits.desi_produit,
        description: produits.desc_produit,
        image: produits.image_produit,
        prix: produits.prix_produit,
        caracteristiques: produits.caracteristiques_produit,
      })
      .from(produits)
      .where(
          and(
          eq(produits.id_famille, familleId),
          eq(type_produits.libelle, 'equipement'),
          isNotNull(produits.prix_produit)
        )
      )
      .leftJoin(type_produits, eq(produits.id_type_produit, type_produits.id_type_produit));
  },

  // RÃ©cupÃ©rer tous les produits de type Ã©quipement
  getAllEquipements: async () => {
    return await db
      .select({
        id: produits.id_produit,
        designation: produits.desi_produit,
        description: produits.desc_produit,
        image: produits.image_produit,
        prix: produits.prix_produit,
        caracteristiques: produits.caracteristiques_produit,
        famille_id: familles.id_famille,
        famille_libelle: familles.libelle_famille,
      })
      .from(produits)
      .where(
        and(
          eq(type_produits.libelle, 'equipement'),
          isNotNull(produits.prix_produit)
        )
      )
      .leftJoin(type_produits, eq(produits.id_type_produit, type_produits.id_type_produit))
      .leftJoin(familles, eq(produits.id_famille, familles.id_famille));
  },

  // RÃ©cupÃ©rer les 5 derniers produits ajoutÃ©s (nouveautÃ©s)
  getLatestProducts: async (limit = 5) => {
    return await db
      .select({
        id: produits.id_produit,
        designation: produits.desi_produit,
        description: produits.desc_produit,
        image: produits.image_produit,
        prix: produits.prix_produit,
        caracteristiques: produits.caracteristiques_produit,
        famille_id: familles.id_famille,
        famille_libelle: familles.libelle_famille,
      })
      .from(produits)
      .where(
        and(
          eq(type_produits.libelle, 'equipement'),
          isNotNull(produits.prix_produit)
        )
      )
      .leftJoin(type_produits, eq(produits.id_type_produit, type_produits.id_type_produit))
      .leftJoin(familles, eq(produits.id_famille, familles.id_famille))
      .orderBy(desc(produits.id_produit)) // Supposons que les IDs plus Ã©levÃ©s sont les plus rÃ©cents
      .limit(limit);
  },

  // RÃ©cupÃ©rer les dÃ©tails d'un produit
  getProductDetails: async (productId) => {
    const details = await db
      .select({
        id: produits.id_produit,
        designation: produits.desi_produit,
        description: produits.desc_produit,
        image: produits.image_produit,
        prix: produits.prix_produit,
        caracteristiques: produits.caracteristiques_produit,
        famille_id: familles.id_famille,
        famille_libelle: familles.libelle_famille,
        marque_id: marques.id_marque,
        marque_libelle: marques.libelle_marque,
        modele_id: modeles.id_modele,
        modele_libelle: modeles.libelle_modele,
        type_id: type_produits.id_type_produit,
        type_libelle: type_produits.libelle
      })
      .from(produits)
      .leftJoin(familles, eq(produits.id_famille, familles.id_famille))
      .leftJoin(marques, eq(produits.id_marque, marques.id_marque))
      .leftJoin(modeles, eq(produits.id_modele, modeles.id_modele))
      .leftJoin(type_produits, eq(produits.id_type_produit, type_produits.id_type_produit))
      .where(eq(produits.id_produit, productId))
      .limit(1);
    
    if (details.length === 0) throw new Error("Produit non trouvÃ©");
    return details[0];
  },

  // RÃ©cupÃ©rer toutes les familles
  getAllFamilles: async () => {
    return await db
      .select({
        id: familles.id_famille,
        libelle: familles.libelle_famille,
      })
      .from(familles);
  },

  // RÃ©cupÃ©rer des produits similaires en fonction du libellÃ©
  getSimilarProductsByLibelle: async (productId, limit = 4) => {
    // D'abord, rÃ©cupÃ©rer les dÃ©tails du produit pour obtenir son libellÃ©
    const productDetails = await produitsService.getProductDetails(productId);
    
    if (!productDetails) {
      throw new Error("Produit non trouvÃ©");
    }
    
    // Extraire les mots-clÃ©s significatifs du libellÃ©
    const designation = productDetails.designation.toLowerCase();
    const descriptionWords = productDetails.description 
      ? productDetails.description.toLowerCase().split(/\s+/) 
      : [];
      
    // Filtrer les mots-clÃ©s pour exclure les mots trÃ¨s courts ou non significatifs
    const keywordsToExclude = ["le", "la", "les", "un", "une", "des", "du", "de", "et", "Ã ", "pour", "avec", "sur", "dans"];
    
    // CrÃ©er une liste de mots-clÃ©s Ã  rechercher
    const keywords = [...designation.split(/\s+/), ...descriptionWords]
      .filter(word => word.length > 2 && !keywordsToExclude.includes(word))
      // Trier par longueur (mots plus longs d'abord) pour privilÃ©gier les termes spÃ©cifiques
      .sort((a, b) => b.length - a.length)
      // Prendre les 5 mots-clÃ©s les plus pertinents
      .slice(0, 5);
      
    // Si nous n'avons pas assez de mots-clÃ©s, utiliser la famille comme fallback
    if (keywords.length < 2 && productDetails.famille_id) {
      const productsInSameFamily = await db
        .select({
          id: produits.id_produit,
          designation: produits.desi_produit,
          description: produits.desc_produit,
          image: produits.image_produit,
          prix: produits.prix_produit,
          caracteristiques: produits.caracteristiques_produit,
          famille_id: familles.id_famille,
          famille_libelle: familles.libelle_famille,
        })
        .from(produits)
        .where(
          and(
            eq(produits.id_famille, productDetails.famille_id),
            eq(type_produits.libelle, 'equipement')
          )
        )
        .leftJoin(type_produits, eq(produits.id_type_produit, type_produits.id_type_produit))
        .leftJoin(familles, eq(produits.id_famille, familles.id_famille))
        .limit(limit + 1); // +1 pour pouvoir exclure le produit lui-mÃªme
      
      // Filtrer pour exclure le produit lui-mÃªme
      return productsInSameFamily
        .filter(product => product.id !== parseInt(productId))
        .slice(0, limit);
    }
    
    // Sinon, rechercher des produits avec des mots-clÃ©s similaires
    let similarProducts = await db
      .select({
        id: produits.id_produit,
        designation: produits.desi_produit,
        description: produits.desc_produit,
        image: produits.image_produit,
        prix: produits.prix_produit,
        caracteristiques: produits.caracteristiques_produit,
        famille_id: familles.id_famille,
        famille_libelle: familles.libelle_famille,
      })
      .from(produits)
      .where(
        and(
          // Ne pas inclure le produit lui-mÃªme
          produits.id_produit.notEquals(productId),
          eq(type_produits.libelle, 'equipement'),
          isNotNull(produits.prix_produit)
        )
      )
      .leftJoin(type_produits, eq(produits.id_type_produit, type_produits.id_type_produit))
      .leftJoin(familles, eq(produits.id_famille, familles.id_famille));
      
    // Calculer un score de similaritÃ© pour chaque produit
    const scoredProducts = similarProducts.map(product => {
      let score = 0;
      const productText = `${product.designation.toLowerCase()} ${product.description ? product.description.toLowerCase() : ''}`;
      
      // Augmenter le score pour chaque mot-clÃ© trouvÃ©
      keywords.forEach(keyword => {
        if (productText.includes(keyword)) {
          // Donner plus de poids aux mots plus longs (plus spÃ©cifiques)
          score += keyword.length * 2;
        }
      });
      
      // Bonus si mÃªme famille
      if (product.famille_id === productDetails.famille_id) {
        score += 10;
      }
      
      return { ...product, score };
    });
    
    // Trier par score et prendre les meilleurs rÃ©sultats
    return scoredProducts
      .sort((a, b) => b.score - a.score)
      .filter(product => product.score > 0) // Ne garder que les produits avec un score positif
      .slice(0, limit)
      // Supprimer le champ score avant de renvoyer les rÃ©sultats
      .map(({ score, ...product }) => product);
  },
};

module.exports = produitsService;


================================================
File: modules/marketing_commercial/services/services_dcat.service.js
================================================
const { db } = require('../../../core/database/config');
const { services } = require("../../../core/database/models");
const { eq, desc } = require("drizzle-orm");
const fs = require('fs').promises;

const servicesDcatService = {
  getAllServices: async () => {
    try {
      return await db
        .select({
          id: services.id_service,
          titre: services.titre_service,
          sous_titre: services.sous_titre_service,
          image: services.image_service,
          detail: services.detail_service
        })
        .from(services)
        .orderBy(desc(services.created_at));
    } catch (error) {
      throw error;
    }
  },

  getServiceById: async (id) => {
    try {
      const result = await db
        .select({
          id: services.id_service,
          titre: services.titre_service,
          sous_titre: services.sous_titre_service,
          image: services.image_service,
          detail: services.detail_service
        })
        .from(services)
        .where(eq(services.id_service, id))
        .limit(1);
      
      return result[0];
    } catch (error) {
      throw error;
    }
  },

  createService: async (serviceData) => {
    try {
      const result = await db
        .insert(services)
        .values({
          titre_service: serviceData.titre,
          sous_titre_service: serviceData.sous_titre,
          detail_service: serviceData.detail,
          image_service: serviceData.image
        })
        .returning();
      return result[0];
    } catch (error) {
      throw error;
    }
  },

  updateService: async (id, serviceData) => {
    try {
      const service = await db
        .select()
        .from(services)
        .where(eq(services.id_service, id))
        .limit(1);

      if (service.length === 0) return null;

      if (serviceData.image && service[0].image_service) {
        try {
          await fs.unlink(service[0].image_service);
        } catch (error) {
          // Ne rien faire en cas d'erreur lors de la suppression de l'image
        }
      }

      const result = await db
        .update(services)
        .set({
          titre_service: serviceData.titre,
          sous_titre_service: serviceData.sous_titre,
          detail_service: serviceData.detail,
          image_service: serviceData.image || service[0].image_service,
          updated_at: new Date()
        })
        .where(eq(services.id_service, id))
        .returning();
      
      return result[0];
    } catch (error) {
      throw error;
    }
  },

  deleteService: async (id) => {
    try {
      const service = await db
        .select()
        .from(services)
        .where(eq(services.id_service, id))
        .limit(1);

      if (service.length === 0) return false;

      if (service[0].image_service) {
        try {
          await fs.unlink(service[0].image_service);
        } catch (error) {
          // Ne rien faire en cas d'erreur lors de la suppression de l'image
        }
      }

      await db.delete(services).where(eq(services.id_service, id));
      return true;
    } catch (error) {
      throw error;
    }
  }
};

module.exports = servicesDcatService;


================================================
File: modules/moyens_generaux/controllers/maintenance.controller.js
================================================
const maintenanceService = require("../services/maintenance.service");

// CREATE
const createMaintenance = async (req, res) => {
  try {
    // if (!req.body.denomination) {
    //   return res.status(400).json({ error: "La denomination est requise" });
    // }
    const result = await maintenanceService.createMaintenance(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getMaintenances = async (req, res) => {
  try {
    const result = await maintenanceService.getMaintenances();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getMaintenanceById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await maintenanceService.getMaintenanceById(id);
    if (!result) {
      return res.status(404).json({ error: "Maintenance non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateMaintenance = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await maintenanceService.updateMaintenance(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteMaintenance = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await maintenanceService.deleteMaintenance(id);
    res.json({ message: "Maintenance supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};


module.exports = {
  createMaintenance,
  getMaintenances,
  getMaintenanceById,
  updateMaintenance,
  deleteMaintenance
};


================================================
File: modules/moyens_generaux/controllers/maintenanceMoyenTravail.controller.js
================================================
// Table de liaison entre maintenant et  moyens de travail
// maintenanceMoyenTravail.controller.js
const maintenanceMoyenTravailService = require("../services/maintenanceMoyenTravail.service");

// CREATE
const createMaintenanceMoyenTravail = async (req, res) => {
  try {
    const result = await maintenanceMoyenTravailService.createMaintenanceMoyenTravail(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la crÃ©ation",
      details: error.message,
    });
  }
};

// READ ALL
const getMaintenanceMoyenTravails = async (req, res) => {
  try {
    const result = await maintenanceMoyenTravailService.getMaintenanceMoyenTravails();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message,
    });
  }
};

// READ ONE
const getMaintenanceMoyenTravailById = async (req, res) => {
  try {
    const id_moyens_de_travail = parseInt(req.params.id_moyens_de_travail);
    const id_maintenance = parseInt(req.params.id_maintenance);
    if (isNaN(id_moyens_de_travail) || isNaN(id_maintenance)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await maintenanceMoyenTravailService.getMaintenanceMoyenTravailById(id_moyens_de_travail, id_maintenance);
    if (!result) {
      return res.status(404).json({ error: "Maintenance Moyen Travail non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message,
    });
  }
};

// UPDATE
const updateMaintenanceMoyenTravail = async (req, res) => {
  try {
    const id_moyens_de_travail = parseInt(req.params.id_moyens_de_travail);
    const id_maintenance = parseInt(req.params.id_maintenance);
    if (isNaN(id_moyens_de_travail) || isNaN(id_maintenance)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await maintenanceMoyenTravailService.updateMaintenanceMoyenTravail(id_moyens_de_travail, id_maintenance, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la mise Ã  jour",
      details: error.message,
    });
  }
};

// DELETE
const deleteMaintenanceMoyenTravail = async (req, res) => {
  try {
    const id_moyens_de_travail = parseInt(req.params.id_moyens_de_travail);
    const id_maintenance = parseInt(req.params.id_maintenance);
    if (isNaN(id_moyens_de_travail) || isNaN(id_maintenance)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await maintenanceMoyenTravailService.deleteMaintenanceMoyenTravail(id_moyens_de_travail, id_maintenance);
    res.json({ message: "Maintenance Moyen Travail supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la suppression",
      details: error.message,
    });
  }
};

module.exports = {
  createMaintenanceMoyenTravail,
  getMaintenanceMoyenTravails,
  getMaintenanceMoyenTravailById,
  updateMaintenanceMoyenTravail,
  deleteMaintenanceMoyenTravail,
};



================================================
File: modules/moyens_generaux/controllers/mouvementOutil.controller.js
================================================
const toolsService = require("../services/mouvementOutil.service");

// RÃ©cupÃ©rer la liste de tous les produits de type "outil".
const getAllOutils = async (req, res) => {
  try {
    const outils = await toolsService.getAllOutils();
    res.status(200).json(outils);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

//RÃ©cupÃ©rer tous les exemplaires des outils.
const getExemplairesOutils = async (req, res) => {
  try {
    const exemplaires = await toolsService.getExemplairesOutils();
    res.status(200).json(exemplaires);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

//Enregistrer la sortie d'un exemplaire d'outil par un employÃ© (prÃªt temporaire).
const enregistrerSortieOutil = async (req, res) => {
  try {
    await toolsService.enregistrerSortieOutil(req.body);
    res.status(201).json({ message: "Sortie enregistrÃ©e avec succÃ¨s." });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

//Enregistrer la retour (entrÃ©e) d'un outil utilisÃ© par un employÃ©.
const enregistrerEntreeOutil = async (req, res) => {
  try {
    await toolsService.enregistrerEntreeOutil(req.body);
    res.status(201).json({ message: "EntrÃ©e enregistrÃ©e avec succÃ¨s." });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

//VÃ©rifier si un produit sorti a Ã©tÃ© dÃ©posÃ© (retournÃ©)
const estOutilRetourne = async (req, res) => {
  try {
    const { id_exemplaire, id_employes } = req.params;

    // VÃ©rification des paramÃ¨tres
    if (
      !id_exemplaire ||
      !id_employes ||
      isNaN(parseInt(id_exemplaire)) ||
      isNaN(parseInt(id_employes))
    ) {
      return res.status(400).json({ error: "ParamÃ¨tres invalides" });
    }

    const retourne = await toolsService.estOutilRetourne(
      parseInt(id_exemplaire),
      parseInt(id_employes)
    );

    res.status(200).json({ retourne });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

//Avoir l'historique des entrÃ©es et sorties d'outils
const getHistoriqueOutils = async (req, res) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ error: "ID requis" });
    }

    const historique = await toolsService.getHistoriqueOutils(parseInt(id));
    res.status(200).json(historique);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};



const getHistoriqueGlobal = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const data = await toolsService.getHistoriqueGlobal(page, limit);
    res.status(200).json(data);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};


module.exports = {
  getAllOutils,
  getExemplairesOutils,
  enregistrerSortieOutil,
  enregistrerEntreeOutil,
  estOutilRetourne,
  getHistoriqueOutils,
  getHistoriqueGlobal
};



================================================
File: modules/moyens_generaux/controllers/moyensdeTravail.controller.js
================================================
const moyenstravailService = require("../services/moyensdeTravail.service");

// CREATE
const createMoyensTravail = async (req, res) => {
  try {
    if (!req.body.denomination) {
      return res.status(400).json({ error: "La denomination est requise" });
    }
    const result = await moyenstravailService.createMoyensTravail(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getMoyensTravails = async (req, res) => {
  try {
    const result = await moyenstravailService.getMoyensTravails();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getMoyensTravailById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await moyenstravailService.getMoyensTravailById(id);
    if (!result) {
      return res.status(404).json({ error: "MoyensTravail non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateMoyensTravail = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await moyenstravailService.updateMoyensTravail(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteMoyensTravail = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await moyenstravailService.deleteMoyensTravail(id);
    res.json({ message: "MoyensTravail supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};


module.exports = {
  createMoyensTravail,
  getMoyensTravails,
  getMoyensTravailById,
  updateMoyensTravail,
  deleteMoyensTravail
};


================================================
File: modules/moyens_generaux/routes/maintenance.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/maintenance.controller");

// CRUD Routes
/**
 * @swagger
 * /moyens-generaux/maintenances:
 *   post:
 *     summary: CrÃ©e une nouvelle maintenance
 *     tags: [Maintenances]
 */
router.post("/", controller.createMaintenance);

/**
 * @swagger
 * /moyens-generaux/maintenances:
 *   get:
 *     summary: RÃ©cupÃ¨re toutes les maintenances
 *     tags: [Maintenances]
 *     responses:
 *       200:
 *         description: Liste des maintenances
 *         content:
 *           application/json:
 *             example:
 *               - id_maintenance: 1
 *                 recurrence: "1 an"
 *                 operations: "test-1"
 *                 recommandations: "test-1"
 *                 type_maintenance: "test-1"
 *                 autre_intervenant: null
 *                 id_partenaire: null
 *                 created_at: "2025-04-30T16:39:23.040Z"
 *                 updated_at: "2025-04-30T16:39:23.040Z"
 *               - id_maintenance: 2
 *                 recurrence: "1 an"
 *                 operations: "test-2"
 *                 recommandations: "test-2"
 *                 type_maintenance: "test-2"
 *                 autre_intervenant: null
 *                 id_partenaire: null
 *                 created_at: "2025-04-30T16:39:41.009Z"
 *                 updated_at: "2025-04-30T16:39:41.009Z"
 */

router.get("/", controller.getMaintenances);

/**
 * @swagger
 * /moyens-generaux/maintenances/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une maintenance par ID
 *     tags: [Maintenances]
 */
router.get("/:id", controller.getMaintenanceById);

/**
 * @swagger
 * /moyens-generaux/maintenances/{id}:
 *   put:
 *     summary: Met Ã  jour une maintenance par ID
 *     tags: [Maintenances]
 */
router.put("/:id", controller.updateMaintenance);

/**
 * @swagger
 * /moyens-generaux/maintenances/{id}:
 *   delete:
 *     summary: Supprime une maintenance par ID
 *     tags: [Maintenances]
 */
router.delete("/:id", controller.deleteMaintenance);

module.exports = router;



================================================
File: modules/moyens_generaux/routes/maintenanceMoyenTravail.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/maintenanceMoyenTravail.controller");

// CRUD Routes  
/**
 * @swagger
 * /moyens-generaux/maintenance-moyen-travails:
 *   post:
 *     summary: CrÃ©e une nouvelle maintenance de moyen de travail
 *     tags: [Maintenances Moyens de Travail]
 */
router.post("/", controller.createMaintenanceMoyenTravail);

/**
 * @swagger
 * /moyens-generaux/maintenance-moyen-travails:
 *   get:
 *     summary: RÃ©cupÃ¨re toutes les maintenances des moyens de travail
 *     tags: [Maintenances Moyens de Travail]
 */
router.get("/", controller.getMaintenanceMoyenTravails);

/**
 * @swagger
 * /moyens-generaux/maintenance-moyen-travails/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une maintenance de moyen de travail par ID
 *     tags: [Maintenances Moyens de Travail]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la maintenance
 *     responses:
 *       200:
 *         description: Maintenance rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id_maintenance:
 *                   type: integer
 *                   example: 1
 *                 recurrence:
 *                   type: string
 *                   example: "1 an"
 *                 operations:
 *                   type: string
 *                   example: "test-1"
 *                 recommandations:
 *                   type: string
 *                   example: "test-1"
 *                 type_maintenance:
 *                   type: string
 *                   example: "test-1"
 *                 autre_intervenant:
 *                   type: string
 *                   nullable: true
 *                   example: null
 *                 id_partenaire:
 *                   type: integer
 *                   nullable: true
 *                   example: null
 *                 created_at:
 *                   type: string
 *                   format: date-time
 *                   example: "2025-04-30T16:39:23.040Z"
 *                 updated_at:
 *                   type: string
 *                   format: date-time
 *                   example: "2025-04-30T16:39:23.040Z"
 *       404:
 *         description: Maintenance non trouvÃ©e
 */

router.get("/:id", controller.getMaintenanceMoyenTravailById);

/**
 * @swagger
 * /moyens-generaux/maintenance-moyen-travails/{id}:
 *   put:
 *     summary: Met Ã  jour une maintenance de moyen de travail par ID
 *     tags: [Maintenances Moyens de Travail]
 */
router.put("/:id", controller.updateMaintenanceMoyenTravail);

/**
 * @swagger
 * /moyens-generaux/maintenance-moyen-travails/{id}:
 *   delete:
 *     summary: Supprime une maintenance de moyen de travail par ID
 *     tags: [Maintenances Moyens de Travail]
 */
router.delete("/:id", controller.deleteMaintenanceMoyenTravail);


module.exports = router;



================================================
File: modules/moyens_generaux/routes/mouvementOutil.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/mouvementOutil.controller");

// router.get("/", controller.getAllOutils);
// router.get("/exemplaires", controller.getExemplairesOutils);
// // router.get("/employe/:id_employe", controller.outilsSortisEmploye);
// router.post("/sortie", controller.enregistrerSortieOutil);
// router.post("/entree", controller.enregistrerEntreeOutil);

// router.get("/etat/:id_exemplaire/:id_employes", controller.estOutilRetourne); //VÃ©rifier si un produit sorti a Ã©tÃ© dÃ©posÃ© (retournÃ©)
// router.get("/historique/:id", controller.getHistoriqueOutils); //[ id : id_produit] Avoir lâ€™historique des entrÃ©es et sorties dâ€™outils

// router.get("/historiques", controller.getHistoriqueGlobal); //Avoir lâ€™historique des entrÃ©es et sorties de tout les outils

/**
 * @swagger
 * /moyens-generaux/outils:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les outils
 *     tags: [Outils]
 *     responses:
 *       200:
 *         description: Liste des outils avec leurs dÃ©tails
 *         content:
 *           application/json:
 *             example:
 *               - produits:
 *                   id_produit: 7
 *                   code_produit: "outils-1"
 *                   desi_produit: "outils-1"
 *                   desc_produit: "test"
 *                   image_produit: "media\\images\\stock_moyensgeneraux\\produits\\tomate_1745872525356.jpeg"
 *                   qte_produit: 1
 *                   emplacement_produit: null
 *                   caracteristiques_produit: null
 *                   prix_produit: null
 *                   id_categorie: null
 *                   id_type_produit: 5
 *                   id_modele: null
 *                   id_famille: null
 *                   id_marque: null
 *                   created_at: "2025-04-28T20:20:28.899Z"
 *                   updated_at: "2025-04-28T20:35:25.365Z"
 *                 type_produits:
 *                   id_type_produit: 5
 *                   libelle: "Outil"
 *                   created_at: "2025-04-28T17:30:41.395Z"
 *                   updated_at: "2025-04-28T17:30:41.395Z"
 */

router.get("/", controller.getAllOutils);

/**
 * @swagger
 * /moyens-generaux/outils/exemplaires:
 *   get:
 *     summary: RÃ©cupÃ¨re les exemplaires d'outils
 *     tags: [Outils]
 *     responses:
 *       200:
 *         description: Liste des exemplaires d'outils avec leurs informations
 *         content:
 *           application/json:
 *             example:
 *               - exemplaires:
 *                   id_exemplaire: 13
 *                   num_serie: "serie-6"
 *                   date_entree: "2025-04-23"
 *                   etat_exemplaire: "Reserve"
 *                   id_livraison: 3
 *                   id_produit: 7
 *                   created_at: "2025-04-28T15:08:37.092Z"
 *                   updated_at: "2025-04-28T16:19:41.256Z"
 *                 produits:
 *                   id_produit: 7
 *                   code_produit: "outils-1"
 *                   desi_produit: "outils-1"
 *                   desc_produit: "test"
 *                   image_produit: "media\\images\\stock_moyensgeneraux\\produits\\tomate_1745872525356.jpeg"
 *                   qte_produit: 1
 *                   emplacement_produit: null
 *                   caracteristiques_produit: null
 *                   prix_produit: null
 *                   id_categorie: null
 *                   id_type_produit: 5
 *                   id_modele: null
 *                   id_famille: null
 *                   id_marque: null
 *                   created_at: "2025-04-28T20:20:28.899Z"
 *                   updated_at: "2025-04-28T20:35:25.365Z"
 *                 type_produits:
 *                   id_type_produit: 5
 *                   libelle: "Outil"
 *                   created_at: "2025-04-28T17:30:41.395Z"
 *                   updated_at: "2025-04-28T17:30:41.395Z"
 */

router.get("/exemplaires", controller.getExemplairesOutils);

/**
 * @swagger
 * /moyens-generaux/outils/sortie:
 *   post:
 *     summary: Enregistre une sortie d'outil
 *     tags: [Outils]
 */
router.post("/sortie", controller.enregistrerSortieOutil);

/**
 * @swagger
 * /moyens-generaux/outils/entree:
 *   post:
 *     summary: Enregistre une entrÃ©e d'outil
 *     tags: [Outils]
 */
router.post("/entree", controller.enregistrerEntreeOutil);

/**
 * @swagger
 * /moyens-generaux/outils/etat/{id_exemplaire}/{id_employes}:
 *   get:
 *     summary: VÃ©rifie si un outil sorti a Ã©tÃ© retournÃ©
 *     tags: [Outils]
 *     parameters:
 *       - name: id_exemplaire
 *         in: path
 *         required: true
 *         description: L'ID de l'exemplaire de l'outil
 *         schema:
 *           type: integer
 *       - name: id_employes
 *         in: path
 *         required: true
 *         description: L'ID de l'employÃ©
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Indique si l'outil a Ã©tÃ© retournÃ©
 *         content:
 *           application/json:
 *             example:
 *               retourne: true
 */

router.get("/etat/:id_exemplaire/:id_employes", controller.estOutilRetourne);

/**
 * @swagger
 * /moyens-generaux/outils/historique/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re l'historique des entrÃ©es et sorties d'un outil spÃ©cifique
 *     tags: [Outils]
 */
router.get("/historique/:id", controller.getHistoriqueOutils);

/**
 * @swagger
 * /moyens-generaux/outils/historiques:
 *   get:
 *     summary: RÃ©cupÃ¨re l'historique global des entrÃ©es et sorties de tous les outils
 *     tags: [Outils]
 *     responses:
 *       200:
 *         description: L'historique des entrÃ©es et sorties de tous les outils
 *         content:
 *           application/json:
 *             examples:
 *               ExempleHistorique:
 *                 value:
 *                   - id_exemplaire: "13"
 *                     historique:
 *                       - id_exemplaire: 13
 *                         type: "sortie"
 *                         date: "2025-04-29T12:03:38.157Z"
 *                         employe: 1
 *                         etat: "bon"
 *                         commentaire: "test"
 *                         site: "test"
 *                         usage: "test"
 *                       - id_exemplaire: 13
 *                         type: "entrÃ©e"
 *                         date: "2025-04-29T12:07:36.981Z"
 *                         employe: 1
 *                         etat: "mauvais"
 *                         commentaire: "test retour"
 */

router.get("/historiques", controller.getHistoriqueGlobal);

module.exports = router;



================================================
File: modules/moyens_generaux/routes/moyens_generaux.routes.js
================================================
const express = require("express");
const router = express.Router();

// Import des sous-routes
const outilsRoutes = require("./mouvementOutil.route");
const moyenstravailRoutes = require("./moyensdeTravail.route"); //moyens de travail
const maintenanceRoutes = require("./maintenance.route"); 
const maintenanceMoyenTravailRoutes = require("./maintenance.route"); 

// Montage des routes

// /**
//  * @swagger
//  * /moyens-generaux/outils:
//  *   description: Routes liÃ©es aux outils
//  *   get:
//  *     summary: AccÃ¨de aux outils
//  *     tags: [Outils]
//  */
router.use("/outils", outilsRoutes);

// /**
//  * @swagger
//  * /moyens-generaux/moyens-travail:
//  *   description: Routes liÃ©es aux moyens de travail
//  *   get:
//  *     summary: AccÃ¨de aux moyens de travail
//  *     tags: [Moyens de Travail]
//  */
router.use("/moyens-travail", moyenstravailRoutes);

// /**
//  * @swagger
//  * /moyens-generaux/maintenances:
//  *   description: Routes liÃ©es aux maintenances
//  *   get:
//  *     summary: AccÃ¨de aux maintenances
//  *     tags: [Maintenances]
//  */
router.use("/maintenances", maintenanceRoutes);


// /**
//  * @swagger
//  * /moyens-generaux/moyen-travails:
//  *   description: Routes liÃ©es aux moyens de travail
//  *   get:
//  *     summary: AccÃ¨de aux maintenances
//  *     tags: [moyen-travails]
//  */
router.use("/moyen-travails", maintenanceMoyenTravailRoutes);

module.exports = router;



================================================
File: modules/moyens_generaux/routes/moyensdeTravail.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/moyensdeTravail.controller");

// CRUD Routes  
/**
 * @swagger
 * /moyens-generaux/moyens-travails:
 *   post:
 *     summary: CrÃ©e un nouveau moyen de travail
 *     tags: [Moyens de Travail]
 */
router.post("/", controller.createMoyensTravail);

/**
 * @swagger
 * /moyens-generaux/moyens-travails:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les moyens de travail
 *     tags: [Moyens de Travail]
 */
router.get("/", controller.getMoyensTravails);

/**
 * @swagger
 * /moyens-generaux/moyens-travails/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un moyen de travail par ID
 *     tags: [Moyens de Travail]
 */
router.get("/:id", controller.getMoyensTravailById);

/**
 * @swagger
 * /moyens-generaux/moyens-travails/{id}:
 *   put:
 *     summary: Met Ã  jour un moyen de travail par ID
 *     tags: [Moyens de Travail]
 */
router.put("/:id", controller.updateMoyensTravail);

/**
 * @swagger
 * /moyens-generaux/moyens-travails/{id}:
 *   delete:
 *     summary: Supprime un moyen de travail par ID
 *     tags: [Moyens de Travail]
 */
router.delete("/:id", controller.deleteMoyensTravail);

//test

module.exports = router;



================================================
File: modules/moyens_generaux/services/maintenance.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
const { maintenances } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createMaintenance = async (data) => {
  const [result] = await db.insert(maintenances).values(data).returning();
  return result;
};

const getMaintenances = async () => {
  return await db.select().from(maintenances);
};

const getMaintenanceById = async (id) => {
  const [result] = await db.select().from(maintenances).where(eq(maintenances.id_maintenance, id));
  return result;
};

const updateMaintenance = async (id, data) => {
  const [result] = await db
    .update(maintenances)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(maintenances.id_maintenance, id))
    .returning();
  return result;
};

const deleteMaintenance = async (id) => {
  const [result] = await db
    .delete(maintenances)
    .where(eq(maintenances.id_maintenance, id))
    .returning();
  return result;
};

module.exports = {
  createMaintenance,
  getMaintenances,
  getMaintenanceById,
  updateMaintenance,
  deleteMaintenance,
};



================================================
File: modules/moyens_generaux/services/maintenanceMoyenTravail.service.js
================================================
// Table de liaison entre maintenant et  moyens de travail
// maintenanceMoyenTravail.service.js
const { eq, and } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
const { maintenance_moyens_travail, maintenances, moyens_de_travail } = require("../../../core/database/models");

// CREATE
const createMaintenanceMoyenTravail = async (data) => {
  const [result] = await db.insert(maintenance_moyens_travail).values(data).returning();
  return result;
};

// READ ALL
const getMaintenanceMoyenTravails = async () => {
  return await db.select({
    id_moyens_de_travail: maintenance_moyens_travail.id_moyens_de_travail,
    id_maintenance: maintenance_moyens_travail.id_maintenance,
    date_maintenance: maintenance_moyens_travail.date_maintenance,
    moyenTravail: {
      id_moyens_de_travail: moyens_de_travail.id_moyens_de_travail,
      denomination: moyens_de_travail.denomination,
    },
    maintenance: {
      id_maintenance: maintenances.id_maintenance,
      recurrence: maintenances.recurrence,
    },
  })
    .from(maintenance_moyens_travail)
    .leftJoin(moyens_de_travail, eq(maintenance_moyens_travail.id_moyens_de_travail, moyens_de_travail.id_moyens_de_travail))
    .leftJoin(maintenances, eq(maintenance_moyens_travail.id_maintenance, maintenances.id_maintenance));
};

// READ ONE
const getMaintenanceMoyenTravailById = async (id_moyens_de_travail, id_maintenance) => {
  const [result] = await db.select({
    id_moyens_de_travail: maintenance_moyens_travail.id_moyens_de_travail,
    id_maintenance: maintenance_moyens_travail.id_maintenance,
    date_maintenance: maintenance_moyens_travail.date_maintenance,
    moyenTravail: {
      id_moyens_de_travail: moyens_de_travail.id_moyens_de_travail,
      denomination: moyens_de_travail.denomination,
    },
    maintenance: {
      id_maintenance: maintenances.id_maintenance,
      recurrence: maintenances.recurrence,
    },
  })
    .from(maintenance_moyens_travail)
    .leftJoin(moyens_de_travail, eq(maintenance_moyens_travail.id_moyens_de_travail, moyens_de_travail.id_moyens_de_travail))
    .leftJoin(maintenances, eq(maintenance_moyens_travail.id_maintenance, maintenances.id_maintenance))
    .where(and(eq(maintenance_moyens_travail.id_moyens_de_travail, id_moyens_de_travail), eq(maintenance_moyens_travail.id_maintenance, id_maintenance)));
  return result;
};

// UPDATE
const updateMaintenanceMoyenTravail = async (id_moyens_de_travail, id_maintenance, data) => {
  const [result] = await db
    .update(maintenance_moyens_travail)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(and(eq(maintenance_moyens_travail.id_moyens_de_travail, id_moyens_de_travail), eq(maintenance_moyens_travail.id_maintenance, id_maintenance)))
    .returning();
  return result;
};

// DELETE
const deleteMaintenanceMoyenTravail = async (id_moyens_de_travail, id_maintenance) => {
  const [result] = await db
    .delete(maintenance_moyens_travail)
    .where(and(eq(maintenance_moyens_travail.id_moyens_de_travail, id_moyens_de_travail), eq(maintenance_moyens_travail.id_maintenance, id_maintenance)))
    .returning();
  return result;
};

module.exports = {
  createMaintenanceMoyenTravail,
  getMaintenanceMoyenTravails,
  getMaintenanceMoyenTravailById,
  updateMaintenanceMoyenTravail,
  deleteMaintenanceMoyenTravail,
};



================================================
File: modules/moyens_generaux/services/mouvementOutil.service.js
================================================
const { eq, and, or, like, sql, asc, desc, inArray } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
const {
  exemplaires,
  produits,
  type_produits,
  employe_sortir_exemplaires,
  employe_entrer_exemplaires,
} = require("../../../core/database/models");

const LIBELLE_OUTIL = "Outil";

const getAllOutils = async () => {
  return await db
    .select()
    .from(produits)
    .innerJoin(
      type_produits,
      eq(produits.id_type_produit, type_produits.id_type_produit)
    )
    .where(eq(type_produits.libelle, LIBELLE_OUTIL));
};

const getExemplairesOutils = async () => {
  return await db
    .select()
    .from(exemplaires)
    .innerJoin(produits, eq(exemplaires.id_produit, produits.id_produit))
    .innerJoin(
      type_produits,
      eq(produits.id_type_produit, type_produits.id_type_produit)
    )
    .where(eq(type_produits.libelle, LIBELLE_OUTIL));
};

const enregistrerSortieOutil = async (data) => {
  await db.insert(employe_sortir_exemplaires).values(data);
};

const enregistrerEntreeOutil = async (data) => {
  await db.insert(employe_entrer_exemplaires).values(data);
};

// VÃ©rifie si un exemplaire sorti a bien Ã©tÃ© retournÃ© par l'employÃ©
async function estOutilRetourne(id_exemplaire, id_employes) {
  const derniereSortie = await db
    .select({ created_at: employe_sortir_exemplaires.created_at })
    .from(employe_sortir_exemplaires)
    .where(
      and(
        eq(employe_sortir_exemplaires.id_exemplaire, id_exemplaire),
        eq(employe_sortir_exemplaires.id_employes, id_employes)
      )
    )
    .orderBy(desc(employe_sortir_exemplaires.created_at))
    .limit(1);

  if (derniereSortie.length === 0) {
    return false; // Jamais sorti
  }

  const derniereEntree = await db
    .select({ created_at: employe_entrer_exemplaires.created_at })
    .from(employe_entrer_exemplaires)
    .where(
      and(
        eq(employe_entrer_exemplaires.id_exemplaire, id_exemplaire),
        eq(employe_entrer_exemplaires.id_employes, id_employes)
      )
    )
    .orderBy(desc(employe_entrer_exemplaires.created_at))
    .limit(1);

  if (derniereEntree.length === 0) {
    return false; // Sorti mais jamais retournÃ©
  }

  // Comparaison : si l'entrÃ©e est postÃ©rieure Ã  la sortie, alors c'est retournÃ©
  return (
    new Date(derniereEntree[0].created_at) >
    new Date(derniereSortie[0].created_at)
  );
}

// Renvoie l'historique des sorties et retours pour un outil donnÃ© (via son libellÃ©)
async function getHistoriqueOutils(id_produit) {
  if (!id_produit) {
    throw new Error("ID requis");
  }

  const exemplairesResult = await db
    .select({ id: exemplaires.id_exemplaire })
    .from(exemplaires)
    .where(eq(exemplaires.id_produit, id_produit));

  if (exemplairesResult.length === 0) {
    return { sorties: [], entrees: [] };
  }

  const ids_exemplaires = exemplairesResult.map((e) => e.id);

  const sorties = await db
    .select({
      id_exemplaire: employe_sortir_exemplaires.id_exemplaire,
      id_employes: employe_sortir_exemplaires.id_employes,
      etat_avant: employe_sortir_exemplaires.etat_avant,
      date_de_sortie: employe_sortir_exemplaires.date_de_sortie,
      site_intervention: employe_sortir_exemplaires.site_intervention,
      but_usage: employe_sortir_exemplaires.but_usage,
      commentaire: employe_sortir_exemplaires.commentaire,
      created_at: employe_sortir_exemplaires.created_at,
    })
    .from(employe_sortir_exemplaires)
    .where(inArray(employe_sortir_exemplaires.id_exemplaire, ids_exemplaires))
    .orderBy(desc(employe_sortir_exemplaires.created_at));

  const entrees = await db
    .select({
      id_exemplaire: employe_entrer_exemplaires.id_exemplaire,
      id_employes: employe_entrer_exemplaires.id_employes,
      etat_apres: employe_entrer_exemplaires.etat_apres,
      date_de_retour: employe_entrer_exemplaires.date_de_retour,
      commentaire: employe_entrer_exemplaires.commentaire,
      created_at: employe_entrer_exemplaires.created_at,
    })
    .from(employe_entrer_exemplaires)
    .where(inArray(employe_entrer_exemplaires.id_exemplaire, ids_exemplaires))
    .orderBy(desc(employe_entrer_exemplaires.created_at));

  return { sorties, entrees };
}

/**
 * RÃ©cupÃ¨re l'historique global des entrÃ©es et sorties de tous les exemplaires.
 * Les actions sont regroupÃ©es par `id_exemplaire`, puis triÃ©es par date.
 * @param {number} page - NumÃ©ro de page.
 * @param {number} limit - Nombre d'Ã©lÃ©ments par page.
 * @returns {Promise<Array>} Historique structurÃ© par exemplaire.
 */
async function getHistoriqueGlobal(page = 1, limit = 10) {
  const offset = (page - 1) * limit;

  // On rÃ©cupÃ¨re les sorties
  const sorties = await db
    .select({
      id_exemplaire: employe_sortir_exemplaires.id_exemplaire,
      type: sql`'sortie'`,
      date: employe_sortir_exemplaires.created_at,
      employe: employe_sortir_exemplaires.id_employes,
      etat: employe_sortir_exemplaires.etat_avant,
      commentaire: employe_sortir_exemplaires.commentaire,
      site: employe_sortir_exemplaires.site_intervention,
      usage: employe_sortir_exemplaires.but_usage,
    })
    .from(employe_sortir_exemplaires);

  // On rÃ©cupÃ¨re les entrÃ©es
  const entrees = await db
    .select({
      id_exemplaire: employe_entrer_exemplaires.id_exemplaire,
      type: sql`'entrÃ©e'`,
      date: employe_entrer_exemplaires.created_at,
      employe: employe_entrer_exemplaires.id_employes,
      etat: employe_entrer_exemplaires.etat_apres,
      commentaire: employe_entrer_exemplaires.commentaire,
    })
    .from(employe_entrer_exemplaires);

  // On fusionne les deux
  const tous = [...sorties, ...entrees];

  // On regroupe par id_exemplaire
  const regroupÃ© = tous.reduce((acc, event) => {
    if (!acc[event.id_exemplaire]) {
      acc[event.id_exemplaire] = [];
    }
    acc[event.id_exemplaire].push(event);
    return acc;
  }, {});

  // On convertit l'objet en tableau formatÃ© et on trie chaque historique
  const resultat = Object.entries(regroupÃ©)
    .map(([id_exemplaire, historique]) => ({
      id_exemplaire,
      historique: historique.sort(
        (a, b) => new Date(a.date) - new Date(b.date)
      ),
    }))
    .sort((a, b) =>
      b.historique.at(-1)?.date?.localeCompare(a.historique.at(-1)?.date)
    ); // Tri par derniÃ¨re activitÃ©

  // Pagination sur le tableau final
  const paginÃ© = resultat.slice(offset, offset + limit);
  return paginÃ©;
}

module.exports = {
  getAllOutils,
  getExemplairesOutils,
  enregistrerSortieOutil,
  enregistrerEntreeOutil,
  estOutilRetourne,
  getHistoriqueOutils,
  getHistoriqueGlobal,
};



================================================
File: modules/moyens_generaux/services/moyensdeTravail.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
const { moyens_de_travail } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createMoyensTravail = async (data) => {
  const [result] = await db.insert(moyens_de_travail).values(data).returning();
  return result;
};

const getMoyensTravails = async () => {
  return await db.select().from(moyens_de_travail);
};

const getMoyensTravailById = async (id) => {
  const [result] = await db.select().from(moyens_de_travail).where(eq(moyens_de_travail.id_moyens_de_travail, id));
  return result;
};

const updateMoyensTravail = async (id, data) => {
  const [result] = await db
    .update(moyens_de_travail)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(moyens_de_travail.id_moyens_de_travail, id))
    .returning();
  return result;
};

const deleteMoyensTravail = async (id) => {
  const [result] = await db
    .delete(moyens_de_travail)
    .where(eq(moyens_de_travail.id_moyens_de_travail, id))
    .returning();
  return result;
};

module.exports = {
  createMoyensTravail,
  getMoyensTravails,
  getMoyensTravailById,
  updateMoyensTravail,
  deleteMoyensTravail,
};



================================================
File: modules/stocks/readme.md
================================================
## Gestion des erreurs de migration Drizzle ORM

Si vous rencontrez l'erreur suivante lors de l'exécution de :

```sh
npx drizzle-kit migrate
```

```sh
error: password authentication failed for user "dcat_user"
    at D:\dcat_backend\node_modules\pg-pool\index.js:45:11
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async PgDialect.migrate (D:\dcat_backend\node_modules\src\pg-core\dialect.ts:85:3)
    at async migrate (D:\dcat_backend\node_modules\src\node-postgres\migrator.ts:10:2) {
  length: 105,
  severity: 'FATAL',
  code: '28P01',
```

### Solution :

Assurez-vous que les fichiers suivants utilisent bien le format de fin de ligne `LF` et non `CRLF` :

- `init-db/init-multiple-dbs.sh`
- `.env`

Pour convertir ces fichiers sous Linux/macOS :

```sh
dos2unix init-db/init-multiple-dbs.sh .env
```

Sous Windows, utilisez un éditeur de texte comme VS Code et modifiez le format de fin de ligne en `LF`.

# États des Exemplaires de Produit

Les exemplaires de produits peuvent se trouver dans différents états en fonction de leur disponibilité, utilisation, ou condition. Voici une description de chaque état possible :

## 1. **Vendu**

- **Description** : L'exemplaire a été acheté par un client et n'est plus disponible à la vente.
- **Utilisation** : Ce statut est attribué après qu'un client a finalisé l'achat d'un exemplaire.

## 2. **Disponible**

- **Description** : L'exemplaire est en stock et prêt à être vendu ou expédié. Il peut être acheté immédiatement par un client.
- **Utilisation** : Quand un exemplaire est prêt à la vente, il est marqué comme "disponible".

## 3. **Utilisation**

- **Description** : L'exemplaire est en cours d'utilisation pour un projet par un employé.

## 4. **En maintenance**

- **Description** : L'exemplaire est temporairement hors service pour des réparations ou un entretien.
- **Utilisation** : Ce statut est utilisé lorsqu'un produit nécessite une intervention technique ou un entretien pour fonctionner correctement.

## 5. **Endommage**

- **Description** : L'exemplaire a subi des dommages physiques et ne peut plus être vendu dans son état actuel.
- **Utilisation** : Ce statut est utilisé lorsque le produit est cassé ou endommagé de manière irréparable ou non vendable.

## 6. **Reserve**

- **Description** : L'exemplaire est réservé pour un client ou une commande, mais l'achat n'a pas encore été finalisé.
- **Utilisation** : Un exemplaire est marqué comme "réservé" lorsqu'il est mis de côté pour une commande en attente de validation.

---

Chaque état permet de gérer l'exemplaire en fonction de son statut actuel dans le cycle de vie du produit, afin de garantir une gestion efficace et une communication claire sur la disponibilité des produits.

# Gestion des Produits : Équipements vs Outils

Dans ce module, les produits sont classés en deux grandes catégories grâce à la table `type_produit` :

- **Équipements** : produits destinés à être **vendus**.
- **Outils** : produits destinés à être **utilisés** par les employés sur le terrain.

---

## 🛠️ Outils

Les outils sont utilisés dans les chantiers ou les projets internes. Leur gestion inclut :

- **Sortie d’outil** : l’outil est attribué à un employé.
- **Suivi d’état** : on note l’état de l’outil avant et après utilisation.
- **Retour d’outil** : lorsqu’un outil revient, on met à jour sa fiche d’usage.

Ces données sont stockées dans la table `usage_exemplaires`.

---

## 📦 Équipements

Les équipements, quant à eux, suivent une logique de **stock** et de **vente**. Ils sont considérés comme des biens destinés à être cédés aux partenaires ou clients. La logique de gestion de stock inclut :

- Suivi des exemplaires disponibles.
- Passage de commande.
- Réduction du stock après vente.

---

## 🔍 Résumé

| Type de produit | Usage principal     | Logique associée       |
| --------------- | ------------------- | ---------------------- |
| Équipement      | Vente               | Stock / Commande       |
| Outil           | Utilisation terrain | Sortie / Retour / État |

Cette distinction permet d’adapter les traitements métier à la nature réelle du produit.



================================================
File: modules/stocks/controllers/achat.controller.js
================================================
/**
 * Ce fichier est utilisÃ© pour modifier les informations de prix pour une livraison d'exemplaire
 * 
 * 
 */
const achatService = require("../services/achat.service");

const updateAchat = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (!req.body || Object.keys(req.body).length === 0) {
      return res.status(400).json({ error: "Aucune donnÃ©e Ã  mettre Ã  jour" });
    }
    const result = await achatService.updateAchatFields(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(400).json({ error: "Ã‰chec de la mise Ã  jour", details: error.message });
  }
};


const getAchatById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const result = await achatService.getAchatById(id);
    if (!result) return res.status(404).json({ error: "Achat introuvable" });
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: "Erreur serveur", details: error.message });
  }
};

const getAllAchats = async (req, res) => {
  try {
    const result = await achatService.getAllAchats();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: "Erreur serveur", details: error.message });
  }
};



const getAchatByExemplaireId = async (req, res) => {
    try {
      const idExemplaire = parseInt(req.params.id);
      if (isNaN(idExemplaire)) {
        return res.status(400).json({ error: "ID exemplaire invalide" });
      }
  
      const result = await achatService.getAchatByExemplaireId(idExemplaire);
      if (!result) {
        return res.status(404).json({ error: "Achat introuvable pour cet exemplaire" });
      }
  
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: "Erreur serveur", details: error.message });
    }
  };



module.exports = {
  updateAchat,
  getAchatById,
  getAllAchats,
  getAchatByExemplaireId,
};



================================================
File: modules/stocks/controllers/categorie.controller.js
================================================
const categorieService = require("../services/categorie.service");

// CREATE
const createCategorie = async (req, res) => {
  try {
    if (!req.body.libelle) {
      return res.status(400).json({ error: "Le libellÃ© est requis" });
    }
    const result = await categorieService.createCategorie(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getCategories = async (req, res) => {
  try {
    const result = await categorieService.getCategories();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getCategorieById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await categorieService.getCategorieById(id);
    if (!result) {
      return res.status(404).json({ error: "Categorie non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateCategorie = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await categorieService.updateCategorie(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteCategorie = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await categorieService.deleteCategorie(id);
    res.json({ message: "Categorie supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};


module.exports = {
  createCategorie,
  getCategories,
  getCategorieById,
  updateCategorie,
  deleteCategorie
};


================================================
File: modules/stocks/controllers/commande.controller.js
================================================
const commandeService = require("../services/commande.service");

/**
 * 
const commande = await createCommande({
  produitsQuantites: { 1: 2, 3: 1 }, // 2x produit ID 1, 1x produit ID 3
  partenaireId: 5,
  lieuLivraison: "Magasin principal",
  dateLivraison: "2025-05-10",
  modePaiement: "carte"
});
 */

const createCommande = async (req, res) => {
  try {
    const commande = await commandeService.createCommande(req.body);
    res.status(201).json(commande);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

const getCommandeById = async (req, res) => {
  try {
    const commande = await commandeService.getCommandeById(
      parseInt(req.params.id)
    );
    res.status(200).json(commande);
  } catch (err) {
    res.status(404).json({ error: err.message });
  }
};

/**
 * Exemple d'utilisation
 *
 * GET /api/commandes?limit=10&offset=20&etat=confirmee
 *
 */

const getAllCommandes = async (req, res) => {
  try {
    const { limit, offset, etat } = req.query;
    const commandes = await commandeService.getAllCommandes({
      limit: Number(limit) || 50,
      offset: Number(offset) || 0,
      etat,
    });
    res.status(200).json(commandes);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

const updateCommande = async (req, res) => {
  try {
    const commande = await commandeService.updateCommande(
      Number(req.params.id),
      req.body
    );
    res.status(200).json(commande);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

const deleteCommande = async (req, res) => {
  try {
    const result = await commandeService.deleteCommande(Number(req.params.id));
    res.status(200).json(result);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

module.exports = {
  getCommandeById,
  getAllCommandes,
  updateCommande,
  deleteCommande,
  createCommande,
};



================================================
File: modules/stocks/controllers/exemplaire.controller.js
================================================
const exemplaireService = require("../services/exemplaire.service");

const createExemplaire = async (req, res) => {
  try {
    const result = await exemplaireService.createExemplaire(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getExemplaires = async (req, res) => {
  try {
    const result = await exemplaireService.getExemplaires();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getExemplaireById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await exemplaireService.getExemplaireById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

//rechercher un exemplaire Ã  partir d'un numÃ©ro de series
const getExemplaireByNumSerie = async (req, res) => {
  try {
    const num_serie = req.params.num_serie;

    const result = await exemplaireService.getExemplaireByNumSerie(num_serie);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateExemplaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const data = req.body;

    if (!data || typeof data !== "object") {
      throw new Error(
        "Les donnÃ©es Ã  mettre Ã  jour sont invalides ou manquantes."
      );
    }

    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await exemplaireService.updateExemplaire(id, data);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteExemplaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await exemplaireService.deleteExemplaire(id);
    return res.json({ message: "Ã©lÃ©ment supprimÃ© avec succÃ¨s" });
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

// obtenir tout les exemplaires d'un produit
const getExemplairesByProduit = async (req, res) => {
  try {
    const id = req.params.id;

    if (!id) {
      return res.status(400).json({ message: "paramÃ¨tre manquant" });
    }

    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }

    const result = await exemplaireService.getExemplairesByProduit(
      parseInt(id)
    );
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

//filtrer les exemplaires selon leur etat (disponible,vendu...)
// id : id du produit de l'exemplaire ; etat : etat de l'exemplaire ("Vendu"...)
const filterExemplairesByEtat = async (req, res) => {
  try {
    const { id, etat } = req.params;

    // VÃ©rification des paramÃ¨tres
    if (!id || !etat) {
      return res.status(400).json({ error: "ParamÃ¨tres requis : id et etat" });
    }

    const parsedId = parseInt(id);

    if (isNaN(parsedId)) {
      return res
        .status(400)
        .json({ error: "ID invalide (doit Ãªtre un nombre)" });
    }

    // Liste blanche des Ã©tats valides
    const etatsAutorises = [
      "Disponible",
      "Vendu",
      "Utilisation",
      "En maintenance",
      "Endommage",
      "Reserve",
    ];
    if (!etatsAutorises.includes(etat)) {
      return res.status(400).json({
        error: `Etat invalide. Les Ã©tats autorisÃ©s sont : ${etatsAutorises.join(
          ", "
        )}`,
      });
    }

    const results = await exemplaireService.filterExemplairesByEtat(
      parsedId,
      etat
    );
    return res.status(200).json(results);
  } catch (error) {
    return res.status(500).json({
      error: "Une erreur est survenue lors du filtrage",
      details: error.message,
    });
  }
};

// // VÃ©rifie si un exemplaire spÃ©cifique est en cours d'utilisation
// const isExemplaireInUse = async (req, res) => {
//   try {
//     const id = req.param.id;
//     const results = await exemplaireService.isExemplaireInUse(parseInt(id));
//     return res.status(200).json(results);
//   } catch (error) {
//     return res.status(500).json({
//       error: "Une erreur est survenue",
//       details: error.message,
//     });
//   }
// };

// // RÃ©cupÃ¨re tous les exemplaires actuellement en cours d'utilisation
// const isExemplairesInUse = async (req, res) => {
//   try {
//     const results = await exemplaireService.isExemplairesInUse();
//     return res.status(200).json(results);
//   } catch (error) {
//     return res.status(500).json({
//       error: "Une erreur est survenue",
//       details: error.message,
//     });
//   }
// };

module.exports = {
  createExemplaire,
  getExemplaires,
  getExemplaireById,
  getExemplaireByNumSerie,
  updateExemplaire,
  deleteExemplaire,
  getExemplairesByProduit,
  // isExemplaireInUse,
  // isExemplairesInUse,

  filterExemplairesByEtat,
};



================================================
File: modules/stocks/controllers/famille.controller.js
================================================
const familleService = require("../services/famille.service");

// CREATE
const createFamille = async (req, res) => {
  try {
    if (!req.body.libelle_famille) {
      return res.status(400).json({ error: "Le libellÃ© est requis" });
    }
    const result = await familleService.createFamille(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getFamilles = async (req, res) => {
  try {
    const result = await familleService.getFamilles();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getFamilleById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await familleService.getFamilleById(id);
    if (!result) {
      return res.status(404).json({ error: "Famille non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateFamille = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await familleService.updateFamille(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteFamille = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await familleService.deleteFamille(id);
    res.json({ message: "Famille supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};


module.exports = {
  createFamille,
  getFamilles,
  getFamilleById,
  updateFamille,
  deleteFamille
};


================================================
File: modules/stocks/controllers/livraison.controller.js
================================================
const livraisonService = require("../services/livraison.service");

// CREATE
const createLivraison = async (req, res) => {
  try {
    const result = await livraisonService.createLivraison(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la crÃ©ation",
      details: error.message,
    });
  }
};

// READ ALL
const getLivraisons = async (req, res) => {
  try {
    const result = await livraisonService.getLivraisons();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message,
    });
  }
};

// READ ONE
const getLivraisonById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await livraisonService.getLivraisonById(id);
    if (!result) {
      return res.status(404).json({ error: "Livraison non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message,
    });
  }
};

// UPDATE
const updateLivraison = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await livraisonService.updateLivraison(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la mise Ã  jour",
      details: error.message,
    });
  }
};

// DELETE
const deleteLivraison = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await livraisonService.deleteLivraison(id);
    res.json({ message: "Livraison supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la suppression",
      details: error.message,
    });
  }
};

// Voir les exemplaires ajoutÃ©s lors dâ€™une livraisons
const getLivraisonExemplaire = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await livraisonService.getLivraisonExemplaire(id);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      error: "Une erreur est survenue",
      details: error.message,
    });
  }
};

module.exports = {
  createLivraison,
  getLivraisons,
  getLivraisonById,
  updateLivraison,
  deleteLivraison,
  getLivraisonExemplaire
};



================================================
File: modules/stocks/controllers/marque.controller.js
================================================
const marqueService = require("../services/marque.service");

const createMarque = async (req, res) => {
  try {
    const result = await marqueService.createMarque(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getMarques = async (req, res) => {
  try {
    const result = await marqueService.getMarques();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getMarqueById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.getMarqueById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateMarque = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.updateMarque(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteMarque = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.deleteMarque(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createMarque,
  getMarques,
  getMarqueById,
  updateMarque,
  deleteMarque,
};



================================================
File: modules/stocks/controllers/modele.controller.js
================================================
const modeleService = require("../services/modele.service");

const createModele = async (req, res) => {
  try {
    const result = await modeleService.createModele(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getModeles = async (req, res) => {
  try {
    const result = await modeleService.getModeles();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getModeleById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.getModeleById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateModele = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.updateModele(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteModele = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.deleteModele(id);
    return res.json(result);
  } catch (error) {
    re
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createModele,
  getModeles,
  getModeleById,
  updateModele,
  deleteModele,
};





// [
//   {"libelle_modele": "Bravia X90J", "id_marque": 1 },
//   {"libelle_modele": "EliteBook 840", "id_marque": 2 },
//   {"libelle_modele": "Galaxy Tab S9", "id_marque": 3 },
//   {"libelle_modele": "OLED CX", "id_marque": 4 },
//   {"libelle_modele": "Tiger Neo N-type", "id_marque": 5 },
//   {"libelle_modele": "Tahoma Switch", "id_marque": 6 },
//   {"libelle_modele": "SmartHub 3", "id_marque": 3 },
//   {"libelle_modele": "ProDesk 600", "id_marque": 2 }
// ]



// [
//   {"libelle_modele": "Bravia X90J"},
//   {"libelle_modele": "EliteBook 840"},
//   {"libelle_modele": "Galaxy Tab S9"},
//   {"libelle_modele": "OLED CX"},
//   {"libelle_modele": "Tiger Neo N-type"},
//   {"libelle_modele": "Tahoma Switch"},
//   {"libelle_modele": "SmartHub 3"},
//   {"libelle_modele": "ProDesk 600"}
// ]




================================================
File: modules/stocks/controllers/produit.controller.js
================================================
const produitService = require("../services/produit.service");
const upload = require("../../utils/middleware/uploadMiddleware");
const path = require("path");
const fs = require("fs");

// Configuration du dossier d'upload (depuis la racine du projet)
const UPLOAD_DIR = path.join(process.cwd(), 'media', 'images', 'stock_moyensgeneraux', 'produits');

const createProduit = async (req, res) => {
  try {
    // Configuration du chemin d'upload pour cette requÃªte
    req.uploadPath = UPLOAD_DIR;
    
    // Utilisation du middleware Multer pour gÃ©rer l'upload
    upload.single('image_produit')(req, res, async (err) => {
      if (err) {
        return res.status(400).json({ 
          error: "Erreur lors de l'upload de l'image",
          details: err.message 
        });
      }

      // PrÃ©paration des donnÃ©es du produit
      const produitData = {
        ...req.body,
        // Si un fichier a Ã©tÃ© uploadÃ©, on stocke le chemin relatif
        image_produit: req.file 
          ? path.join('media', 'images', 'stock_moyensgeneraux', 'produits', req.file.filename)
          : null
      };

      const result = await produitService.createProduit(produitData);
      return res.status(201).json(result);
    });
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la crÃ©ation du produit", 
      details: error.message 
    });
  }
};

const getProduits = async (req, res) => {
  try {
    const produits = await produitService.getProduits();
    
    // Transformer les chemins d'images en URLs accessibles si nÃ©cessaire
    const result = produits.map(produit => ({
      ...produit,
      image_url: produit.image_produit 
        ? `${req.protocol}://${req.get('host')}/${produit.image_produit.replace(/\\/g, '/')}`
        : null
    }));

    return res.status(200).json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la rÃ©cupÃ©ration des produits", 
      details: error.message 
    });
  }
};

const getProduitsByTypes = async (req, res) => {
  try {
    const idType = parseInt(req.params.idType);
    if (isNaN(idType)) {
      return res.status(400).json({ error: "ID de type de produit invalide" });
    }
    
    const produits = await produitService.getProduitsByTypes(Number(idType));
    
    // Transformer les chemins d'images en URLs accessibles si nÃ©cessaire
    const result = produits.map(produit => ({
      ...produit,
      image_url: produit.image_produit 
        ? `${req.protocol}://${req.get('host')}/${produit.image_produit.replace(/\\/g, '/')}`
        : null
    }));

    return res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la rÃ©cupÃ©ration des produits par type", 
      details: error.message 
    });
  }
};

const getProduitById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID de produit invalide" });
    }
    
    const produit = await produitService.getProduitById(Number(id));
    
    if (!produit) {
      return res.status(404).json({ error: "Produit non trouvÃ©" });
    }

    // Ajouter l'URL complÃ¨te de l'image si elle existe
    const result = {
      ...produit,
      image_url: produit.image_produit 
        ? `${req.protocol}://${req.get('host')}/${produit.image_produit.replace(/\\/g, '/')}`
        : null
    };

    return res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la rÃ©cupÃ©ration du produit", 
      details: error.message 
    });
  }
};

const updateProduit = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID de produit invalide" });
    }

    req.uploadPath = UPLOAD_DIR;
    
    upload.single('image_produit')(req, res, async (err) => {
      if (err) {
        return res.status(400).json({ 
          error: "Erreur lors de l'upload de l'image",
          details: err.message 
        });
      }

      // RÃ©cupÃ©rer l'ancien produit pour supprimer l'image existante si nÃ©cessaire
      const existingProduit = await produitService.getProduitById(id);
      if (!existingProduit) {
        return res.status(404).json({ error: "Produit non trouvÃ©" });
      }

      // PrÃ©paration des donnÃ©es de mise Ã  jour
      const updateData = {
        ...req.body,
        updated_at: new Date()
      };

      if (req.file) {
        // Si une nouvelle image est uploadÃ©e
        updateData.image_produit = path.join('media', 'images', 'stock_moyensgeneraux', 'produits', req.file.filename);
        
        // Supprimer l'ancienne image si elle existe
        if (existingProduit.image_produit) {
          const oldImagePath = path.join(process.cwd(), existingProduit.image_produit);
          if (fs.existsSync(oldImagePath)) {
            fs.unlinkSync(oldImagePath);
          }
        }
      }

      const result = await produitService.updateProduit(id, updateData);
      return res.json(result);
    });
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la mise Ã  jour du produit", 
      details: error.message 
    });
  }
};

const deleteProduit = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID de produit invalide" });
    }

    // RÃ©cupÃ©rer le produit avant suppression pour supprimer son image
    const produit = await produitService.getProduitById(id);
    if (!produit) {
      return res.status(404).json({ error: "Produit non trouvÃ©" });
    }

    const result = await produitService.deleteProduit(id);

    // Supprimer l'image associÃ©e si elle existe
    if (produit.image_produit) {
      const imagePath = path.join(process.cwd(), produit.image_produit);
      if (fs.existsSync(imagePath)) {
        fs.unlinkSync(imagePath);
      }
    }

    return res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Une erreur est survenue lors de la suppression du produit", 
      details: error.message 
    });
  }
};

module.exports = {
  createProduit,
  getProduits,
  getProduitById,
  updateProduit,
  deleteProduit,
  getProduitsByTypes
};


================================================
File: modules/stocks/controllers/sortiesExemplaire.controller.js
================================================
const { json } = require("sequelize");
const sortieService = require("../services/sortieExemplaire.service");

// CrÃ©er une sortie
const createSortie = async (req, res) => {
  try {
    const { type_sortie, reference_id, id_exemplaire, date_sortie } = req.body;

    // Validation minimale
    if (!type_sortie || !reference_id || !id_exemplaire) {
      return errorResponse(
        res,
        400,
        "Type, rÃ©fÃ©rence et exemplaire sont obligatoires"
      );
    }

    const sortie = await sortieService.createSortie({
      type_sortie,
      reference_id,
      id_exemplaire,
      date_sortie,
    });

    return res.status(201).json(sortie);
  } catch (error) {
    res.status(500).json({
      error: "Erreur lors de la crÃ©ation",
      details: error.message,
    });
  }
};

// Lister les sorties avec filtres
const getSorties = async (req, res) => {
  try {
    // RÃ©cupÃ©ration des paramÃ¨tres de pagination (avec valeurs par dÃ©faut)
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const offset = (page - 1) * limit;

    const filters = {
      type_sortie: req.query.type_sortie,
      reference_id: req.query.reference_id
        ? parseInt(req.query.reference_id)
        : undefined,
      id_exemplaire: req.query.id_exemplaire
        ? parseInt(req.query.id_exemplaire)
        : undefined,
      start_date: req.query.start_date,
      end_date: req.query.end_date,
    };

    const { sorties, total } = await sortieService.getSorties(filters, {
      limit,
      offset,
    });

    const totalPages = Math.ceil(total / limit);

    const response = {
      data: sorties,
      pagination: {
        totalItems: total,
        totalPages,
        currentPage: page,
        itemsPerPage: limit,
        hasNextPage: page < totalPages,
        hasPreviousPage: page > 1,
      },
    };

    return res.status(200).json(response);
  } catch (error) {
    res.status(500).json({
      error: "Une erreur est survenue",
      details: error.message,
    });
  }
};

// RÃ©cupÃ©rer les dÃ©tails d'une sortie
const getSortieDetails = async (req, res) => {
  try {
    const { id } = req.params;
    const details = await sortieService.getSortieDetails(parseInt(id));

    if (!details) {
      return res.status(404).json({ error: "Sortie non trouvÃ©e" });
    }

    return res.status(200).json({ details: "DÃ©tails de la sortie" });
  } catch (error) {
    res.status(500).json({
      error: "Une erreur est survenue",
      details: error.message,
    });
  }
};

// Mettre Ã  jour une sortie
const updateSortie = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    if (Object.keys(updateData).length === 0) {
      return errorResponse(res, 400, "Aucune donnÃ©e Ã  mettre Ã  jour");
    }

    const updated = await sortieService.updateSortie(parseInt(id), updateData);
    return res.status(200).json({ updated: "Sortie mise Ã  jour" });
  } catch (error) {
    res.status(500).json({
      error: "Une erreur est survenue",
      details: error.message,
    });
  }
};

// Supprimer une sortie
const deleteSortie = async (req, res) => {
  try {
    const { id } = req.params;
    const deleted = await sortieService.deleteSortie(parseInt(id));

    return res
      .status(200)
      .json({ message: "Sortie supprimÃ©e et exemplaire rÃ©activÃ©" },deleted);
  } catch (error) {
    if (error.message === "Sortie non trouvÃ©e") {
      return res.status(404).json({
        error: "Une erreur est survenue",
        details: error.message,
      });
    }
    res.status(500).json({
      error: "Une erreur est survenue",
      details: error.message,
    });
  }
};

module.exports = {
  createSortie,
  getSorties,
  getSortieDetails,
  updateSortie,
  deleteSortie,
};



================================================
File: modules/stocks/controllers/stocks.controller.js
================================================
ï»¿// const stockService = require('../services/stocks.service');

// module.exports = {
//   getAll: (req, res, next) => {
//     try {
//       const stockItems = stockService.getAllStockItems();
//       res.json(stockItems);
//     } catch (err) {
//       next(err);
//     }
//   },
//   create: (req, res, next) => {
//     try {
//       const newItem = stockService.createStockItem(req.body);
//       res.status(201).json(newItem);
//     } catch (err) {
//       next(err);
//     }
//   }
// };


================================================
File: modules/stocks/controllers/typesProduit.controller.js
================================================
const typeProduitService = require("../services/typesProduit.service");

// CREATE
const createTypeProduit = async (req, res) => {
  try {
    if (!req.body.libelle) {
      return res.status(400).json({ error: "Le libellÃ© est requis" });
    }
    const result = await typeProduitService.createTypeProduit(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getTypeProduits = async (req, res) => {
  try {
    const result = await typeProduitService.getTypeProduits();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getTypeProduitById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await typeProduitService.getTypeProduitById(id);
    if (!result) {
      return res.status(404).json({ error: "TypeProduit non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateTypeProduit = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await typeProduitService.updateTypeProduit(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteTypeProduit = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await typeProduitService.deleteTypeProduit(id);
    res.json({ message: "TypeProduit supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};


module.exports = {
  createTypeProduit,
  getTypeProduits,
  getTypeProduitById,
  updateTypeProduit,
  deleteTypeProduit
};


================================================
File: modules/stocks/routes/achat.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/achat.controller");

/**
 * id: id de la livraison
 */


/**
 * @swagger
 * /stocks/achats:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les achats
 *     description: Retourne la liste complÃ¨te de tous les achats enregistrÃ©s
 *     tags: [Achats]
 *     responses:
 *       200:
 *         description: Liste des achats rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   fournisseur:
 *                     type: string
 *                     example: "FOURNISSEUR 1"
 *                   date:
 *                     type: string
 *                     format: date
 *                     example: "2025-05-05"
 *                   montant:
 *                     type: number
 *                     format: float
 *                     example: 25000
 *       500:
 *         description: Erreur serveur
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
router.get("/", controller.getAllAchats);

/**
 * @swagger
 * /stocks/achats/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un achat par ID
 *     tags: [Achats]
 */
router.get("/:id", controller.getAchatById);

/**
 * @swagger
 * /stocks/achats/{id}:
 *   put:
 *     summary: Met Ã  jour un achat par ID
 *     tags: [Achats]
 */
router.put("/:id", controller.updateAchat);

/**
 * @swagger
 * /stocks/achats/exemplaire/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un achat via l'ID d'un exemplaire
 *     tags: [Achats]
 */
router.get("/exemplaire/:id", controller.getAchatByExemplaireId);

module.exports = router;


================================================
File: modules/stocks/routes/categorie.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/categorie.controller");

// CRUD Routes

/**
 * @swagger
 * /stocks/categories:
 *   post:
 *     summary: CrÃ©e une nouvelle catÃ©gorie
 *     tags: [CatÃ©gories]
 */
router.post("/", controller.createCategorie);

/**
 * @swagger
 * /stocks/categories:
 *   get:
 *     summary: RÃ©cupÃ¨re toutes les catÃ©gories
 *     tags: [CatÃ©gories]
 *     responses:
 *       200:
 *         description: Liste des catÃ©gories
 *         content:
 *           application/json:
 *             example:
 *               - id_categorie: 1
 *                 libelle: "categorie-001"
 *                 created_at: "2025-04-23T11:40:49.215Z"
 *                 updated_at: "2025-04-23T11:40:49.215Z"
 *               - id_categorie: 2
 *                 libelle: "categorie-002"
 *                 created_at: "2025-04-23T11:40:55.225Z"
 *                 updated_at: "2025-04-23T11:40:55.225Z"
 *               - id_categorie: 3
 *                 libelle: "categorie-003"
 *                 created_at: "2025-04-23T11:41:00.366Z"
 *                 updated_at: "2025-04-23T11:41:00.366Z"
 */
router.get("/", controller.getCategories);

/**
 * @swagger
 * /stocks/categories/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une catÃ©gorie par ID
 *     tags: [CatÃ©gories]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: CatÃ©gorie rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id_categorie:
 *                   type: integer
 *                   example: 1
 *                 libelle:
 *                   type: string
 *                   example: "categorie-001"
 *                 created_at:
 *                   type: string
 *                   format: date-time
 *                 updated_at:
 *                   type: string
 *                   format: date-time
 *       404:
 *         description: CatÃ©gorie non trouvÃ©e
 */
router.get("/:id", controller.getCategorieById);

/**
 * @swagger
 * /stocks/categories/{id}:
 *   put:
 *     summary: Met Ã  jour une catÃ©gorie par ID
 *     tags: [CatÃ©gories]
 */
router.put("/:id", controller.updateCategorie);

/**
 * @swagger
 * /stocks/categories/{id}:
 *   delete:
 *     summary: Supprime une catÃ©gorie par ID
 *     tags: [CatÃ©gories]
 */
router.delete("/:id", controller.deleteCategorie);

module.exports = router;



================================================
File: modules/stocks/routes/commande.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/commande.controller");


/**
 * @swagger
 * /stocks/commandes:
 *   post:
 *     summary: CrÃ©e une nouvelle commande
 *     tags: [Commandes]
 */
router.post("/", controller.createCommande);

/**
 * @swagger
 * /stocks/commandes:
 *   get:
 *     summary: RÃ©cupÃ¨re toutes les commandes
 *     tags: [Commandes]
 *     responses:
 *       200:
 *         description: Liste des commandes avec leurs partenaires
 *         content:
 *           application/json:
 *             example:
 *               - commandes:
 *                   id_commande: 13
 *                   date_de_commande: "2025-04-28"
 *                   etat_commande: "en cours"
 *                   date_livraison: "2025-04-30"
 *                   lieu_de_livraison: "Hit radio"
 *                   mode_de_paiement: "espÃ¨ce"
 *                   id_client: null
 *                   created_at: "2025-04-28T16:19:41.229Z"
 *                   updated_at: "2025-04-28T16:19:41.229Z"
 *                 partenaire_commandes:
 *                   id_partenaire: 3
 *                   id_commande: 13
 *                   created_at: "2025-04-28T16:19:41.241Z"
 *                   updated_at: "2025-04-28T16:19:41.241Z"
 *                 partenaires:
 *                   id_partenaire: 3
 *                   nom_partenaire: "Axo"
 *                   telephone_partenaire: "0303030303"
 *                   email_partenaire: "test-3@gmail.com"
 *                   specialite: "test-3"
 *                   localisation: "test-3"
 *                   type_partenaire: "test-3"
 *                   statut: "test-3"
 *                   id_entite: 1
 *                   created_at: "2025-04-23T11:12:51.310Z"
 *                   updated_at: "2025-04-23T11:12:51.310Z"
 */

router.get("/", controller.getAllCommandes);

/**
 * @swagger
 * /stocks/commandes/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une commande par ID
 *     tags: [Commandes]
 */
router.get("/:id", controller.getCommandeById);

/**
 * @swagger
 * /stocks/commandes/{id}:
 *   put:
 *     summary: Met Ã  jour une commande par ID
 *     tags: [Commandes]
 */
router.put("/:id", controller.updateCommande);

/**
 * @swagger
 * /stocks/commandes/{id}:
 *   delete:
 *     summary: Supprime une commande par ID
 *     tags: [Commandes]
 */
router.delete("/:id", controller.deleteCommande);


module.exports = router;



================================================
File: modules/stocks/routes/exemplaire.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/exemplaire.controller");

// // CRUD Routes
// router.post("/", controller.createExemplaire);
// router.get("/", controller.getExemplaires);
// router.get("/:id", controller.getExemplaireById);
// router.get("/series/:num_serie", controller.getExemplaireByNumSerie); //rechercher un exemplaire Ã  partir d'un numÃ©ro de series
// router.put("/:id", controller.updateExemplaire);
// router.delete("/:id", controller.deleteExemplaire);

// router.get("/produit/:id", controller.getExemplairesByProduit); // id et code forme la clÃ© Ã©trangÃ¨re composÃ©e de la table produit
// // router.get("/:id/is-in-use", controller.isExemplaireInUse); // VÃ©rifie si un exemplaire spÃ©cifique est en cours d'utilisation
// // router.get("/in-use", controller.isExemplairesInUse); // RÃ©cupÃ¨re tous les exemplaires actuellement en cours d'utilisation

// //id: id du produit
// router.get("/produit/:id/etat/:etat", controller.filterExemplairesByEtat); //   filtrer les exemplaires selon leur etat (disponible,vendu...)

/**
 * @swagger
 * /stocks/exemplaires:
 *   post:
 *     summary: CrÃ©e un nouvel exemplaire
 *     tags: [Exemplaires]
 */
router.post("/", controller.createExemplaire);

/**
 * @swagger
 * /stocks/exemplaires:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les exemplaires
 *     tags: [Exemplaires]
 *     responses:
 *       200:
 *         description: Liste des exemplaires
 *         content:
 *           application/json:
 *             example:
 *               - id_exemplaire: 11
 *                 num_serie: "serie-5"
 *                 date_entree: "2025-04-23"
 *                 etat_exemplaire: "Disponible"
 *                 id_livraison: 1
 *                 id_produit: 5
 *                 created_at: "2025-04-28T15:07:29.561Z"
 *                 updated_at: "2025-04-28T15:54:11.714Z"
 *               - id_exemplaire: 12
 *                 num_serie: "serie-6"
 *                 date_entree: "2025-04-23"
 *                 etat_exemplaire: "Reserve"
 *                 id_livraison: 1
 *                 id_produit: 5
 *                 created_at: "2025-04-28T15:07:40.083Z"
 *                 updated_at: "2025-04-28T16:19:41.256Z"
 */

router.get("/", controller.getExemplaires);

/**
 * @swagger
 * /stocks/exemplaires/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un exemplaire par ID
 *     tags: [Exemplaires]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'exemplaire
 *     responses:
 *       200:
 *         description: DÃ©tails de l'exemplaire
 *         content:
 *           application/json:
 *             example:
 *               id_exemplaire: 11
 *               num_serie: "serie-5"
 *               date_entree: "2025-04-23"
 *               etat_exemplaire: "Disponible"
 *               id_livraison: 1
 *               id_produit: 5
 *               created_at: "2025-04-28T15:07:29.561Z"
 *               updated_at: "2025-04-28T15:54:11.714Z"
 */

router.get("/:id", controller.getExemplaireById);

/**
 * @swagger
 * /stocks/exemplaires/series/{num_serie}:
 *   get:
 *     summary: RÃ©cupÃ¨re un exemplaire par numÃ©ro de sÃ©rie
 *     tags: [Exemplaires]
 */
router.get("/series/:num_serie", controller.getExemplaireByNumSerie);

/**
 * @swagger
 * /stocks/exemplaires/{id}:
 *   put:
 *     summary: Met Ã  jour un exemplaire par ID
 *     tags: [Exemplaires]
 */
router.put("/:id", controller.updateExemplaire);

/**
 * @swagger
 * /stocks/exemplaires/{id}:
 *   delete:
 *     summary: Supprime un exemplaire par ID
 *     tags: [Exemplaires]
 */
router.delete("/:id", controller.deleteExemplaire);

/**
 * @swagger
 * /stocks/exemplaires/produit/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re les exemplaires dâ€™un produit
 *     tags: [Exemplaires]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du produit
 *     responses:
 *       200:
 *         description: Liste des exemplaires associÃ©s au produit
 *         content:
 *           application/json:
 *             example:
 *               - id_exemplaire: 11
 *                 num_serie: "serie-5"
 *                 date_entree: "2025-04-23"
 *                 etat_exemplaire: "Disponible"
 *                 id_livraison: 1
 *                 id_produit: 5
 *                 created_at: "2025-04-28T15:07:29.561Z"
 *                 updated_at: "2025-04-28T15:54:11.714Z"
 *               - id_exemplaire: 12
 *                 num_serie: "serie-6"
 *                 date_entree: "2025-04-23"
 *                 etat_exemplaire: "Reserve"
 *                 id_livraison: 1
 *                 id_produit: 5
 *                 created_at: "2025-04-28T15:07:40.083Z"
 *                 updated_at: "2025-04-28T16:19:41.256Z"
 */

router.get("/produit/:id", controller.getExemplairesByProduit);

/**
 * @swagger
 * /stocks/exemplaires/produit/{id}/etat/{etat}:
 *   get:
 *     summary: Filtre les exemplaires d'un produit selon leur Ã©tat
 *     tags: [Exemplaires]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du produit
 *       - in: path
 *         name: etat
 *         required: true
 *         schema:
 *           type: string
 *         description: "Vendu, Disponible, Utilisation, En maintenance, Endommage, Reserve"
 *     responses:
 *       200:
 *         description: Liste des exemplaires filtrÃ©s selon l'Ã©tat, avec total
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 total:
 *                   type: integer
 *                   example: 3
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id_exemplaire:
 *                         type: integer
 *                         example: 11
 *                       num_serie:
 *                         type: string
 *                         example: "serie-5"
 *                       date_entree:
 *                         type: string
 *                         format: date
 *                         example: "2025-04-23"
 *                       etat_exemplaire:
 *                         type: string
 *                         example: "Disponible"
 *                       id_livraison:
 *                         type: integer
 *                         example: 1
 *                       id_produit:
 *                         type: integer
 *                         example: 5
 *                       created_at:
 *                         type: string
 *                         format: date-time
 *                         example: "2025-04-28T15:07:29.561Z"
 *                       updated_at:
 *                         type: string
 *                         format: date-time
 *                         example: "2025-04-28T15:54:11.714Z"
 */


router.get("/produit/:id/etat/:etat", controller.filterExemplairesByEtat);  // id : id du produit de l'exemplaire ; etat : etat de l'exemplaire ("Vendu"...)

module.exports = router;



================================================
File: modules/stocks/routes/famille.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/famille.controller");

// CRUD Routes
// router.post("/", controller.createFamille);
// router.get("/", controller.getFamilles);
// router.get("/:id", controller.getFamilleById);
// router.put("/:id", controller.updateFamille);
// router.delete("/:id", controller.deleteFamille);

/**
 * @swagger
 * /stocks/familles:
 *   post:
 *     summary: CrÃ©e une nouvelle famille
 *     tags: [Familles]
 */
router.post("/", controller.createFamille);

/**
 * @swagger
 * /stocks/familles:
 *   get:
 *     summary: RÃ©cupÃ¨re toutes les familles
 *     tags: [Familles]
 *     responses:
 *       200:
 *         description: Liste des familles
 *         content:
 *           application/json:
 *             example:
 *               - id_famille: 1
 *                 libelle_famille: "famille-001"
 *                 created_at: "2025-04-23T11:38:03.375Z"
 *                 updated_at: "2025-04-23T11:38:03.375Z"
 *               - id_famille: 2
 *                 libelle_famille: "famille-002"
 *                 created_at: "2025-04-23T11:38:07.292Z"
 *                 updated_at: "2025-04-23T11:38:07.292Z"
 *               - id_famille: 3
 *                 libelle_famille: "famille-003"
 *                 created_at: "2025-04-23T11:38:12.014Z"
 *                 updated_at: "2025-04-23T11:38:12.014Z"
 */

router.get("/", controller.getFamilles);

/**
 * @swagger
 * /stocks/familles/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une famille par ID
 *     tags: [Familles]
 */
router.get("/:id", controller.getFamilleById);

/**
 * @swagger
 * /stocks/familles/{id}:
 *   put:
 *     summary: Met Ã  jour une famille par ID
 *     tags: [Familles]
 */
router.put("/:id", controller.updateFamille);

/**
 * @swagger
 * /stocks/familles/{id}:
 *   delete:
 *     summary: Supprime une famille par ID
 *     tags: [Familles]
 */
router.delete("/:id", controller.deleteFamille);


module.exports = router;


================================================
File: modules/stocks/routes/livraison.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/livraison.controller");

// CRUD Routes
// router.post("/", controller.createLivraison);
// router.get("/", controller.getLivraisons);
// router.get("/:id", controller.getLivraisonById);
// router.put("/:id", controller.updateLivraison);
// router.delete("/:id", controller.deleteLivraison);
// router.get("/livraisons/:id/exemplaires", controller.getLivraisonExemplaire); //Voir les exemplaires ajoutÃ©s lors dâ€™une livraison


/**
 * @swagger
 * /stocks/livraisons:
 *   post:
 *     summary: CrÃ©e une nouvelle livraison
 *     tags: [Livraisons]
 */
router.post("/", controller.createLivraison);

/**
 * @swagger
 * /stocks/livraisons:
 *   get:
 *     summary: RÃ©cupÃ¨re toutes les livraisons
 *     tags: [Livraisons]
 *     responses:
 *       200:
 *         description: Liste des livraisons
 *         content:
 *           application/json:
 *             example:
 *               - id_livraison: 1
 *                 reference_livraison: null
 *                 frais_divers: "0.00"
 *                 periode_achat: "2025-04-04"
 *                 prix_achat: "150000.00"
 *                 prix_de_revient: "160000.00"
 *                 prix_de_vente: "200000.00"
 *                 id_partenaire: 1
 *                 created_at: "2025-04-23T11:13:17.657Z"
 *                 updated_at: "2025-04-24T14:45:33.350Z"
 *               - id_livraison: 2
 *                 reference_livraison: null
 *                 frais_divers: "1111.00"
 *                 periode_achat: "1111"
 *                 prix_achat: "1111.00"
 *                 prix_de_revient: "1111.00"
 *                 prix_de_vente: "1111.00"
 *                 id_partenaire: 2
 *                 created_at: "2025-04-23T11:13:26.528Z"
 *                 updated_at: "2025-05-02T09:58:33.795Z"
 */

router.get("/", controller.getLivraisons);

/**
 * @swagger
 * /stocks/livraisons/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une livraison par ID
 *     tags: [Livraisons]
 */
router.get("/:id", controller.getLivraisonById);

/**
 * @swagger
 * /stocks/livraisons/{id}:
 *   put:
 *     summary: Met Ã  jour une livraison par ID
 *     tags: [Livraisons]
 */
router.put("/:id", controller.updateLivraison);

/**
 * @swagger
 * /stocks/livraisons/{id}:
 *   delete:
 *     summary: Supprime une livraison par ID
 *     tags: [Livraisons]
 */
router.delete("/:id", controller.deleteLivraison);

/**
 * @swagger
 * /stocks/livraisons/{id}/exemplaires:
 *   get:
 *     summary: RÃ©cupÃ¨re les exemplaires ajoutÃ©s lors d'une livraison
 *     tags: [Livraisons]
 */
router.get("/livraisons/:id/exemplaires", controller.getLivraisonExemplaire);


module.exports = router;


================================================
File: modules/stocks/routes/marque.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/marque.controller");

// CRUD Routes
// router.post("/", controller.createMarque);
// router.get("/", controller.getMarques);
// router.get("/:id", controller.getMarqueById);
// router.put("/:id", controller.updateMarque);
// router.delete("/:id", controller.deleteMarque);

/**
 * @swagger
 * /stocks/marques:
 *   post:
 *     summary: CrÃ©e une nouvelle marque
 *     tags: [Marques]
 */
router.post("/", controller.createMarque);

/**
 * @swagger
 * /stocks/marques:
 *   get:
 *     summary: RÃ©cupÃ¨re toutes les marques
 *     tags: [Marques]
 *     responses:
 *       200:
 *         description: Liste des marques
 *         content:
 *           application/json:
 *             example:
 *               - id_marque: 3
 *                 libelle_marque: "marque-001"
 *                 created_at: "2025-04-23T10:54:23.358Z"
 *                 updated_at: "2025-04-23T10:54:23.358Z"
 *               - id_marque: 4
 *                 libelle_marque: "marque-002"
 *                 created_at: "2025-04-23T11:39:04.388Z"
 *                 updated_at: "2025-04-23T11:39:04.388Z"
 */

router.get("/", controller.getMarques);

/**
 * @swagger
 * /stocks/marques/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une marque par ID
 *     tags: [Marques]
 */
router.get("/:id", controller.getMarqueById);

/**
 * @swagger
 * /stocks/marques/{id}:
 *   put:
 *     summary: Met Ã  jour une marque par ID
 *     tags: [Marques]
 */
router.put("/:id", controller.updateMarque);

/**
 * @swagger
 * /stocks/marques/{id}:
 *   delete:
 *     summary: Supprime une marque par ID
 *     tags: [Marques]
 */
router.delete("/:id", controller.deleteMarque);


module.exports = router;



================================================
File: modules/stocks/routes/modele.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/modele.controller");

// CRUD Routes
// router.post("/", controller.createModele);
// router.get("/", controller.getModeles);
// router.get("/:id", controller.getModeleById);
// router.put("/:id", controller.updateModele);
// router.delete("/:id", controller.deleteModele);

/**
 * @swagger
 * /stocks/modeles:
 *   post:
 *     summary: CrÃ©e un nouveau modÃ¨le
 *     tags: [ModÃ¨les]
 */
router.post("/", controller.createModele);

/**
 * @swagger
 * /stocks/modeles:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les modÃ¨les
 *     tags: [ModÃ¨les]
 *     responses:
 *       200:
 *         description: Liste des modÃ¨les
 *         content:
 *           application/json:
 *             example:
 *               - id_modele: 1
 *                 libelle_modele: null
 *                 created_at: "2025-04-23T11:43:12.111Z"
 *                 updated_at: "2025-04-23T11:43:12.111Z"
 *               - id_modele: 2
 *                 libelle_modele: null
 *                 created_at: "2025-04-23T11:43:17.630Z"
 *                 updated_at: "2025-04-23T11:43:17.630Z"
 */

router.get("/", controller.getModeles);

/**
 * @swagger
 * /stocks/modeles/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un modÃ¨le par ID
 *     tags: [ModÃ¨les]
 */
router.get("/:id", controller.getModeleById);

/**
 * @swagger
 * /stocks/modeles/{id}:
 *   put:
 *     summary: Met Ã  jour un modÃ¨le par ID
 *     tags: [ModÃ¨les]
 */
router.put("/:id", controller.updateModele);

/**
 * @swagger
 * /stocks/modeles/{id}:
 *   delete:
 *     summary: Supprime un modÃ¨le par ID
 *     tags: [ModÃ¨les]
 */
router.delete("/:id", controller.deleteModele);

module.exports = router;



================================================
File: modules/stocks/routes/produit.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/produit.controller");

// CRUD Routes
// router.post("/", controller.createProduit);
// router.get("/", controller.getProduits);
// router.get("/:id", controller.getProduitById);
// router.get("/:idType", controller.getProduitsByTypes); // afficher tous les outils/Ã©quipements
// router.put("/:id", controller.updateProduit);
// router.delete("/:id", controller.deleteProduit);

/**
 * @swagger
 * /produits:
 *   post:
 *     summary: CrÃ©e un nouveau produit
 *     tags: [Produits]
 */
router.post("/", controller.createProduit);

/**
 * @swagger
 * /stocks/produits:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les produits
 *     tags: [Produits]
 *     responses:
 *       200:
 *         description: Liste des produits
 *         content:
 *           application/json:
 *             example:
 *               - id_produit: 5
 *                 code_produit: "produit-4"
 *                 desi_produit: "produit-4"
 *                 desc_produit: null
 *                 image_produit: "media\\images\\stock_moyensgeneraux\\produits\\tomate_1745603051631.jpeg"
 *                 qte_produit: 1
 *                 emplacement_produit: "salle 4"
 *                 caracteristiques_produit: null
 *                 prix_produit: null
 *                 id_categorie: 2
 *                 id_type_produit: 1
 *                 id_modele: 2
 *                 id_famille: 2
 *                 id_marque: 3
 *                 created_at: "2025-04-25T17:44:12.643Z"
 *                 updated_at: "2025-04-28T16:19:41.264Z"
 *                 image_url: "http://localhost:2000/media/images/stock_moyensgeneraux/produits/tomate_1745603051631.jpeg"
 *               - id_produit: 7
 *                 code_produit: "outils-1"
 *                 desi_produit: "outils-1"
 *                 desc_produit: "test"
 *                 image_produit: "media\\images\\stock_moyensgeneraux\\produits\\tomate_1745872525356.jpeg"
 *                 qte_produit: 1
 *                 emplacement_produit: null
 *                 caracteristiques_produit: null
 *                 prix_produit: null
 *                 id_categorie: null
 *                 id_type_produit: 5
 *                 id_modele: null
 *                 id_famille: null
 *                 id_marque: null
 *                 created_at: "2025-04-28T20:20:28.899Z"
 *                 updated_at: "2025-04-28T20:35:25.365Z"
 *                 image_url: "http://localhost:2000/media/images/stock_moyensgeneraux/produits/tomate_1745872525356.jpeg"
 */

router.get("/", controller.getProduits);

/**
 * @swagger
 * /stocks/produits/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un produit par ID
 *     tags: [Produits]
 */
router.get("/:id", controller.getProduitById);

/**
 * @swagger
 * /stocks/produits/type/{idType}:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les produits par type (outils/Ã©quipements)
 *     tags: [Produits]
 */
router.get("/type/:idType", controller.getProduitsByTypes);

/**
 * @swagger
 * /stocks/produits/{id}:
 *   put:
 *     summary: Met Ã  jour un produit par ID
 *     tags: [Produits]
 */
router.put("/:id", controller.updateProduit);

/**
 * @swagger
 * /stocks/produits/{id}:
 *   delete:
 *     summary: Supprime un produit par ID
 *     tags: [Produits]
 */
router.delete("/:id", controller.deleteProduit);


module.exports = router;



================================================
File: modules/stocks/routes/sortiesExemplaire.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/sortiesExemplaire.controller");


// router.post("/", controller.createSortie);
// router.get("/", controller.getSorties);
// router.get("/:id", controller.getSortieDetails);
// router.put("/:id", controller.updateSortie);
// router.delete("/:id", controller.deleteSortie);

/**
 * @swagger
 * /stocks/sorties-exemplaires:
 *   post:
 *     summary: CrÃ©e une nouvelle sortie d'exemplaire
 *     tags: [Sorties Exemplaire]
 */
router.post("/", controller.createSortie);

/**
 * @swagger
 * /stocks/sorties-exemplaires:
 *   get:
 *     summary: RÃ©cupÃ¨re toutes les sorties d'exemplaires
 *     tags: [Sorties Exemplaire]
 */
router.get("/", controller.getSorties);

/**
 * @swagger
 * /stocks/sorties-exemplaires/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re les dÃ©tails d'une sortie d'exemplaire par ID
 *     tags: [Sorties Exemplaire]
 */
router.get("/:id", controller.getSortieDetails);

/**
 * @swagger
 * /stocks/sorties-exemplaires/{id}:
 *   put:
 *     summary: Met Ã  jour une sortie d'exemplaire par ID
 *     tags: [Sorties Exemplaire]
 */
router.put("/:id", controller.updateSortie);

/**
 * @swagger
 * /stocks/sorties-exemplaires/{id}:
 *   delete:
 *     summary: Supprime une sortie d'exemplaire par ID
 *     tags: [Sorties Exemplaire]
 */
router.delete("/:id", controller.deleteSortie);


module.exports = router;


================================================
File: modules/stocks/routes/stocks.routes.js
================================================
ï»¿const express = require("express");
const router = express.Router();

// Import des sous-routes
const familleRoutes = require("./famille.routes");
const categorieRoutes = require("./categorie.route");
const marqueRoutes = require("./marque.routes");
const modeleRoutes = require("./modele.routes");
const produitRoutes = require("./produit.routes");
const exemplaireRoutes = require("./exemplaire.routes");
const livraisonRoutes = require("./livraison.routes");
const typesProduitRoutes = require("./typesProduit.routes");
const commandeRoutes = require("./commande.route");
const sortiesExemplairesRoutes = require("./sortiesExemplaire.route");
const achatRoutes = require("./achat.route");

// Montage des routes
// router.use("/familles", familleRoutes);
// router.use("/categories", categorieRoutes);
// router.use("/marques", marqueRoutes);
// router.use("/modeles", modeleRoutes);
// router.use("/produits", produitRoutes);
// router.use("/exemplaires", exemplaireRoutes);
// router.use("/livraisons", livraisonRoutes);
// router.use("/types-produits", typesProduitRoutes);
// router.use("/commandes", commandeRoutes);
// router.use("/sorties-exemplaires", sortiesExemplairesRoutes);
// router.use("/achats", achatRoutes);

// /**
//  * @swagger
//  * /stocks/familles:
//  *   description: Routes liÃ©es aux familles
//  *   get:
//  *     summary: AccÃ¨de aux familles de produits
//  *     tags: [Familles]
//  */
router.use("/familles", familleRoutes);

// /**
//  * @swagger
//  * /stocks/categories:
//  *   description: Routes liÃ©es aux catÃ©gories
//  *   get:
//  *     summary: AccÃ¨de aux catÃ©gories de produits
//  *     tags: [CatÃ©gories]
//  */
router.use("/categories", categorieRoutes);

// /**
//  * @swagger
//  * /stocks/marques:
//  *   description: Routes liÃ©es aux marques
//  *   get:
//  *     summary: AccÃ¨de aux marques de produits
//  *     tags: [Marques]
//  */
router.use("/marques", marqueRoutes);

// /**
//  * @swagger
//  * /stocks/modeles:
//  *   description: Routes liÃ©es aux modÃ¨les
//  *   get:
//  *     summary: AccÃ¨de aux modÃ¨les de produits
//  *     tags: [ModÃ¨les]
//  */
router.use("/modeles", modeleRoutes);

// /**
//  * @swagger
//  * /stocks/produits:
//  *   description: Routes liÃ©es aux produits
//  *   get:
//  *     summary: AccÃ¨de aux produits
//  *     tags: [Produits]
//  */
router.use("/produits", produitRoutes);

// /**
//  * @swagger
//  * /stocks/exemplaires:
//  *   description: Routes liÃ©es aux exemplaires de produits
//  *   get:
//  *     summary: AccÃ¨de aux exemplaires de produits
//  *     tags: [Exemplaires]
//  */
router.use("/exemplaires", exemplaireRoutes);

// /**
//  * @swagger
//  * /stocks/livraisons:
//  *   description: Routes liÃ©es aux livraisons
//  *   get:
//  *     summary: AccÃ¨de aux livraisons
//  *     tags: [Livraisons]
//  */
router.use("/livraisons", livraisonRoutes);

// /**
//  * @swagger
//  * /stocks/types-produits:
//  *   description: Routes liÃ©es aux types de produits
//  *   get:
//  *     summary: AccÃ¨de aux types de produits
//  *     tags: [Types de Produits]
//  */
router.use("/types-produits", typesProduitRoutes);

// /**
//  * @swagger
//  * /stocks/commandes:
//  *   description: Routes liÃ©es aux commandes
//  *   get:
//  *     summary: AccÃ¨de aux commandes
//  *     tags: [Commandes]
//  */
router.use("/commandes", commandeRoutes);

// /**
//  * @swagger
//  * /stocks/sorties-exemplaires:
//  *   description: Routes liÃ©es aux sorties d'exemplaires
//  *   get:
//  *     summary: AccÃ¨de aux sorties d'exemplaires
//  *     tags: [Sorties Exemplaires]
//  */
router.use("/sorties-exemplaires", sortiesExemplairesRoutes);

// /**
//  * @swagger
//  * /stocks/achats:
//  *   description: Routes liÃ©es aux achats
//  *   get:
//  *     summary: AccÃ¨de aux achats
//  *     tags: [Achats]
//  */
router.use("/achats", achatRoutes);

module.exports = router;



================================================
File: modules/stocks/routes/typesProduit.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/typesProduit.controller");

// CRUD Routes
// router.post("/", controller.createTypeProduit);
// router.get("/", controller.getTypeProduits);
// router.get("/:id", controller.getTypeProduitById);
// router.put("/:id", controller.updateTypeProduit);
// router.delete("/:id", controller.deleteTypeProduit);

/**
 * @swagger
 * /stocks/type-produits:
 *   post:
 *     summary: CrÃ©e un nouveau type de produit
 *     tags: [Types de Produits]
 */
router.post("/", controller.createTypeProduit);

/**
 * @swagger
 * /stocks/type-produits:
 *   get:
 *     summary: RÃ©cupÃ¨re tous les types de produits
 *     tags: [Types de Produits]
 */
router.get("/", controller.getTypeProduits);

/**
 * @swagger
 * /stocks/type-produits/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un type de produit par ID
 *     tags: [Types de Produits]
 */
router.get("/:id", controller.getTypeProduitById);

/**
 * @swagger
 * /stocks/type-produits/{id}:
 *   put:
 *     summary: Met Ã  jour un type de produit par ID
 *     tags: [Types de Produits]
 */
router.put("/:id", controller.updateTypeProduit);

/**
 * @swagger
 * /stocks/type-produits/{id}:
 *   delete:
 *     summary: Supprime un type de produit par ID
 *     tags: [Types de Produits]
 */
router.delete("/:id", controller.deleteTypeProduit);

module.exports = router;



================================================
File: modules/stocks/services/achat.service.js
================================================
const { eq, and } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
const { livraisons, exemplaires, produits } = require("../../../core/database/models");

// Met Ã  jour uniquement les champs liÃ©s Ã  l'achat dans la table livraisons
// Et met Ã  jour le prix_produit si prix_de_vente est fourni
const updateAchatFields = async (id, data) => {
  const allowedFields = [
    "prix_achat",
    "frais_divers",
    "prix_de_revient",
    "prix_de_vente",
    "periode_achat",
  ];

  // On ne conserve que les champs autorisÃ©s Ã  Ãªtre modifiÃ©s
  const cleanData = Object.fromEntries(
    Object.entries(data).filter(([key]) => allowedFields.includes(key))
  );

  await db.transaction(async (tx) => {
    // 1. Mise Ã  jour des champs dans la table livraisons
    const [result] = await tx
      .update(livraisons)
      .set({
        ...cleanData,
        updated_at: new Date(),
      })
      .where(eq(livraisons.id_livraison, id))
      .returning();

    // 2. Si prix_de_vente est fourni, on met Ã  jour le prix_produit
    if (cleanData.prix_de_vente !== undefined) {
      // RÃ©cupÃ©rer les exemplaires de la livraison
      const exemplairesLivraison = await tx
        .select({ id_produit: exemplaires.id_produit })
        .from(exemplaires)
        .where(eq(exemplaires.id_livraison, id));

      // Mettre Ã  jour le prix pour chaque produit unique
      const produitsIds = [...new Set(exemplairesLivraison.map(e => e.id_produit))];
      
      for (const id_produit of produitsIds) {
        await tx
          .update(produits)
          .set({
            prix_produit: cleanData.prix_de_vente,
            updated_at: new Date(),
          })
          .where(eq(produits.id_produit, id_produit));
      }
    }

    return result;
  });
};

// RÃ©cupÃ¨re les informations d'achat d'une livraison Ã  partir de son ID
const getAchatById = async (id) => {
  const [result] = await db
    .select()
    .from(livraisons)
    .where(eq(livraisons.id_livraison, id));

  if (!result) return null;

  return {
    id: result.id_livraison,
    prix_achat: result.prix_achat,
    frais_divers: result.frais_divers,
    prix_de_revient: result.prix_de_revient,
    prix_de_vente: result.prix_de_vente,
    periode_achat: result.periode_achat,
  };
};

// RÃ©cupÃ¨re tous les enregistrements d'achat avec les champs d'achat uniquement
const getAllAchats = async () => {
  const rows = await db.select().from(livraisons);
  return rows.map((row) => ({
    id: row.id_livraison,
    prix_achat: row.prix_achat,
    frais_divers: row.frais_divers,
    prix_de_revient: row.prix_de_revient,
    prix_de_vente: row.prix_de_vente,
    periode_achat: row.periode_achat,
  }));
};

// RÃ©cupÃ¨re les infos d'achat Ã  partir d'un exemplaire spÃ©cifique
const getAchatByExemplaireId = async (id_exemplaire) => {
  // Jointure entre exemplaire et livraison
  const [result] = await db
    .select({
      id_livraison: livraisons.id_livraison,
      prix_achat: livraisons.prix_achat,
      frais_divers: livraisons.frais_divers,
      prix_de_revient: livraisons.prix_de_revient,
      prix_de_vente: livraisons.prix_de_vente,
      periode_achat: livraisons.periode_achat,
    })
    .from(exemplaires)
    .leftJoin(
      livraisons,
      eq(exemplaires.id_livraison, livraisons.id_livraison)
    )
    .where(eq(exemplaires.id_exemplaire, id_exemplaire));

  return result || null;
};

module.exports = {
  updateAchatFields,
  getAchatById,
  getAllAchats,
  getAchatByExemplaireId,
};



================================================
File: modules/stocks/services/categorie.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { categories } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createCategorie = async (data) => {
  const [result] = await db.insert(categories).values(data).returning();
  return result;
};

const getCategories = async () => {
  return await db.select().from(categories);
};

const getCategorieById = async (id) => {
  const [result] = await db
    .select()
    .from(categories)
    .where(eq(categories.id_categorie, id));
  return result;
};

const updateCategorie = async (id, data) => {
  const [result] = await db
    .update(categories)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(categories.id_categorie, id))
    .returning();
  return result;
};

const deleteCategorie = async (id) => {
  const [result] = await db
    .delete(categories)
    .where(eq(categories.id_categorie, id))
    .returning();
  return result;
};

module.exports = {
  createCategorie,
  getCategories,
  getCategorieById,
  updateCategorie,
  deleteCategorie,
};



================================================
File: modules/stocks/services/commande.service.js
================================================
const { and, eq, inArray, sql } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
const {
  exemplaires,
  produits,
  commandes,
  partenaires,
  partenaire_commandes,
  commande_produits,
  sortie_exemplaires,
} = require("../../../core/database/models");

const { etatExemplaire } = require("./exemplaire.service");

const { typeSortie } = require("./sortieExemplaire.service");

/**
 * 
const commande = await createCommande({
  produitsQuantites: { 1: 2, 3: 1 }, // 2x produit ID 1, 1x produit ID 3
  partenaireId: 5,
  lieuLivraison: "Magasin principal",
  dateLivraison: "2025-05-10",
  modePaiement: "carte"
});
 */

async function createCommande({
  produitsQuantites, // {id_produit: quantite}
  partenaireId,
  lieuLivraison,
  dateCommande = new Date(),
  dateLivraison,
  modePaiement,
}) {
  return await db.transaction(async (tx) => {
    // 1. Validation des entrées
    if (!produitsQuantites || !Object.keys(produitsQuantites).length) {
      throw new Error("Aucun produit spécifié");
    }
    if (!partenaireId) throw new Error("Partenaire non spécifié");

    // 2. Vérification des stocks et récupération des exemplaires disponibles
    const produitsACommander = Object.entries(produitsQuantites);
    const exemplairesReserves = [];

    for (const [produitId, quantite] of produitsACommander) {
      // Vérifier la quantité disponible
      const [produit] = await tx
        .select()
        .from(produits)
        .where(eq(produits.id_produit, Number(produitId)));

      if (!produit || produit.qte_produit < quantite) {
        throw new Error(`Stock insuffisant pour le produit ${produitId}`);
      }

      // Récupérer des exemplaires disponibles
      const exemplairesDispos = await tx
        .select()
        .from(exemplaires)
        .where(
          and(
            eq(exemplaires.id_produit, Number(produitId)),
            eq(exemplaires.etat_exemplaire, "Disponible")
          )
        )
        .limit(quantite);

      if (exemplairesDispos.length < quantite) {
        throw new Error(
          `Pas assez d'exemplaires disponibles pour le produit ${produitId}`
        );
      }

      exemplairesReserves.push(...exemplairesDispos);
    }

    // 3. Création de la commande
    const [newCommande] = await tx
      .insert(commandes)
      .values({
        date_de_commande: new Date(dateCommande),
        etat_commande: "en cours",
        date_livraison: new Date(dateLivraison),
        lieu_de_livraison: lieuLivraison,
        mode_de_paiement: modePaiement,
        created_at: new Date(),
        updated_at: new Date(),
      })
      .returning();

    // 4. Liaison commande-partenaire (étape cruciale ajoutée)
    await tx.insert(partenaire_commandes).values({
      id_partenaire: partenaireId,
      id_commande: newCommande.id_commande,
      created_at: new Date(),
      updated_at: new Date(),
    });

    // 5. Liaison commande-produits
    for (const [produitId, quantite] of produitsACommander) {
      await tx.insert(commande_produits).values({
        id_commande: newCommande.id_commande,
        id_produit: Number(produitId),
        quantite: quantite,
        created_at: new Date(),
        updated_at: new Date(),
      });
    }

    // 6. Mise à jour des exemplaires (marqués comme vendus)
    const exemplairesIds = exemplairesReserves.map((e) => e.id_exemplaire);
    await tx
      .update(exemplaires)
      .set({
        etat_exemplaire: etatExemplaire[5], //Reservé
        updated_at: new Date(),
      })
      .where(inArray(exemplaires.id_exemplaire, exemplairesIds));

    // 7. Mise à jour des stocks produits
    for (const [produitId, quantite] of produitsACommander) {
      await tx
        .update(produits)
        .set({
          qte_produit: sql`${produits.qte_produit} - ${quantite}`,
          updated_at: new Date(),
        })
        .where(eq(produits.id_produit, Number(produitId)));
    }

    // 8. Retour de la commande complète
    const completeCommande = {
      ...newCommande,
      produits: produitsACommander.map(([id, qte]) => ({
        id_produit: Number(id),
        quantite: qte,
      })),
      exemplaires: exemplairesReserves,
      partenaire: { id_partenaire: partenaireId },
    };

    return completeCommande;
  });
}

// 🔍 Lire une commande avec détails
async function getCommandeById(id) {
  try {
    const [row] = await db
      .select({
        commande: commandes,
        partenaire: partenaires,
      })
      .from(commandes)
      .leftJoin(
        partenaire_commandes,
        eq(commandes.id_commande, partenaire_commandes.id_commande)
      )
      .leftJoin(
        partenaires,
        eq(partenaire_commandes.id_partenaire, partenaires.id_partenaire)
      )
      .where(eq(commandes.id_commande, id));

    if (!row) throw new Error("Commande introuvable");

    const exemplairesAssocies = await db
      .select()
      .from(exemplaires)
      .where(eq(exemplaires.id_commande, id));

    return {
      ...row.commande,
      partenaire: row.partenaire || null,
      exemplaires: exemplairesAssocies,
    };
  } catch (error) {
    console.error("Erreur dans getCommandeById:", error);
    throw error;
  }
}


// 📜 Liste paginée ou filtrée des commandes
async function getAllCommandes({ limit = 50, offset = 0, etat = null } = {}) {
  let query = db
    .select()
    .from(commandes)
    .leftJoin(
      partenaire_commandes,
      eq(commandes.id_commande, partenaire_commandes.id_commande)
    )
    .leftJoin(
      partenaires,
      eq(partenaire_commandes.id_partenaire, partenaires.id_partenaire)
    );

  if (etat) {
    query = query.where(eq(commandes.etat_commande, etat));
  }

  return await query.limit(limit).offset(offset);
}

// 📝 Mise à jour d'une commande
async function updateCommande(idCommande, updateData) {
  const allowedFields = [
    "date_livraison",
    "lieu_de_livraison",
    "etat_commande",
    "mode_de_paiement",
  ];

  const updatePayload = Object.fromEntries(
    Object.entries(updateData).filter(([key]) => allowedFields.includes(key))
  );

  if (!Object.keys(updatePayload).length) {
    throw new Error("Aucune donnée valide à mettre à jour");
  }

  updatePayload.updated_at = new Date();

  const [result] = await db
    .update(commandes)
    .set(updatePayload)
    .where(eq(commandes.id_commande, idCommande))
    .returning();

  if (!result) throw new Error("Commande non trouvée");

  return getCommandeById(idCommande);
}

// ❌ Suppression d'une commande complète
async function deleteCommande(idCommande) {
  // 1. Récupération des exemplaires liés à cette commande
  const exemplairesAssocies = await db
    .select()
    .from(exemplaires)
    .where(eq(exemplaires.id_commande, idCommande));

  // 2. Suppression des liaisons avec les partenaires et des sorties
  await Promise.all([
    db
      .delete(partenaire_commandes)
      .where(eq(partenaire_commandes.id_commande, idCommande)),

    db.delete(sortie_exemplaires).where(
      and(
        eq(sortie_exemplaires.reference_id, idCommande),
        eq(sortie_exemplaires.type_sortie, typeSortie[0]) // "vente directe"
      )
    ),
  ]);

  // 3. Réinitialisation des exemplaires et mise à jour des stocks produits
  for (const ex of exemplairesAssocies) {
    await Promise.all([
      db
        .update(exemplaires)
        .set({
          id_commande: null,
          etat_exemplaire: etatExemplaire[1], //"Disponible"
          updated_at: new Date(),
        })
        .where(eq(exemplaires.id_exemplaire, ex.id_exemplaire)),

      db
        .update(produits)
        .set({
          qte_produit: sql`${produits.qte_produit} + 1`,
          updated_at: new Date(),
        })
        .where(eq(produits.id_produit, ex.id_produit)),
    ]);
  }

  // 4. Suppression de la commande elle-même
  const result = await db
    .delete(commandes)
    .where(eq(commandes.id_commande, idCommande));

  if (result.rowCount === 0) throw new Error("Commande introuvable");

  return { success: true };
}

module.exports = {
  createCommande,
  getCommandeById,
  getAllCommandes,
  updateCommande,
  deleteCommande,
};



================================================
File: modules/stocks/services/exemplaire.service.js
================================================
const { eq, sql, and, inArray, isNull, count } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper");
const { exemplaires, produits } = require("../../../core/database/models");

/**
 *
 * vendu : exemplaire vendu
 * disponible : exemplaire disponible
 * in Use     : exemplaire (outils) en cours d'utilisation (par un employÃ©)
 */
const etatExemplaire = [
  "Vendu",
  "Disponible",
  "Utilisation",
  "En maintenance",
  "Endommage",
  "Reserve", //fait partie d'une commande,mais pas encore sortie(pas enregistrÃ© dans la table sortie exemplaire)
]; //liste des etats de l'exemplaire

/**
 * Services pour le modÃ¨le `exemplaires` (MVC)
 *
 * Ce fichier contient toutes les opÃ©rations CRUD et les services
 * nÃ©cessaires pour gÃ©rer les exemplaires et les commandes liÃ©es.
 */

/**
 * CrÃ©er un nouvel exemplaire et incrÃ©menter la quantitÃ© du produit associÃ©.
 */
async function createExemplaire(data) {
  const { id_produit } = data;
  const [newExemplaire] = await db.insert(exemplaires).values(data).returning();

  // IncrÃ©menter la quantitÃ© du produit liÃ©
  await db
    .update(produits)
    .set({
      qte_produit: sql`${produits.qte_produit} + 1`,
      updated_at: sql`NOW()`,
    })
    .where(eq(produits.id_produit, id_produit));

  return newExemplaire;
}

async function getExemplaires() {
  return db.select().from(exemplaires);
}

async function getExemplaireById(id) {
  const [ex] = await db
    .select()
    .from(exemplaires)
    .where(eq(exemplaires.id_exemplaire, id));
  return ex;
}

//rechercher un exemplaire Ã  partir d'un numÃ©ro de series
async function getExemplaireByNumSerie(num_serie) {
  const [ex] = await db
    .select()
    .from(exemplaires)
    .where(eq(exemplaires.num_serie, num_serie));
  return ex;
}

async function updateExemplaire(id, data) {
  return await db.transaction(async (tx) => {
    // 1. VÃ©rification de l'existence de l'exemplaire
    const [current] = await tx
      .select()
      .from(exemplaires)
      .where(eq(exemplaires.id_exemplaire, id));

    if (!current) {
      throw new Error("Exemplaire non trouvÃ©");
    }

    // 2. VÃ©rification du changement de produit
    const produitChange =
      data.id_produit && data.id_produit !== current.id_produit;

    if (produitChange) {
      // 3. Validation du nouveau produit
      const [newProduct] = await tx
        .select()
        .from(produits)
        .where(eq(produits.id_produit, data.id_produit));

      if (!newProduct) {
        throw new Error("Nouveau produit non trouvÃ©");
      }

      // 4. Ajustement des quantitÃ©s (en une seule requÃªte pour chaque opÃ©ration)
      // DÃ©crÃ©mentation ancien produit
      await tx
        .update(produits)
        .set({
          qte_produit: sql`${produits.qte_produit} - 1`,
          updated_at: sql`NOW()`,
        })
        .where(eq(produits.id_produit, current.id_produit));

      // IncrÃ©mentation nouveau produit
      await tx
        .update(produits)
        .set({
          qte_produit: sql`${produits.qte_produit} + 1`,
          updated_at: sql`NOW()`,
        })
        .where(eq(produits.id_produit, data.id_produit));
    }

    // 5. Mise Ã  jour de l'exemplaire
    const [updated] = await tx
      .update(exemplaires)
      .set({
        ...data,
        updated_at: new Date(),
      })
      .where(eq(exemplaires.id_exemplaire, id))
      .returning();

    return updated;
  });
}

async function deleteExemplaire(id) {
  return await db.transaction(async (tx) => {
    // 1. VÃ©rification de l'existence de l'exemplaire
    const [toDelete] = await tx
      .select()
      .from(exemplaires)
      .where(eq(exemplaires.id_exemplaire, id));

    if (!toDelete) {
      throw new Error("Exemplaire non trouvÃ©");
    }

    // 2. VÃ©rification que la quantitÃ© ne deviendra pas nÃ©gative
    const [produit] = await tx
      .select({ qte_produit: produits.qte_produit })
      .from(produits)
      .where(eq(produits.id_produit, toDelete.id_produit));

    if (produit.qte_produit <= 0) {
      throw new Error("La quantitÃ© du produit est dÃ©jÃ  Ã  zÃ©ro");
    }

    // 3. DÃ©crÃ©mentation du stock produit
    const updateResult = await tx
      .update(produits)
      .set({
        qte_produit: sql`GREATEST(${produits.qte_produit} - 1, 0)`, // Ã‰vite les valeurs nÃ©gatives
        updated_at: sql`NOW()`,
      })
      .where(eq(produits.id_produit, toDelete.id_produit));

    if (updateResult.rowCount === 0) {
      throw new Error("Ã‰chec de la mise Ã  jour du produit");
    }

    // 4. Suppression de l'exemplaire
    const [deleted] = await tx
      .delete(exemplaires)
      .where(eq(exemplaires.id_exemplaire, id))
      .returning();

    return deleted;
  });
}

/** ---Autres requetes --- */

async function getExemplairesByProduit(id) {
  return db.select().from(exemplaires).where(eq(exemplaires.id_produit, id));
}

//filtrer les exemplaires selon leur etat (disponible,vendu...)
// id : id du produit de l'exemplaire ; etat : etat de l'exemplaire ("Vendu"...)
async function filterExemplairesByEtat(id, etat) {
  const exemplairesFiltres = await db
    .select()
    .from(exemplaires)
    .where(
      and(eq(exemplaires.id_produit, id), eq(exemplaires.etat_exemplaire, etat))
    );

  const total = exemplairesFiltres.length;

  return {
    total,
    data: exemplairesFiltres,
  };
}

// // // VÃ©rifie si un exemplaire spÃ©cifique est en cours d'utilisation
// // async function isExemplaireInUse(exId) {
// //   const [result] = await db
// //     .select()
// //     .from(usage_exemplaires)
// //     .where(
// //       and(
// //         eq(usage_exemplaires.id_exemplaire, exId),
// //         isNull(usage_exemplaires.date_retour_usage)
// //       )
// //     );

// //   return !!result; //retourne un boolÃ©en
// // }

// // RÃ©cupÃ¨re tous les exemplaires actuellement en cours d'utilisation
// async function isExemplairesInUse() {
//   return filterExemplairesByEtat(etatExemplaire[2]);
// }

module.exports = {
  createExemplaire,
  getExemplaires,
  getExemplaireById,
  getExemplaireByNumSerie,
  updateExemplaire,
  deleteExemplaire,
  getExemplairesByProduit,
  // isExemplaireInUse,
  // isExemplairesInUse,

  filterExemplairesByEtat,

  //variable
  etatExemplaire,
};

// /**
//  * RÃ©cupÃ¨re tous les exemplaires utilisÃ©s dans le cadre dâ€™un projet donnÃ©.

//  */
// async function getExemplairesByProjet(projectId) {
//   return db
//     .select()
//     .from(exemplaires)
//     .innerJoin(
//       usage_exemplaires,
//       eq(usage_exemplaires.id_exemplaire, exemplaires.id_exemplaire)
//     )
//     .where(eq(exemplaires.id_projet, projectId));
// }



================================================
File: modules/stocks/services/famille.service.js
================================================
// const { eq } = require("drizzle-orm");
// const dbConfig = require("../../../core/database/config");
// const { familles } = require("../../../core/database/models");

// // Solution robuste pour rÃ©cupÃ©rer db correctement
// const db = dbConfig.db || dbConfig.default;

// // Debug crucial
// console.log("MÃ©thodes Drizzle disponibles:", {
//   insert: typeof db.insert,
//   select: typeof db.select,
//   update: typeof db.update,
//   delete: typeof db.delete
// });

const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { familles } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createFamille = async (data) => {
  const [result] = await db.insert(familles).values(data).returning();
  return result;
};

const getFamilles = async () => {
  return await db.select().from(familles);
};

const getFamilleById = async (id) => {
  const [result] = await db.select().from(familles).where(eq(familles.id_famille, id));
  return result;
};

const updateFamille = async (id, data) => {
  const [result] = await db
    .update(familles)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(familles.id_famille, id))
    .returning();
  return result;
};

const deleteFamille = async (id) => {
  const [result] = await db
    .delete(familles)
    .where(eq(familles.id_famille, id))
    .returning();
  return result;
};

module.exports = {
  createFamille,
  getFamilles,
  getFamilleById,
  updateFamille,
  deleteFamille,
};



================================================
File: modules/stocks/services/livraison.service.js
================================================
// const { eq } = require("drizzle-orm");
// const dbConfig = require("../../../core/database/config");
// const { livraisons } = require("../../../core/database/models");

// // Solution robuste pour rÃ©cupÃ©rer db correctement
// const db = dbConfig.db || dbConfig.default;

// // Debug crucial
// console.log("MÃ©thodes Drizzle disponibles:", {
//   insert: typeof db.insert,
//   select: typeof db.select,
//   update: typeof db.update,
//   delete: typeof db.delete
// });

const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { livraisons, exemplaires } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createLivraison = async (data) => {
  const [result] = await db.insert(livraisons).values(data).returning();
  return result;
};

const getLivraisons = async () => {
  return await db.select().from(livraisons);
};

const getLivraisonById = async (id) => {
  const [result] = await db
    .select()
    .from(livraisons)
    .where(eq(livraisons.id_livraison, id));
  return result;
};

const updateLivraison = async (id, data) => {
  const [result] = await db
    .update(livraisons)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(livraisons.id_livraison, id))
    .returning();
  return result;
};

const deleteLivraison = async (id) => {
  const [result] = await db
    .delete(livraisons)
    .where(eq(livraisons.id_livraison, id))
    .returning();
  return result;
};

// [GET] /livraisons â†’ Liste des livraisons
// [POST] /livraisons â†’ Ajouter une livraisons (avec des exemplaires entrants)

// Voir les exemplaires ajoutÃ©s lors dâ€™une livraisons
const getLivraisonExemplaire = async (id) => {
  const [result] = await db
    .select(exemplaires)
    .where(eq(exemplaires.id_livraison, id));

  return result;
};

module.exports = {
  createLivraison,
  getLivraisons,
  getLivraisonById,
  updateLivraison,
  deleteLivraison,
  getLivraisonExemplaire,
};



================================================
File: modules/stocks/services/marque.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { marques } = require("../../../core/database/models");

const createMarque = async (data) => {
  const [result] = await db.insert(marques).values(data).returning();
  return result;
};

const getMarques = async () => {
  return await db.select().from(marques);
};

const getMarqueById = async (id) => {
  const [result] = await db
    .select()
    .from(marques)
    .where(eq(marques.id_marque, id));
  return result;
};

const updateMarque = async (id, data) => {
  const [result] = await db
    .update(marques)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(marques.id_marque, id))
    .returning();
  return result;
};

const deleteMarque = async (id) => {
  const [result] = await db
    .delete(marques)
    .where(eq(marques.id_marque, id))
    .returning();
  return result;
};

module.exports = {
  createMarque,
  getMarques,
  getMarqueById,
  updateMarque,
  deleteMarque,
};



================================================
File: modules/stocks/services/modele.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { modeles } = require("../../../core/database/models");

const createModele = async (data) => {
  const [result] = await db.insert(modeles).values(data).returning();
  return result;
};

const getModeles = async () => {
  return await db.select().from(modeles);
};

const getModeleById = async (id) => {
  const [result] = await db
    .select()
    .from(modeles)
    .where(eq(modeles.id_modele, id));
  return result;
};

const updateModele = async (id, data) => {
  const [result] = await db
    .update(modeles)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(modeles.id_modele, id))
    .returning();
  return result;
};

const deleteModele = async (id) => {
  const [result] = await db
    .delete(modeles)
    .where(eq(modeles.id_modele, id))
    .returning();
  return result;
};

module.exports = {
  createModele,
  getModeles,
  getModeleById,
  updateModele,
  deleteModele,
};



================================================
File: modules/stocks/services/produit.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const {
  produits,
} = require("../../../core/database/models");

const createProduit = async (data) => {
  const [result] = await db.insert(produits).values(data).returning();
  return result;
};

const getProduits = async () => {
  return await db.select().from(produits); 
};

// afficher tous les outils/Ã©quipements
const getProduitsByTypes = async (idType) => {
  return await db.select().from(produits).where(eq(produits.id_type_produit,idType)); 
};

const getProduitById = async (id) => {
  const [result] = await db
    .select()
    .from(produits)
    .where(eq(produits.id_produit, id));
  return result;
};

const updateProduit = async (id, data) => {
  const [result] = await db
    .update(produits)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(produits.id_produit, id))
    .returning();
  return result;
};

const deleteProduit = async (id) => {
  const [result] = await db
    .delete(produits)
    .where(eq(produits.id_produit, id))
    .returning();
  return result;
};


module.exports = {
  createProduit,
  getProduits,
  getProduitById,
  updateProduit,
  deleteProduit,
  getProduitsByTypes
};



================================================
File: modules/stocks/services/sortieExemplaire.service.js
================================================
const { and, eq, gte, lte, sql } = require("drizzle-orm");
const { db } = require("../../../core/database/config");
const {
  exemplaires,
  sortie_exemplaires,
  commandes,
  projets,
} = require("../../../core/database/models");

const typeSortie = ["vente directe", "vente en ligne", "projet"];

const etatExemplaire=require("./exemplaire.service")

// CrÃ©ation d'une sortie (et marquage de l'exemplaire comme "Vendu")
async function createSortie({
  type_sortie,
  reference_id,
  id_exemplaire,
  date_sortie = new Date(),
}) {
  return await db.transaction(async (tx) => {
    const [newSortie] = await tx
      .insert(sortie_exemplaires)
      .values({
        type_sortie,
        reference_id,
        id_exemplaire,
        date_sortie: new Date(date_sortie),
        created_at: new Date(),
        updated_at: new Date(),
      })
      .returning();

    await tx
      .update(exemplaires)
      .set({
        etat_exemplaire: etatExemplaire[0], //"Vendu"
        updated_at: new Date(),
      })
      .where(eq(exemplaires.id_exemplaire, id_exemplaire));

    return newSortie;
  });
}

// Lecture des sorties avec filtres optionnels et pagination
async function getSorties(filters = {}, { limit, offset } = {}) {
  const baseQuery = db
    .select()
    .from(sortie_exemplaires)
    .where(
      and(
        filters.type_sortie
          ? eq(sortie_exemplaires.type_sortie, filters.type_sortie)
          : undefined,
        filters.reference_id
          ? eq(sortie_exemplaires.reference_id, filters.reference_id)
          : undefined,
        filters.id_exemplaire
          ? eq(sortie_exemplaires.id_exemplaire, filters.id_exemplaire)
          : undefined,
        filters.start_date && filters.end_date
          ? and(
              gte(sortie_exemplaires.date_sortie, new Date(filters.start_date)),
              lte(sortie_exemplaires.date_sortie, new Date(filters.end_date))
            )
          : undefined
      )
    );

  const totalResult = await db
    .select({ count: sql`count(*)` })
    .from(sortie_exemplaires)
    .where(
      and(
        filters.type_sortie
          ? eq(sortie_exemplaires.type_sortie, filters.type_sortie)
          : undefined,
        filters.reference_id
          ? eq(sortie_exemplaires.reference_id, filters.reference_id)
          : undefined,
        filters.id_exemplaire
          ? eq(sortie_exemplaires.id_exemplaire, filters.id_exemplaire)
          : undefined,
        filters.start_date && filters.end_date
          ? and(
              gte(sortie_exemplaires.date_sortie, new Date(filters.start_date)),
              lte(sortie_exemplaires.date_sortie, new Date(filters.end_date))
            )
          : undefined
      )
    );

  const total = parseInt(totalResult[0].count);

  let query = baseQuery;
  if (limit !== undefined) {
    query = query.limit(limit);
  }
  if (offset !== undefined) {
    query = query.offset(offset);
  }

  const sorties = await query;

  return {
    sorties,
    total,
  };
}

// Mise Ã  jour partielle d'une sortie (et gestion de l'Ã©tat d'exemplaire si changÃ©)
async function updateSortie(id_sortie_exemplaire, updateData) {
  return await db.transaction(async (tx) => {
    const [oldSortie] = await tx
      .select()
      .from(sortie_exemplaires)
      .where(eq(sortie_exemplaires.id_sortie_exemplaire, id_sortie_exemplaire));

    if (!oldSortie) throw new Error("Sortie non trouvÃ©e");

    const [updated] = await tx
      .update(sortie_exemplaires)
      .set({
        ...updateData,
        updated_at: new Date(),
      })
      .where(eq(sortie_exemplaires.id_sortie_exemplaire, id_sortie_exemplaire))
      .returning();

    if (
      updateData.id_exemplaire &&
      updateData.id_exemplaire !== oldSortie.id_exemplaire
    ) {
      await Promise.all([
        tx
          .update(exemplaires)
          .set({ etat_exemplaire: etatExemplaire[5], updated_at: new Date() }) //"Reserve"
          .where(eq(exemplaires.id_exemplaire, oldSortie.id_exemplaire)),

        tx
          .update(exemplaires)
          .set({ etat_exemplaire: etatExemplaire[0], updated_at: new Date() }) //"Vendu"
          .where(eq(exemplaires.id_exemplaire, updateData.id_exemplaire)),
      ]);
    }

    return updated;
  });
}

// Suppression d'une sortie (et rÃ©tablissement de l'exemplaire Ã  "Disponible")
async function deleteSortie(id_sortie_exemplaire) {
  return await db.transaction(async (tx) => {
    const [sortie] = await tx
      .select()
      .from(sortie_exemplaires)
      .where(eq(sortie_exemplaires.id_sortie_exemplaire, id_sortie_exemplaire));

    if (!sortie) throw new Error("Sortie non trouvÃ©e");

    const [deleted] = await tx
      .delete(sortie_exemplaires)
      .where(eq(sortie_exemplaires.id_sortie_exemplaire, id_sortie_exemplaire))
      .returning();

    await tx
      .update(exemplaires)
      .set({ etat_exemplaire: etatExemplaire[1], updated_at: new Date() }) //"Disponible"
      .where(eq(exemplaires.id_exemplaire, sortie.id_exemplaire));

    return deleted;
  });
}

// RÃ©cupÃ©ration dÃ©taillÃ©e avec jointure exemplaire
async function getSortieDetails(id_sortie_exemplaire) {
  const [sortie] = await db
    .select({ sortie: sortie_exemplaires, exemplaire: exemplaires })
    .from(sortie_exemplaires)
    .leftJoin(
      exemplaires,
      eq(sortie_exemplaires.id_exemplaire, exemplaires.id_exemplaire)
    )
    .where(eq(sortie_exemplaires.id_sortie_exemplaire, id_sortie_exemplaire));

  if (!sortie) return null;

  let details;
  switch (sortie.sortie.type_sortie) {
    case typeSortie[0]: //vente directe
    case typeSortie[1]: //vente en ligne
      details = await db.query.commandes.findFirst({
        where: eq(commandes.id_commande, sortie.sortie.reference_id),
      });
      break;
    case typeSortie[2]: //projet
      details = await db.query.projets.findFirst({
        where: eq(projets.id_projet, sortie.sortie.reference_id),
      });
      break;
    default:
      details = { message: "Type de sortie non gÃ©rÃ©" };
  }

  return {
    ...sortie,
    details,
  };
}

module.exports = {
  createSortie,
  getSorties,
  updateSortie,
  deleteSortie,
  getSortieDetails,

  typeSortie,
};



================================================
File: modules/stocks/services/stocks.service.js
================================================
// const { stocks } = require('../tests/stocks.mock');

// module.exports = {
//   getAllStockItems: () => {
//     return stocks;
//   },
//   createStockItem: (itemData) => {
//     const newItem = {
//       id: stocks.length + 1,
//       ...itemData,
//       last_updated: new Date()
//     };
//     stocks.push(newItem);
//     return newItem;
//   }
// };


================================================
File: modules/stocks/services/typesProduit.service.js
================================================
const { eq } = require("drizzle-orm");
const {db} = require("../../../core/database/config");
// const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { type_produits } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createTypeProduit = async (data) => {
  const [result] = await db.insert(type_produits).values(data).returning();
  return result;
};

const getTypeProduits = async () => {
  return await db.select().from(type_produits);
};

const getTypeProduitById = async (id) => {
  const [result] = await db
    .select()
    .from(type_produits)
    .where(eq(type_produits.id_type_produit, id));
  return result;
};

const updateTypeProduit = async (id, data) => {
  const [result] = await db
    .update(type_produits)
    .set({
      ...data,
      updated_at: new Date(),
    })
    .where(eq(type_produits.id_type_produit, id))
    .returning();
  return result;
};

const deleteTypeProduit = async (id) => {
  const [result] = await db
    .delete(type_produits)
    .where(eq(type_produits.id_type_produit, id))
    .returning();
  return result;
};

module.exports = {
  createTypeProduit,
  getTypeProduits,
  getTypeProduitById,
  updateTypeProduit,
  deleteTypeProduit,
};



================================================
File: modules/stocks/tests/stocks.mock.js
================================================
// module.exports = {
//   famille: [
//     {
//       id: 1,
//       libelle: "Informatique"
//     },
//     {
//       id: 2,
//       libelle: "Bureautique"
//     }
//   ],

//   categorie: [
//     {
//       id: 1,
//       libelle: "PÃ©riphÃ©rique"
//     },
//     {
//       id: 2,
//       libelle: "Composant"
//     }
//   ],

//   modele: [
//     {
//       id: 1,
//       libelle: "ProBook 450"
//     },
//     {
//       id: 2,
//       libelle: "ThinkPad X1"
//     }
//   ],

//   marque: [
//     {
//       id: 1,
//       libelle: "HP"
//     },
//     {
//       id: 2,
//       libelle: "Lenovo"
//     }
//   ],

//   fonction: [
//     {
//       id: 1,
//       nom: "DÃ©veloppeur"
//     },
//     {
//       id: 2,
//       nom: "Chef de projet"
//     }
//   ],

//   employes: [
//     {
//       id: 1,
//       nom: "Dupont",
//       keycloak_id: "a1b2c3d4-e5f6-7890",
//       prenom: "Jean",
//       email: "jean.dupont@example.com",
//       contact: "+123456789",
//       adresse: "123 Rue Example, Ville",
//       status: "Actif",
//       fonctionId: 1
//     },
//     {
//       id: 2,
//       nom: "Martin",
//       keycloak_id: "b2c3d4e5-f6g7-8901",
//       prenom: "Sophie",
//       email: "sophie.martin@example.com",
//       contact: "+987654321",
//       adresse: "456 Avenue Test, Ville",
//       status: "Actif",
//       fonctionId: 2
//     }
//   ],

//   demande: [
//     {
//       id: 1,
//       dateDebut: "2025-01-15",
//       status: "En cours",
//       dateFin: "2025-01-30",
//       motif: "Besoin d'un nouvel ordinateur",
//       type: "MatÃ©riel",
//       employeId: 1
//     }
//   ],

//   typeDoc: [
//     {
//       id: 1,
//       libelle: "Contrat"
//     },
//     {
//       id: 2,
//       libelle: "Facture"
//     }
//   ],

//   entite: [
//     {
//       id: 1,
//       libelle: "Direction"
//     },
//     {
//       id: 2,
//       libelle: "Service Technique"
//     }
//   ],

//   produit: [
//     {
//       id: 1,
//       code: "PROD001",
//       nom: "Ordinateur portable",
//       description: "Ordinateur portable haute performance",
//       type: "MatÃ©riel",
//       image: "images/prod001.jpg",
//       quantite: "10",
//       modeleId: 1,
//       categorieId: 1,
//       familleId: 1,
//       marqueId: 1
//     }
//   ],

//   documents: [
//     {
//       id: 1,
//       titre: "Contrat de travail",
//       fichier: "docs/contrat.pdf",
//       dateAjout: "2025-01-10",
//       employeId: 1,
//       typeDocId: 1
//     }
//   ],

//   partenaire: [
//     {
//       id: 1,
//       nom: "TechSolutions Inc.",
//       telephone: "+1234567890",
//       email: "contact@techsolutions.com",
//       specialite: "Informatique",
//       localisation: "123 Business Ave, City",
//       type: "Fournisseur",
//       entiteId: 1
//     }
//   ],

//   contrat: [
//     {
//       id: 1,
//       nom: "Contrat de maintenance",
//       duree: "1 an",
//       dateDebut: "2025-01-01",
//       dateFin: "2025-12-31",
//       lien: "contrats/2025/maintenance.pdf",
//       partenaireId: 1
//     }
//   ],

//   intervention: [
//     {
//       id: 1,
//       date: "2025-02-15",
//       causeDefaillance: "Panne matÃ©rielle",
//       rapport: "rapports/interv001.pdf",
//       typeMaintenance: "Corrective",
//       typeDefaillance: "MatÃ©rielle",
//       superviseur: "M. Responsable",
//       duree: "2 heures",
//       numero: "INT-2025-001",
//       lieu: "Bureau 101",
//       contratId: 1
//     }
//   ],

//   projet: [
//     {
//       id: 1,
//       nom: "Migration vers Windows 11",
//       type: "IT",
//       devis: "DEV-2025-001",
//       dateDebut: "2025-03-01",
//       dateFin: "2025-06-30",
//       duree: "4 mois",
//       description: "Migration de tous les postes vers Windows 11",
//       etat: "En cours",
//       partenaireId: 1,
//       familleId: 1
//     }
//   ],

//   livraison: [
//     {
//       id: 1,
//       autresFrais: "50",
//       periodeAchat: "Mars 2025",
//       prixAchat: "1200",
//       dedouanement: "100",
//       prixTransport: "150",
//       dateLivraison: "2025-03-15",
//       quantite: "5",
//       partenaireId: 1
//     }
//   ],

//   mission: [
//     {
//       id: 1,
//       nom: "DÃ©ploiement pilote",
//       description: "DÃ©ploiement initial sur 10 postes tests",
//       statut: "En cours",
//       lieu: "SiÃ¨ge social",
//       projetId: 1
//     }
//   ],

//   exemplaire: [
//     {
//       id: 1,
//       numSerie: "SN123456789",
//       prix: "1250",
//       etat: "Neuf",
//       livraisonId: 1,
//       produitId: 1,
//       produitCode: "PROD001"
//     }
//   ],

//   tache: [
//     {
//       id: 1,
//       nom: "Installation OS",
//       description: "Installation de Windows 11 sur les postes",
//       statut: "En cours",
//       dateDebut: "2025-03-10",
//       dateFin: "2025-03-12",
//       responsable: "Technicien IT",
//       missionId: 1
//     }
//   ],

//   projetExemplaireEmployes: [
//     {
//       exemplaireId: 1,
//       projetId: 1,
//       employeId: 1,
//       dateUtilisation: "2025-03-16",
//       dateFin: "2025-06-30",
//       dateDebut: "2025-03-16"
//     }
//   ],

//   exemplaireAcheter: [
//     {
//       exemplaireId: 1,
//       partenaireId: 1,
//       lieuLivraison: "EntrepÃ´t principal",
//       quantite: "1",
//       dateAchat: "2025-03-10"
//     }
//   ],

//   missionEmployes: [
//     {
//       employeId: 1,
//       missionId: 1
//     }
//   ],

//   interventionProduit: [
//     {
//       exemplaireId: 1,
//       interventionId: 1
//     }
//   ],

//   interventionEmploye: [
//     {
//       employeId: 1,
//       interventionId: 1
//     }
//   ],

//   sollicitationProduits: [
//     {
//       produitId: 1,
//       produitCode: "PROD001",
//       partenaireId: 1,
//       etat: "En attente",
//       description: "Besoin de piÃ¨ces de rechange"
//     }
//   ],

//   sollicitationInterventions: [
//     {
//       partenaireId: 1,
//       interventionId: 1,
//       etat: "TerminÃ©",
//       description: "Intervention urgente rÃ©alisÃ©e"
//     }
//   ]
// };


================================================
File: modules/stocks/utils/drizzle-wrapper.js
================================================
/**
 * ⚠️ [ARCHITECTURE - SOLUTION DE CONTOURNEMENT] ⚠️
 *
 * Problème initial :
 * - Le fichier central config.js utilise des ES Modules (import/export)
 * - Le reste du projet utilise CommonJS (require/module.exports)
 * - Résultat : db.insert() non reconnu dans famille.service.js
 *
 * Pourquoi ce fichier existe :
 * 1. Évite de modifier config.js (fichier partagé avec d'autres modules)
 * 2. Contourne l'incompatibilité des systèmes de modules
 * 3. Garantit une instance Drizzle fonctionnelle avec :
 *    - Les mêmes paramètres de connexion
 *    - Le même schéma de base de données
 *
 * Solution technique :
 * - Crée une nouvelle instance Drizzle locale
 * - Réutilise les variables d'environnement existantes
 * - Maintient l'isolation du module
 *
 * Risques à connaître :
 * - Double instance de Pool PostgreSQL (augmente légèrement les connexions)
 * - Nécessite de synchroniser les changements de schéma manuellement
 *
 * Alternatives envisagées et rejetées :
 * - Convertir tout le projet en ES Modules (trop intrusif)
 * - Modifier config.js (risque pour les autres modules)
 */

// [Mon module stocks] → [drizzle-wrapper local] → PostgreSQL
//             ↑
//             └─ [N'utilise PAS config.js]

// modules/stocks/utils/drizzle-wrapper.js
const { drizzle } = require("drizzle-orm/node-postgres");
const { Pool } = require("pg");
const schema = require("../../../core/database/models");

// Config locale (utilise les mêmes variables d'environnement de .env)
const pool = new Pool({
  // host: process.env.DB_HOST,
  host: "172.31.3.7",
  port: process.env.DB_PORT,
  user: process.env.APP_DB_USER,
  password: process.env.APP_DB_PASSWORD,
  database: process.env.APP_DB_NAME,
});

module.exports = drizzle(pool, { schema });



================================================
File: modules/stocks/utils/setup-triggers.js
================================================
// const { sql } = require('drizzle-orm');
// const { db } = require('./db.config');

// async function setupUpdatedAtTriggers() {
//   // Ã‰tape 1 : CrÃ©er la fonction PostgreSQL
//   await db.execute(sql`
//     CREATE OR REPLACE FUNCTION update_updated_at_column()
//     RETURNS TRIGGER AS $$
//     BEGIN
//       NEW.updated_at = NOW();
//       RETURN NEW;
//     END;
//     $$ LANGUAGE plpgsql;
//   `);

//   // Ã‰tape 2 : Liste des tables Ã  gÃ©rer
//   const tables = [
//     'familles', 'modeles', 'marques', 'fonctions', 'employes',
//     'demandes', 'type_docs', 'clients_en_ligne', 'entites',
//     'partenaires', 'commandes', 'type_produits', 'prestations',
//     'produits', 'contrats', 'projets', 'livraisons', 'documents',
//     'interventions', 'taches', 'exemplaires',
//     'intervention_employes', 'usage_exemplaires', 'prestation_employes'
//   ];

//   // Ã‰tape 3 : CrÃ©er un trigger sur chaque table
//   for (const table of tables) {
//     await db.execute(sql`
//       DROP TRIGGER IF EXISTS trg_update_${sql.identifier(table)}_updated_at ON ${sql.identifier(table)};
//     `);

//     await db.execute(sql`
//       CREATE TRIGGER trg_update_${sql.identifier(table)}_updated_at
//       BEFORE UPDATE ON ${sql.identifier(table)}
//       FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
//     `);
//   }

//   console.log('âœ… Triggers "updated_at" appliquÃ©s avec succÃ¨s Ã  toutes les tables.');
// }

// module.exports = {
//   setupUpdatedAtTriggers,
// };



================================================
File: modules/technique/controllers/interventions.controller.js
================================================
const fs = require('fs').promises;
const path = require('path');
const interventionsService = require("../services/interventions.service");

const interventionsController = {
  getAllInterventions: async (req, res) => {
    try {
      const interventions = await interventionsService.getAllInterventions();
      res.status(200).json({ success: true, data: interventions });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getInterventionById: async (req, res) => {
    try {
      const { id } = req.params;
      const intervention = await interventionsService.getInterventionById(parseInt(id));
      if (!intervention) {
        return res.status(404).json({ success: false, message: "Intervention non trouvÃ©e" });
      }
      res.status(200).json({ success: true, data: intervention });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  createIntervention: async (req, res) => {
    try {
      const interventionData = {
        date_: new Date(req.body.date_),
        cause_defaillance: req.body.cause_defaillance,
        rapport_intervention: req.body.rapport_intervention,
        type_intervention: req.body.type_intervention,
        type_defaillance: req.body.type_defaillance,
        duree: req.body.duree,
        lieu: req.body.lieu,
        statut_intervention: req.body.statut_intervention || 'en_cours',
        recommandation: req.body.recommandation,
        probleme_signale: req.body.probleme_signale,
        mode_intervention: req.body.mode_intervention,
        detail_cause: req.body.detail_cause,
        type: req.body.type,
        id_partenaire: req.body.id_partenaire ? parseInt(req.body.id_partenaire) : null,
        id_contrat: req.body.id_contrat ? parseInt(req.body.id_contrat) : null
      };

      const newIntervention = await interventionsService.createIntervention(interventionData);

      res.status(201).json({
        success: true,
        message: "Intervention crÃ©Ã©e avec succÃ¨s",
        data: {
          intervention: newIntervention,
          details: {
            dateCreation: new Date().toISOString()
          }
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la crÃ©ation de l'intervention",
        error: error.message
      });
    }
  },

  updateIntervention: async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;
      if (updateData.date_) updateData.date_ = new Date(updateData.date_);
      if (updateData.id_partenaire) updateData.id_partenaire = parseInt(updateData.id_partenaire);
      if (updateData.id_contrat) updateData.id_contrat = parseInt(updateData.id_contrat);

      const updatedIntervention = await interventionsService.updateIntervention(
        parseInt(id),
        updateData
      );

      if (!updatedIntervention) {
        return res.status(404).json({ success: false, message: "Intervention non trouvÃ©e" });
      }

      res.status(200).json({ success: true, data: updatedIntervention });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  deleteIntervention: async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await interventionsService.deleteIntervention(parseInt(id));
      if (!deleted) {
        return res.status(404).json({
          success: false,
          message: "Intervention non trouvÃ©e"
        });
      }
      res.status(200).json({
        success: true,
        message: "Intervention supprimÃ©e avec succÃ¨s",
        data: { id: parseInt(id) }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  },

  addDocumentToIntervention: async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: "Aucun fichier n'a Ã©tÃ© tÃ©lÃ©chargÃ©"
        });
      }

      const { id } = req.params;
      const relativePath = req.file.path
        .replace(process.cwd(), '')
        .replace(/\\/g, '/')
        .replace(/^\//, '');

      const documentData = {
        libelle_document: req.body.libelle_document,
        classification_document: req.body.classification_document,
        lien_document: relativePath,
        etat_document: req.body.etat_document || 'actif',
        id_nature_document: req.body.id_nature_document ? parseInt(req.body.id_nature_document) : null,
        id_intervention: parseInt(id)
      };

      let document;
      try {
        document = await interventionsService.addDocumentToIntervention(documentData);
      } catch (dbError) {
        await fs.unlink(req.file.path).catch(() => {});
        return res.status(500).json({
          success: false,
          message: "Erreur lors de l'enregistrement du document en base",
          error: dbError.message
        });
      }

      res.status(201).json({
        success: true,
        message: "Document ajoutÃ© avec succÃ¨s Ã  l'intervention",
        data: {
          document: document,
          details: {
            dateCreation: new Date().toISOString(),
            chemin: relativePath
          }
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de l'ajout du document",
        error: error.message
      });
    }
  },

  getInterventionDocuments: async (req, res) => {
    try {
      const { id } = req.params;
      const documents = await interventionsService.getInterventionDocuments(parseInt(id));
      res.status(200).json({
        success: true,
        message: "Liste des documents de l'intervention rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: documents
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  },

  deleteDocument: async (req, res) => {
    try {
      const { id, documentId } = req.params;
      const document = await interventionsService.getDocumentById(parseInt(documentId));
      if (!document || document.id_intervention !== parseInt(id)) {
        return res.status(404).json({
          success: false,
          message: "Document non trouvÃ© ou n'appartenant pas Ã  cette intervention"
        });
      }
      const deleted = await interventionsService.deleteDocument(parseInt(documentId));
      res.status(200).json({
        success: true,
        message: "Document supprimÃ© avec succÃ¨s",
        data: {
          intervention_id: parseInt(id),
          document_id: parseInt(documentId)
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  },

  addEmployeToIntervention: async (req, res) => {
    try {
      const { id } = req.params;
      const { id_employes } = req.body;
      const result = await interventionsService.addEmployeToIntervention(
        parseInt(id),
        parseInt(id_employes)
      );
      res.status(201).json({
        success: true,
        message: "EmployÃ© ajoutÃ© Ã  l'intervention avec succÃ¨s",
        data: result
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  },

  removeEmployeFromIntervention: async (req, res) => {
    try {
      const { id, employeId } = req.params;
      const result = await interventionsService.removeEmployeFromIntervention(
        parseInt(id),
        parseInt(employeId)
      );
      if (!result) {
        return res.status(404).json({
          success: false,
          message: "Association non trouvÃ©e"
        });
      }
      res.status(200).json({
        success: true,
        message: "EmployÃ© retirÃ© de l'intervention avec succÃ¨s",
        data: {
          intervention_id: parseInt(id),
          employe_id: parseInt(employeId)
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  },

  getInterventionEmployes: async (req, res) => {
    try {
      const { id } = req.params;
      const employes = await interventionsService.getInterventionEmployes(parseInt(id));
      res.status(200).json({
        success: true,
        message: "Liste des employÃ©s de l'intervention rÃ©cupÃ©rÃ©e",
        data: employes
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  }
};

module.exports = interventionsController;



================================================
File: modules/technique/controllers/livrable.controller.js
================================================
const fs = require('fs').promises;
const livrableService = require("../services/livrable.service");

const livrableController = {
  getAllLivrables: async (req, res) => {
    try {
      const data = await livrableService.getAllLivrables();
      res.status(200).json({ success: true, data });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getLivrableById: async (req, res) => {
    try {
      const { id } = req.params;
      const data = await livrableService.getLivrableById(parseInt(id));
      if (!data) return res.status(404).json({ success: false, message: "Livrable non trouvÃ©" });
      res.status(200).json({ success: true, data });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  createLivrable: async (req, res) => {
    try {
      const data = req.body;
      const newLivrable = await livrableService.createLivrable(data);
      res.status(201).json({ success: true, data: newLivrable });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  updateLivrable: async (req, res) => {
    try {
      const { id } = req.params;
      const data = req.body;
      const updated = await livrableService.updateLivrable(parseInt(id), data);
      if (!updated) return res.status(404).json({ success: false, message: "Livrable non trouvÃ©" });
      res.status(200).json({ success: true, data: updated });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  deleteLivrable: async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await livrableService.deleteLivrable(parseInt(id));
      if (!deleted) return res.status(404).json({ success: false, message: "Livrable non trouvÃ©" });
      res.status(200).json({ success: true, message: "Livrable supprimÃ©", data: deleted });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  // Documents liÃ©s
  addDocumentToLivrable: async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ success: false, message: "Aucun fichier n'a Ã©tÃ© tÃ©lÃ©chargÃ©" });
      }
      const { id } = req.params;
      const relativePath = req.file.path.replace(process.cwd(), '').replace(/\\/g, '/').replace(/^\//, '');
      const documentData = {
        libelle_document: req.body.libelle_document,
        lien_document: relativePath,
        etat_document: req.body.etat_document || 'actif',
        id_livrable: parseInt(id),
        id_nature_document: req.body.id_nature_document ? parseInt(req.body.id_nature_document) : null
      };
      let document;
      try {
        document = await livrableService.addDocumentToLivrable(documentData);
      } catch (dbError) {
        await fs.unlink(req.file.path).catch(() => {});
        return res.status(500).json({ success: false, message: "Erreur lors de l'enregistrement du document en base", error: dbError.message });
      }
      res.status(201).json({ success: true, message: "Document ajoutÃ© au livrable", data: document });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getLivrableDocuments: async (req, res) => {
    try {
      const { id } = req.params;
      const documents = await livrableService.getLivrableDocuments(parseInt(id));
      res.status(200).json({ success: true, data: documents });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  deleteDocument: async (req, res) => {
    try {
      const { id, documentId } = req.params;
      const document = await livrableService.getDocumentById(parseInt(documentId));
      if (!document || document.id_livrable !== parseInt(id)) {
        return res.status(404).json({ success: false, message: "Document non trouvÃ© ou n'appartenant pas Ã  ce livrable" });
      }
      await livrableService.deleteDocument(parseInt(documentId));
      res.status(200).json({ success: true, message: "Document supprimÃ©" });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },
  
  getLivrablesByProjet: async (req, res) => {
    try {
      const { projetId } = req.params;
      const livrables = await livrableService.getLivrablesByProjet(parseInt(projetId));
      res.status(200).json({ success: true, data: livrables });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  }
};

module.exports = livrableController;


================================================
File: modules/technique/controllers/projets.controller.js
================================================
const fs = require('fs').promises;
const path = require('path');
const projetsService = require("../services/projets.service");

const projetsController = {
  getAllProjets: async (req, res) => {
    try {
      const projets = await projetsService.getAllProjets();
      res.status(200).json({ success: true, data: projets });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getProjetById: async (req, res) => {
    try {
      const { id } = req.params;
      const projet = await projetsService.getProjetById(parseInt(id));
      if (!projet) {
        return res.status(404).json({ success: false, message: "Projet non trouvÃ©" });
      }
      res.status(200).json({ success: true, data: projet });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  createProjet: async (req, res) => {
    try {
      const projetData = {
        nom_projet: req.body.nom_projet,
        type_projet: req.body.type_projet,
        devis_estimatif: parseFloat(req.body.devis_estimatif),
        date_debut: new Date(req.body.date_debut),
        date_fin: new Date(req.body.date_fin),
        duree_prevu_projet: req.body.duree_prevu_projet,
        description_projet: req.body.description_projet,
        etat: req.body.etat || 'en_cours',
        lieu: req.body.lieu,
        responsable: req.body.responsable,
        site: req.body.site,
        id_famille: req.body.id_famille ? parseInt(req.body.id_famille) : null
      };

      const newProjet = await projetsService.createProjet(projetData);

      res.status(201).json({
        success: true,
        message: "Projet crÃ©Ã© avec succÃ¨s",
        data: {
          projet: newProjet,
          details: {
            dateCreation: new Date().toISOString()
          }
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la crÃ©ation du projet",
        error: error.message
      });
    }
  },

  updateProjet: async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;
      if (updateData.devis_estimatif) updateData.devis_estimatif = parseFloat(updateData.devis_estimatif);
      if (updateData.date_debut) updateData.date_debut = new Date(updateData.date_debut);
      if (updateData.date_fin) updateData.date_fin = new Date(updateData.date_fin);
      if (updateData.id_famille) updateData.id_famille = parseInt(updateData.id_famille);

      const updatedProjet = await projetsService.updateProjet(parseInt(id), updateData);

      if (!updatedProjet) {
        return res.status(404).json({ success: false, message: "Projet non trouvÃ©" });
      }

      res.status(200).json({ success: true, data: updatedProjet });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  deleteProjet: async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await projetsService.deleteProjet(parseInt(id));
      if (!deleted) {
        return res.status(404).json({ success: false, message: "Projet non trouvÃ©" });
      }
      res.status(200).json({
        success: true,
        message: "Projet supprimÃ© avec succÃ¨s",
        data: { id: parseInt(id) }
      });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  addDocumentToProjet: async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: "Aucun fichier n'a Ã©tÃ© tÃ©lÃ©chargÃ©"
        });
      }

      const { id } = req.params;
      const relativePath = req.file.path
        .replace(process.cwd(), '')
        .replace(/\\/g, '/')
        .replace(/^\//, '');

      const documentData = {
        libelle_document: req.body.libelle_document,
        classification_document: req.body.classification_document,
        lien_document: relativePath,
        etat_document: req.body.etat_document || 'actif',
        id_nature_document: req.body.id_nature_document ? parseInt(req.body.id_nature_document) : null,
        id_projet: parseInt(id)
      };

      let document;
      try {
        document = await projetsService.addDocumentToProjet(documentData);
      } catch (dbError) {
        await fs.unlink(req.file.path).catch(() => {});
        return res.status(500).json({
          success: false,
          message: "Erreur lors de l'enregistrement du document en base",
          error: dbError.message
        });
      }

      res.status(201).json({
        success: true,
        message: "Document ajoutÃ© avec succÃ¨s au projet",
        data: {
          document: document,
          details: {
            dateCreation: new Date().toISOString(),
            chemin: relativePath
          }
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de l'ajout du document",
        error: error.message
      });
    }
  },

  addPartenaireToProjet: async (req, res) => {
    try {
      const { id } = req.params;
      const { id_partenaire } = req.body;
      const result = await projetsService.addPartenaireToProjet(
        parseInt(id),
        parseInt(id_partenaire)
      );
      res.status(201).json({
        success: true,
        message: "Partenaire ajoutÃ© au projet avec succÃ¨s",
        data: result
      });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  removePartenaireFromProjet: async (req, res) => {
    try {
      const { id, partenaireId } = req.params;
      const result = await projetsService.removePartenaireFromProjet(
        parseInt(id),
        parseInt(partenaireId)
      );
      if (!result) {
        return res.status(404).json({ success: false, message: "Association non trouvÃ©e" });
      }
      res.status(200).json({
        success: true,
        message: "Partenaire retirÃ© du projet avec succÃ¨s",
        data: {
          projet_id: parseInt(id),
          partenaire_id: parseInt(partenaireId)
        }
      });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getProjetPartenaires: async (req, res) => {
    try {
      const { id } = req.params;
      const partenaires = await projetsService.getProjetPartenaires(parseInt(id));
      res.status(200).json({
        success: true,
        message: "Liste des partenaires du projet rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: partenaires
      });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getProjetLivrables: async (req, res) => {
    try {
      const { id } = req.params;
      const livrables = await projetsService.getProjetLivrables(parseInt(id));
      res.status(200).json({
        success: true,
        message: "Liste des livrables du projet rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: livrables
      });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getProjetLivrablesWithDocuments: async (req, res) => {
    try {
      const { id } = req.params;
      const livrables = await projetsService.getProjetLivrablesWithDocuments(parseInt(id));
      res.status(200).json({
        success: true,
        message: "Liste des livrables avec documents du projet rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: livrables
      });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getProjetDocuments: async (req, res) => {
    try {
      const { id } = req.params;
      const documents = await projetsService.getProjetDocuments(parseInt(id));
      res.status(200).json({
        success: true,
        message: "Liste des documents du projet rÃ©cupÃ©rÃ©e avec succÃ¨s",
        data: documents
      });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  deleteDocument: async (req, res) => {
    try {
      const { id, documentId } = req.params;
      const document = await projetsService.getDocumentById(parseInt(documentId));
      if (!document || document.id_projet !== parseInt(id)) {
        return res.status(404).json({
          success: false,
          message: "Document non trouvÃ© ou n'appartenant pas Ã  ce projet"
        });
      }
      const deleted = await projetsService.deleteDocument(parseInt(documentId));
      res.status(200).json({
        success: true,
        message: "Document supprimÃ© avec succÃ¨s",
        data: {
          projet_id: parseInt(id),
          document_id: parseInt(documentId)
        }
      });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  }
};

module.exports = projetsController;



================================================
File: modules/technique/controllers/taches.controller.js
================================================
const tachesService = require("../services/taches.service");

const tachesController = {
  getAllTaches: async (req, res) => {
    try {
      const taches = await tachesService.getAllTaches();
      res.status(200).json({ success: true, data: taches });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getTacheById: async (req, res) => {
    try {
      const { id } = req.params;
      const tache = await tachesService.getTacheById(parseInt(id));
      if (!tache) {
        return res.status(404).json({ success: false, message: "TÃ¢che non trouvÃ©e" });
      }
      res.status(200).json({ success: true, data: tache });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  createTache: async (req, res) => {
    try {
      const tacheData = req.body;
      const newTache = await tachesService.createTache(tacheData);
      res.status(201).json({ success: true, data: newTache });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  updateTache: async (req, res) => {
    try {
      const { id } = req.params;
      const tacheData = req.body;
      const updatedTache = await tachesService.updateTache(parseInt(id), tacheData);
      if (!updatedTache) {
        return res.status(404).json({ success: false, message: "TÃ¢che non trouvÃ©e" });
      }
      res.status(200).json({ success: true, data: updatedTache });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  deleteTache: async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await tachesService.deleteTache(parseInt(id));
      if (!deleted) {
        return res.status(404).json({ success: false, message: "TÃ¢che non trouvÃ©e" });
      }
      res.status(200).json({ success: true, message: "TÃ¢che supprimÃ©e avec succÃ¨s" });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  addEmployeToTache: async (req, res) => {
    try {
      const { id } = req.params;
      const { id_employes } = req.body;
      const result = await tachesService.addEmployeToTache(
        parseInt(id),
        parseInt(id_employes)
      );
      res.status(201).json({ success: true, data: result });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  removeEmployeFromTache: async (req, res) => {
    try {
      const { id, employeId } = req.params;
      const result = await tachesService.removeEmployeFromTache(
        parseInt(id),
        parseInt(employeId)
      );
      if (!result) {
        return res.status(404).json({ success: false, message: "Association non trouvÃ©e" });
      }
      res.status(200).json({ success: true, message: "EmployÃ© retirÃ© de la tÃ¢che" });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getTacheEmployes: async (req, res) => {
    try {
      const { id } = req.params;
      const employes = await tachesService.getTacheEmployes(parseInt(id));
      res.status(200).json({ success: true, data: employes });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  },

  getTachesByProjet: async (req, res) => {
    try {
      const { projetId } = req.params;
      const taches = await tachesService.getTachesByProjet(parseInt(projetId));
      res.status(200).json({ success: true, data: taches });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  }
};

module.exports = tachesController;



================================================
File: modules/technique/routes/interventions.routes.js
================================================
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const interventionsController = require('../controllers/interventions.controller');
const uploadMiddleware = require("../../utils/middleware/uploadMiddleware");

// DÃ©finition des chemins de stockage
const UPLOAD_PATHS = {
  INTERVENTIONS: 'media/documents/technique/interventions'
};

// Middleware pour gÃ©rer les erreurs d'upload
const handleUploadError = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    return res.status(400).json({
      success: false,
      message: "Erreur lors du tÃ©lÃ©chargement du fichier",
      error: err.message
    });
  }
  next(err);
};

/**
 * @swagger
 * components:
 *   schemas:
 *     Intervention:
 *       type: object
 *       properties:
 *         id_intervention:
 *           type: integer
 *           description: ID unique de l'intervention
 *         date_intervention:
 *           type: string
 *           format: date
 *           description: Date de l'intervention
 *         cause_defaillance:
 *           type: string
 *           description: Cause de la dÃ©faillance
 *         rapport_intervention:
 *           type: string
 *           description: Rapport dÃ©taillÃ© de l'intervention
 *         type_intervention:
 *           type: string
 *           description: Type d'intervention (Maintenance, DÃ©pannage, Installation, etc.)
 *         type_defaillance:
 *           type: string
 *           description: Type de dÃ©faillance rencontrÃ©e
 *         duree:
 *           type: string
 *           description: DurÃ©e de l'intervention
 *         lieu:
 *           type: string
 *           description: Lieu oÃ¹ s'est dÃ©roulÃ©e l'intervention
 *         statut_intervention:
 *           type: string
 *           description: Statut actuel de l'intervention (En cours, TerminÃ©e, En attente, etc.)
 *         recommandation:
 *           type: string
 *           description: Recommandations suite Ã  l'intervention
 *         probleme_signale:
 *           type: string
 *           description: ProblÃ¨me initialement signalÃ©
 *         mode_intervention:
 *           type: string
 *           description: Mode d'intervention (Sur site, Ã€ distance, etc.)
 *         detail_cause:
 *           type: string
 *           description: DÃ©tails sur la cause du problÃ¨me
 *         type:
 *           type: string
 *           description: Classification de l'intervention
 *         id_partenaire:
 *           type: integer
 *           description: ID du partenaire concernÃ© par l'intervention
 *         id_contrat:
 *           type: integer
 *           description: ID du contrat liÃ© Ã  l'intervention
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date de crÃ©ation de l'enregistrement
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date de derniÃ¨re mise Ã  jour
 *     Document:
 *       type: object
 *       properties:
 *         id_documents:
 *           type: integer
 *           description: ID unique du document
 *         libelle_document:
 *           type: string
 *           description: LibellÃ© du document
 *         classification_document:
 *           type: string
 *           description: Classification du document
 *         date_document:
 *           type: string
 *           description: Date du document
 *         lien_document:
 *           type: string
 *           description: Chemin d'accÃ¨s au document
 *         etat_document:
 *           type: string
 *           description: Ã‰tat du document (Actif, ArchivÃ©)
 *     Employe:
 *       type: object
 *       properties:
 *         id_employes:
 *           type: integer
 *           description: ID unique de l'employÃ©
 *         nom_employes:
 *           type: string
 *           description: Nom de l'employÃ©
 *         prenom_employes:
 *           type: string
 *           description: PrÃ©nom de l'employÃ©
 *         email_employes:
 *           type: string
 *           description: Email de l'employÃ©
 *         contact_employes:
 *           type: string
 *           description: NumÃ©ro de contact de l'employÃ©
 */

/**
 * @swagger
 * /api/technique/interventions:
 *   get:
 *     summary: Liste toutes les interventions
 *     description: RÃ©cupÃ¨re la liste complÃ¨te des interventions techniques
 *     tags: [Interventions]
 *     responses:
 *       200:
 *         description: Liste des interventions rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 interventions:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Intervention'
 *       500:
 *         description: Erreur serveur
 */
router.get("/", interventionsController.getAllInterventions);

/**
 * @swagger
 * /api/technique/interventions/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une intervention par son ID
 *     description: Retourne les dÃ©tails d'une intervention spÃ©cifique
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention
 *     responses:
 *       200:
 *         description: DÃ©tails de l'intervention rÃ©cupÃ©rÃ©s avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 intervention:
 *                   $ref: '#/components/schemas/Intervention'
 *       404:
 *         description: Intervention non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id", interventionsController.getInterventionById);

/**
 * @swagger
 * /api/technique/interventions:
 *   post:
 *     summary: CrÃ©e une nouvelle intervention
 *     description: Enregistre une nouvelle intervention technique
 *     tags: [Interventions]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - date_intervention
 *               - type_intervention
 *               - lieu
 *             properties:
 *               date_intervention:
 *                 type: string
 *                 format: date
 *                 description: Date de l'intervention
 *               cause_defaillance:
 *                 type: string
 *                 description: Cause de la dÃ©faillance
 *               rapport_intervention:
 *                 type: string
 *                 description: Rapport dÃ©taillÃ© de l'intervention
 *               type_intervention:
 *                 type: string
 *                 description: Type d'intervention (Maintenance, DÃ©pannage, Installation, etc.)
 *               type_defaillance:
 *                 type: string
 *                 description: Type de dÃ©faillance rencontrÃ©e
 *               duree:
 *                 type: string
 *                 description: DurÃ©e de l'intervention
 *               lieu:
 *                 type: string
 *                 description: Lieu oÃ¹ s'est dÃ©roulÃ©e l'intervention
 *               statut_intervention:
 *                 type: string
 *                 description: Statut actuel de l'intervention
 *               recommandation:
 *                 type: string
 *                 description: Recommandations suite Ã  l'intervention
 *               probleme_signale:
 *                 type: string
 *                 description: ProblÃ¨me initialement signalÃ©
 *               mode_intervention:
 *                 type: string
 *                 description: Mode d'intervention (Sur site, Ã€ distance, etc.)
 *               detail_cause:
 *                 type: string
 *                 description: DÃ©tails sur la cause du problÃ¨me
 *               type:
 *                 type: string
 *                 description: Classification de l'intervention
 *               id_partenaire:
 *                 type: integer
 *                 description: ID du partenaire concernÃ© par l'intervention
 *               id_contrat:
 *                 type: integer
 *                 description: ID du contrat liÃ© Ã  l'intervention
 *     responses:
 *       201:
 *         description: Intervention crÃ©Ã©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 intervention:
 *                   $ref: '#/components/schemas/Intervention'
 *       400:
 *         description: DonnÃ©es invalides
 *       500:
 *         description: Erreur serveur
 */
router.post("/", interventionsController.createIntervention);

/**
 * @swagger
 * /api/technique/interventions/{id}:
 *   put:
 *     summary: Met Ã  jour une intervention
 *     description: Modifie les informations d'une intervention existante
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention Ã  modifier
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               date_intervention:
 *                 type: string
 *                 format: date
 *                 description: Date de l'intervention
 *               cause_defaillance:
 *                 type: string
 *                 description: Cause de la dÃ©faillance
 *               rapport_intervention:
 *                 type: string
 *                 description: Rapport dÃ©taillÃ© de l'intervention
 *               type_intervention:
 *                 type: string
 *                 description: Type d'intervention
 *               type_defaillance:
 *                 type: string
 *                 description: Type de dÃ©faillance rencontrÃ©e
 *               duree:
 *                 type: string
 *                 description: DurÃ©e de l'intervention
 *               lieu:
 *                 type: string
 *                 description: Lieu oÃ¹ s'est dÃ©roulÃ©e l'intervention
 *               statut_intervention:
 *                 type: string
 *                 description: Statut actuel de l'intervention
 *               recommandation:
 *                 type: string
 *                 description: Recommandations suite Ã  l'intervention
 *               probleme_signale:
 *                 type: string
 *                 description: ProblÃ¨me initialement signalÃ©
 *               mode_intervention:
 *                 type: string
 *                 description: Mode d'intervention
 *               detail_cause:
 *                 type: string
 *                 description: DÃ©tails sur la cause du problÃ¨me
 *               type:
 *                 type: string
 *                 description: Classification de l'intervention
 *               id_partenaire:
 *                 type: integer
 *                 description: ID du partenaire concernÃ©
 *               id_contrat:
 *                 type: integer
 *                 description: ID du contrat liÃ©
 *     responses:
 *       200:
 *         description: Intervention mise Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 intervention:
 *                   $ref: '#/components/schemas/Intervention'
 *       404:
 *         description: Intervention non trouvÃ©e
 *       400:
 *         description: DonnÃ©es invalides
 *       500:
 *         description: Erreur serveur
 */
router.put("/:id", interventionsController.updateIntervention);

/**
 * @swagger
 * /api/technique/interventions/{id}:
 *   delete:
 *     summary: Supprime une intervention
 *     description: Supprime une intervention existante par son ID
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention Ã  supprimer
 *     responses:
 *       200:
 *         description: Intervention supprimÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Intervention supprimÃ©e avec succÃ¨s
 *       404:
 *         description: Intervention non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id", interventionsController.deleteIntervention);

/**
 * @swagger
 * /api/technique/interventions/{id}/documents:
 *   post:
 *     summary: Ajoute un document Ã  une intervention
 *     description: TÃ©lÃ©charge et associe un document Ã  une intervention existante
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - document
 *               - libelle_document
 *             properties:
 *               document:
 *                 type: string
 *                 format: binary
 *                 description: Fichier Ã  tÃ©lÃ©charger
 *               libelle_document:
 *                 type: string
 *                 description: Nom du document
 *               classification_document:
 *                 type: string
 *                 description: Classification du document
 *               date_document:
 *                 type: string
 *                 description: Date du document
 *               id_nature_document:
 *                 type: integer
 *                 description: ID de la nature du document
 *     responses:
 *       201:
 *         description: Document ajoutÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 document:
 *                   $ref: '#/components/schemas/Document'
 *       400:
 *         description: DonnÃ©es invalides ou erreur de tÃ©lÃ©chargement
 *       404:
 *         description: Intervention non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.post("/:id/documents",
  (req, res, next) => {
    try {
      // DÃ©finir et crÃ©er le chemin avant l'upload
      const uploadPath = path.join(process.cwd(), UPLOAD_PATHS.INTERVENTIONS);
      
      // CrÃ©er le dossier s'il n'existe pas
      if (!fs.existsSync(uploadPath)) {
        fs.mkdirSync(uploadPath, { recursive: true });
      }
      
      req.uploadPath = uploadPath;
      next();
    } catch (error) {
      next(error);
    }
  },
  uploadMiddleware.single("document"),
  interventionsController.addDocumentToIntervention
);

/**
 * @swagger
 * /api/technique/interventions/{id}/employes:
 *   post:
 *     summary: Ajoute un employÃ© Ã  une intervention
 *     description: Associe un employÃ© Ã  une intervention existante
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id_employes
 *             properties:
 *               id_employes:
 *                 type: integer
 *                 description: ID de l'employÃ© Ã  associer
 *     responses:
 *       201:
 *         description: EmployÃ© ajoutÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: EmployÃ© ajoutÃ© Ã  l'intervention avec succÃ¨s
 *       400:
 *         description: DonnÃ©es invalides ou association dÃ©jÃ  existante
 *       404:
 *         description: Intervention ou employÃ© non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post("/:id/employes", interventionsController.addEmployeToIntervention);

/**
 * @swagger
 * /api/technique/interventions/{id}/employes/{employeId}:
 *   delete:
 *     summary: Retire un employÃ© d'une intervention
 *     description: Dissocie un employÃ© d'une intervention existante
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention
 *       - in: path
 *         name: employeId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'employÃ© Ã  retirer
 *     responses:
 *       200:
 *         description: EmployÃ© retirÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: EmployÃ© retirÃ© de l'intervention avec succÃ¨s
 *       404:
 *         description: Intervention, employÃ© ou association non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id/employes/:employeId", interventionsController.removeEmployeFromIntervention);

/**
 * @swagger
 * /api/technique/interventions/{id}/employes:
 *   get:
 *     summary: RÃ©cupÃ¨re les employÃ©s d'une intervention
 *     description: Retourne la liste des employÃ©s associÃ©s Ã  une intervention spÃ©cifique
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention
 *     responses:
 *       200:
 *         description: Liste des employÃ©s rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 employes:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Employe'
 *       404:
 *         description: Intervention non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id/employes", interventionsController.getInterventionEmployes);

/**
 * @swagger
 * /api/technique/interventions/{id}/documents:
 *   get:
 *     summary: RÃ©cupÃ¨re les documents d'une intervention
 *     description: Retourne la liste des documents associÃ©s Ã  une intervention spÃ©cifique
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention
 *     responses:
 *       200:
 *         description: Liste des documents rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 documents:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Document'
 *       404:
 *         description: Intervention non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id/documents", interventionsController.getInterventionDocuments);

/**
 * @swagger
 * /api/technique/interventions/{id}/documents/{documentId}:
 *   delete:
 *     summary: Supprime un document d'une intervention
 *     description: Supprime un document associÃ© Ã  une intervention spÃ©cifique
 *     tags: [Interventions]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'intervention
 *       - in: path
 *         name: documentId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du document Ã  supprimer
 *     responses:
 *       200:
 *         description: Document supprimÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Document supprimÃ© avec succÃ¨s
 *       404:
 *         description: Intervention ou document non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id/documents/:documentId", interventionsController.deleteDocument);


module.exports = router;



================================================
File: modules/technique/routes/livrable.routes.js
================================================
const express = require("express");
const router = express.Router();
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const livrableController = require("../controllers/livrable.controller");
const uploadMiddleware = require("../../utils/middleware/uploadMiddleware");

// DÃ©finition des chemins de stockage
const UPLOAD_PATHS = {
  LIVRABLES: 'media/documents/technique/livrables'
};

/**
 * @swagger
 * components:
 *   schemas:
 *     Livrable:
 *       type: object
 *       properties:
 *         id_livrable:
 *           type: integer
 *           description: ID unique du livrable
 *         libelle_livrable:
 *           type: string
 *           description: LibellÃ© du livrable
 *         date:
 *           type: string
 *           format: date
 *           description: Date du livrable
 *         realisations:
 *           type: string
 *           description: RÃ©alisations liÃ©es au livrable
 *         reserves:
 *           type: string
 *           description: RÃ©serves Ã©mises sur le livrable
 *         approbation:
 *           type: string
 *           description: Approbation du livrable
 *         recommandation:
 *           type: string
 *           description: Recommandations pour le livrable
 *         id_projet:
 *           type: integer
 *           description: ID du projet auquel le livrable est rattachÃ©
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date de crÃ©ation de l'enregistrement
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date de derniÃ¨re mise Ã  jour
 *     Document:
 *       type: object
 *       properties:
 *         id_documents:
 *           type: integer
 *           description: ID unique du document
 *         libelle_document:
 *           type: string
 *           description: LibellÃ© du document
 *         classification_document:
 *           type: string
 *           description: Classification du document
 *         date_document:
 *           type: string
 *           description: Date du document
 *         lien_document:
 *           type: string
 *           description: Chemin d'accÃ¨s au document
 *         etat_document:
 *           type: string
 *           description: Ã‰tat du document (Actif, ArchivÃ©)
 */

/**
 * @swagger
 * /api/technique/livrables:
 *   get:
 *     summary: Liste tous les livrables
 *     description: RÃ©cupÃ¨re la liste complÃ¨te des livrables avec leurs informations
 *     tags: [Livrables]
 *     responses:
 *       200:
 *         description: Liste des livrables rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 livrables:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Livrable'
 *       500:
 *         description: Erreur serveur
 */
router.get("/", livrableController.getAllLivrables);

/**
 * @swagger
 * /api/technique/livrables/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un livrable par son ID
 *     description: Retourne les dÃ©tails d'un livrable spÃ©cifique
 *     tags: [Livrables]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du livrable
 *     responses:
 *       200:
 *         description: DÃ©tails du livrable rÃ©cupÃ©rÃ©s avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 livrable:
 *                   $ref: '#/components/schemas/Livrable'
 *       404:
 *         description: Livrable non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id", livrableController.getLivrableById);

/**
 * @swagger
 * /api/technique/livrables:
 *   post:
 *     summary: CrÃ©e un nouveau livrable
 *     description: Enregistre un nouveau livrable dans le systÃ¨me
 *     tags: [Livrables]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - libelle_livrable
 *               - id_projet
 *             properties:
 *               libelle_livrable:
 *                 type: string
 *                 description: LibellÃ© du livrable
 *               date:
 *                 type: string
 *                 format: date
 *                 description: Date du livrable (YYYY-MM-DD)
 *               realisations:
 *                 type: string
 *                 description: RÃ©alisations liÃ©es au livrable
 *               reserves:
 *                 type: string
 *                 description: RÃ©serves Ã©mises sur le livrable
 *               approbation:
 *                 type: string
 *                 description: Approbation du livrable
 *               recommandation:
 *                 type: string
 *                 description: Recommandations pour le livrable
 *               id_projet:
 *                 type: integer
 *                 description: ID du projet auquel le livrable est rattachÃ©
 *     responses:
 *       201:
 *         description: Livrable crÃ©Ã© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 livrable:
 *                   $ref: '#/components/schemas/Livrable'
 *       400:
 *         description: DonnÃ©es invalides
 *       404:
 *         description: Projet non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post("/", livrableController.createLivrable);

/**
 * @swagger
 * /api/technique/livrables/{id}:
 *   put:
 *     summary: Met Ã  jour un livrable
 *     description: Modifie les informations d'un livrable existant
 *     tags: [Livrables]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du livrable Ã  modifier
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               libelle_livrable:
 *                 type: string
 *                 description: LibellÃ© du livrable
 *               date:
 *                 type: string
 *                 format: date
 *                 description: Date du livrable (YYYY-MM-DD)
 *               realisations:
 *                 type: string
 *                 description: RÃ©alisations liÃ©es au livrable
 *               reserves:
 *                 type: string
 *                 description: RÃ©serves Ã©mises sur le livrable
 *               approbation:
 *                 type: string
 *                 description: Approbation du livrable
 *               recommandation:
 *                 type: string
 *                 description: Recommandations pour le livrable
 *               id_projet:
 *                 type: integer
 *                 description: ID du projet auquel le livrable est rattachÃ©
 *     responses:
 *       200:
 *         description: Livrable mis Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 livrable:
 *                   $ref: '#/components/schemas/Livrable'
 *       400:
 *         description: DonnÃ©es invalides
 *       404:
 *         description: Livrable non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.put("/:id", livrableController.updateLivrable);

/**
 * @swagger
 * /api/technique/livrables/{id}:
 *   delete:
 *     summary: Supprime un livrable
 *     description: Supprime un livrable existant par son ID
 *     tags: [Livrables]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du livrable Ã  supprimer
 *     responses:
 *       200:
 *         description: Livrable supprimÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Livrable supprimÃ© avec succÃ¨s
 *       404:
 *         description: Livrable non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id", livrableController.deleteLivrable);

/**
 * @swagger
 * /api/technique/livrables/{id}/documents:
 *   post:
 *     summary: Ajoute un document Ã  un livrable
 *     description: TÃ©lÃ©charge et associe un document Ã  un livrable existant
 *     tags: [Livrables]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du livrable
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - document
 *               - libelle_document
 *             properties:
 *               document:
 *                 type: string
 *                 format: binary
 *                 description: Fichier Ã  tÃ©lÃ©charger
 *               libelle_document:
 *                 type: string
 *                 description: Nom du document
 *               classification_document:
 *                 type: string
 *                 description: Classification du document
 *               date_document:
 *                 type: string
 *                 description: Date du document
 *               id_nature_document:
 *                 type: integer
 *                 description: ID de la nature du document
 *     responses:
 *       201:
 *         description: Document ajoutÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 document:
 *                   $ref: '#/components/schemas/Document'
 *       400:
 *         description: DonnÃ©es invalides ou erreur de tÃ©lÃ©chargement
 *       404:
 *         description: Livrable non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post("/:id/documents",
  (req, res, next) => {
    try {
      // DÃ©finir et crÃ©er le chemin avant l'upload
      const uploadPath = path.join(process.cwd(), UPLOAD_PATHS.LIVRABLES);
      
      // CrÃ©er le dossier s'il n'existe pas
      if (!fs.existsSync(uploadPath)) {
        fs.mkdirSync(uploadPath, { recursive: true });
      }
      
      req.uploadPath = uploadPath;
      next();
    } catch (error) {
      next(error);
    }
  },
  uploadMiddleware.single("document"),
  livrableController.addDocumentToLivrable
);

/**
 * @swagger
 * /api/technique/livrables/{id}/documents:
 *   get:
 *     summary: RÃ©cupÃ¨re les documents d'un livrable
 *     description: Retourne la liste des documents associÃ©s Ã  un livrable spÃ©cifique
 *     tags: [Livrables]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du livrable
 *     responses:
 *       200:
 *         description: Liste des documents rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 documents:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Document'
 *       404:
 *         description: Livrable non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id/documents", livrableController.getLivrableDocuments);

/**
 * @swagger
 * /api/technique/livrables/{id}/documents/{documentId}:
 *   delete:
 *     summary: Supprime un document d'un livrable
 *     description: Supprime un document associÃ© Ã  un livrable spÃ©cifique
 *     tags: [Livrables]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du livrable
 *       - in: path
 *         name: documentId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du document Ã  supprimer
 *     responses:
 *       200:
 *         description: Document supprimÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Document supprimÃ© avec succÃ¨s
 *       404:
 *         description: Livrable ou document non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id/documents/:documentId", livrableController.deleteDocument);

/**
 * @swagger
 * /api/technique/livrables/projet/{projetId}:
 *   get:
 *     summary: RÃ©cupÃ¨re les livrables associÃ©s Ã  un projet
 *     description: Retourne la liste des livrables appartenant Ã  un projet spÃ©cifique
 *     tags: [Livrables]
 *     parameters:
 *       - in: path
 *         name: projetId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *     responses:
 *       200:
 *         description: Liste des livrables du projet rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 livrables:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Livrable'
 *       404:
 *         description: Projet non trouvÃ© ou aucun livrable associÃ©
 *       500:
 *         description: Erreur serveur
 */
router.get("/projet/:projetId", livrableController.getLivrablesByProjet);

module.exports = router;


================================================
File: modules/technique/routes/projets.routes.js
================================================
const express = require("express");
const router = express.Router();
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const projetsController = require("../controllers/projets.controller");
const uploadMiddleware = require("../../utils/middleware/uploadMiddleware");

// DÃ©finition des chemins de stockage
const UPLOAD_PATHS = {
  PROJETS: 'media/documents/technique/projets'
};

/**
 * @swagger
 * components:
 *   schemas:
 *     Projet:
 *       type: object
 *       properties:
 *         id_projet:
 *           type: integer
 *           description: ID unique du projet
 *         nom_projet:
 *           type: string
 *           description: Nom du projet
 *         type_projet:
 *           type: string
 *           description: Type de projet
 *         devis_estimatif:
 *           type: number
 *           format: float
 *           description: Montant estimatif du projet
 *         date_debut:
 *           type: string
 *           format: date
 *           description: Date de dÃ©but du projet
 *         date_fin:
 *           type: string
 *           format: date
 *           description: Date de fin prÃ©vue du projet
 *         duree_prevu_projet:
 *           type: string
 *           description: DurÃ©e prÃ©vue du projet
 *         description_projet:
 *           type: string
 *           description: Description dÃ©taillÃ©e du projet
 *         etat:
 *           type: string
 *           description: Ã‰tat actuel du projet (En cours, TerminÃ©, etc.)
 *         lieu:
 *           type: string
 *           description: Lieu de rÃ©alisation du projet
 *         responsable:
 *           type: string
 *           description: Responsable du projet
 *         site:
 *           type: string
 *           description: Site du projet
 *         id_famille:
 *           type: integer
 *           description: ID de la famille du projet
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date de crÃ©ation de l'enregistrement
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date de derniÃ¨re mise Ã  jour
 *     Document:
 *       type: object
 *       properties:
 *         id_documents:
 *           type: integer
 *           description: ID unique du document
 *         libelle_document:
 *           type: string
 *           description: LibellÃ© du document
 *         classification_document:
 *           type: string
 *           description: Classification du document
 *         date_document:
 *           type: string
 *           description: Date du document
 *         lien_document:
 *           type: string
 *           description: Chemin d'accÃ¨s au document
 *         etat_document:
 *           type: string
 *           description: Ã‰tat du document (Actif, ArchivÃ©)
 *     Partenaire:
 *       type: object
 *       properties:
 *         id_partenaire:
 *           type: integer
 *           description: ID unique du partenaire
 *         nom_partenaire:
 *           type: string
 *           description: Nom du partenaire
 *         telephone_partenaire:
 *           type: string
 *           description: NumÃ©ro de tÃ©lÃ©phone du partenaire
 *         email_partenaire:
 *           type: string
 *           description: Email du partenaire
 *         specialite:
 *           type: string
 *           description: SpÃ©cialitÃ© du partenaire
 *         localisation:
 *           type: string
 *           description: Localisation du partenaire
 *         type_partenaire:
 *           type: string
 *           description: Type de partenaire
 *     Livrable:
 *       type: object
 *       properties:
 *         id_livrable:
 *           type: integer
 *           description: ID unique du livrable
 *         libelle_livrable:
 *           type: string
 *           description: LibellÃ© du livrable
 *         date:
 *           type: string
 *           format: date
 *           description: Date du livrable
 *         realisations:
 *           type: string
 *           description: RÃ©alisations liÃ©es au livrable
 *         reserves:
 *           type: string
 *           description: RÃ©serves Ã©mises sur le livrable
 *         approbation:
 *           type: string
 *           description: Approbation du livrable
 *         recommandation:
 *           type: string
 *           description: Recommandations pour le livrable
 *         documents:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/Document'
 *           description: Documents associÃ©s au livrable
 */

/**
 * @swagger
 * /api/technique/projets:
 *   get:
 *     summary: Liste tous les projets
 *     description: RÃ©cupÃ¨re la liste complÃ¨te des projets avec leurs informations
 *     tags: [Projets]
 *     responses:
 *       200:
 *         description: Liste des projets rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 projets:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Projet'
 *       500:
 *         description: Erreur serveur
 */
router.get("/", projetsController.getAllProjets);

/**
 * @swagger
 * /api/technique/projets/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re un projet par son ID
 *     description: Retourne les dÃ©tails d'un projet spÃ©cifique
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *     responses:
 *       200:
 *         description: DÃ©tails du projet rÃ©cupÃ©rÃ©s avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 projet:
 *                   $ref: '#/components/schemas/Projet'
 *       404:
 *         description: Projet non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id", projetsController.getProjetById);

/**
 * @swagger
 * /api/technique/projets:
 *   post:
 *     summary: CrÃ©e un nouveau projet
 *     description: Enregistre un nouveau projet technique
 *     tags: [Projets]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - nom_projet
 *               - type_projet
 *             properties:
 *               nom_projet:
 *                 type: string
 *                 description: Nom du projet
 *               type_projet:
 *                 type: string
 *                 description: Type de projet
 *               devis_estimatif:
 *                 type: number
 *                 format: float
 *                 description: Montant estimatif du projet
 *               date_debut:
 *                 type: string
 *                 format: date
 *                 description: Date de dÃ©but du projet
 *               date_fin:
 *                 type: string
 *                 format: date
 *                 description: Date de fin prÃ©vue du projet
 *               duree_prevu_projet:
 *                 type: string
 *                 description: DurÃ©e prÃ©vue du projet
 *               description_projet:
 *                 type: string
 *                 description: Description dÃ©taillÃ©e du projet
 *               etat:
 *                 type: string
 *                 description: Ã‰tat actuel du projet
 *               lieu:
 *                 type: string
 *                 description: Lieu de rÃ©alisation du projet
 *               responsable:
 *                 type: string
 *                 description: Responsable du projet
 *               site:
 *                 type: string
 *                 description: Site du projet
 *               id_famille:
 *                 type: integer
 *                 description: ID de la famille du projet
 *     responses:
 *       201:
 *         description: Projet crÃ©Ã© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 projet:
 *                   $ref: '#/components/schemas/Projet'
 *       400:
 *         description: DonnÃ©es invalides
 *       500:
 *         description: Erreur serveur
 */
router.post("/", projetsController.createProjet);

/**
 * @swagger
 * /api/technique/projets/{id}:
 *   put:
 *     summary: Met Ã  jour un projet
 *     description: Modifie les informations d'un projet existant
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet Ã  modifier
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               nom_projet:
 *                 type: string
 *                 description: Nom du projet
 *               type_projet:
 *                 type: string
 *                 description: Type de projet
 *               devis_estimatif:
 *                 type: number
 *                 format: float
 *                 description: Montant estimatif du projet
 *               date_debut:
 *                 type: string
 *                 format: date
 *                 description: Date de dÃ©but du projet
 *               date_fin:
 *                 type: string
 *                 format: date
 *                 description: Date de fin prÃ©vue du projet
 *               duree_prevu_projet:
 *                 type: string
 *                 description: DurÃ©e prÃ©vue du projet
 *               description_projet:
 *                 type: string
 *                 description: Description dÃ©taillÃ©e du projet
 *               etat:
 *                 type: string
 *                 description: Ã‰tat actuel du projet
 *               lieu:
 *                 type: string
 *                 description: Lieu de rÃ©alisation du projet
 *               responsable:
 *                 type: string
 *                 description: Responsable du projet
 *               site:
 *                 type: string
 *                 description: Site du projet
 *               id_famille:
 *                 type: integer
 *                 description: ID de la famille du projet
 *     responses:
 *       200:
 *         description: Projet mis Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 projet:
 *                   $ref: '#/components/schemas/Projet'
 *       404:
 *         description: Projet non trouvÃ©
 *       400:
 *         description: DonnÃ©es invalides
 *       500:
 *         description: Erreur serveur
 */
router.put("/:id", projetsController.updateProjet);

/**
 * @swagger
 * /api/technique/projets/{id}:
 *   delete:
 *     summary: Supprime un projet
 *     description: Supprime un projet existant par son ID
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet Ã  supprimer
 *     responses:
 *       200:
 *         description: Projet supprimÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Projet supprimÃ© avec succÃ¨s
 *       404:
 *         description: Projet non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id", projetsController.deleteProjet);

/**
 * @swagger
 * /api/technique/projets/{id}/documents:
 *   post:
 *     summary: Ajoute un document Ã  un projet
 *     description: TÃ©lÃ©charge et associe un document Ã  un projet existant
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - document
 *               - libelle_document
 *             properties:
 *               document:
 *                 type: string
 *                 format: binary
 *                 description: Fichier Ã  tÃ©lÃ©charger
 *               libelle_document:
 *                 type: string
 *                 description: Nom du document
 *               classification_document:
 *                 type: string
 *                 description: Classification du document
 *               date_document:
 *                 type: string
 *                 description: Date du document
 *               id_nature_document:
 *                 type: integer
 *                 description: ID de la nature du document
 *     responses:
 *       201:
 *         description: Document ajoutÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 document:
 *                   $ref: '#/components/schemas/Document'
 *       400:
 *         description: DonnÃ©es invalides ou erreur de tÃ©lÃ©chargement
 *       404:
 *         description: Projet non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post("/:id/documents",
  (req, res, next) => {
    try {
      // DÃ©finir et crÃ©er le chemin avant l'upload
      const uploadPath = path.join(process.cwd(), UPLOAD_PATHS.PROJETS);
      
      // CrÃ©er le dossier s'il n'existe pas
      if (!fs.existsSync(uploadPath)) {
        fs.mkdirSync(uploadPath, { recursive: true });
      }
      
      req.uploadPath = uploadPath;
      next();
    } catch (error) {
      next(error);
    }
  },
  uploadMiddleware.single("document"),
  projetsController.addDocumentToProjet
);

/**
 * @swagger
 * /api/technique/projets/{id}/documents:
 *   get:
 *     summary: RÃ©cupÃ¨re les documents d'un projet
 *     description: Retourne la liste des documents associÃ©s Ã  un projet spÃ©cifique
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *     responses:
 *       200:
 *         description: Liste des documents rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 documents:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Document'
 *       404:
 *         description: Projet non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id/documents", projetsController.getProjetDocuments);

/**
 * @swagger
 * /api/technique/projets/{id}/documents/{documentId}:
 *   delete:
 *     summary: Supprime un document d'un projet
 *     description: Supprime un document associÃ© Ã  un projet spÃ©cifique
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *       - in: path
 *         name: documentId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du document Ã  supprimer
 *     responses:
 *       200:
 *         description: Document supprimÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Document supprimÃ© avec succÃ¨s
 *       404:
 *         description: Projet ou document non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id/documents/:documentId", projetsController.deleteDocument);

/**
 * @swagger
 * /api/technique/projets/{id}/partenaires:
 *   post:
 *     summary: Ajoute un partenaire Ã  un projet
 *     description: Associe un partenaire Ã  un projet existant
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id_partenaire
 *             properties:
 *               id_partenaire:
 *                 type: integer
 *                 description: ID du partenaire Ã  associer
 *     responses:
 *       201:
 *         description: Partenaire ajoutÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Partenaire ajoutÃ© au projet avec succÃ¨s
 *       400:
 *         description: DonnÃ©es invalides ou association dÃ©jÃ  existante
 *       404:
 *         description: Projet ou partenaire non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post("/:id/partenaires", projetsController.addPartenaireToProjet);

/**
 * @swagger
 * /api/technique/projets/{id}/partenaires/{partenaireId}:
 *   delete:
 *     summary: Retire un partenaire d'un projet
 *     description: Dissocie un partenaire d'un projet existant
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *       - in: path
 *         name: partenaireId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du partenaire Ã  retirer
 *     responses:
 *       200:
 *         description: Partenaire retirÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Partenaire retirÃ© du projet avec succÃ¨s
 *       404:
 *         description: Projet, partenaire ou association non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id/partenaires/:partenaireId", projetsController.removePartenaireFromProjet);

/**
 * @swagger
 * /api/technique/projets/{id}/partenaires:
 *   get:
 *     summary: RÃ©cupÃ¨re les partenaires d'un projet
 *     description: Retourne la liste des partenaires associÃ©s Ã  un projet spÃ©cifique
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *     responses:
 *       200:
 *         description: Liste des partenaires rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 partenaires:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Partenaire'
 *       404:
 *         description: Projet non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id/partenaires", projetsController.getProjetPartenaires);

/**
 * @swagger
 * /api/technique/projets/{id}/livrables-with-documents:
 *   get:
 *     summary: RÃ©cupÃ¨re les livrables avec documents d'un projet
 *     description: Retourne la liste des livrables avec leurs documents associÃ©s pour un projet spÃ©cifique
 *     tags: [Projets]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *     responses:
 *       200:
 *         description: Liste des livrables avec documents rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 livrables:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Livrable'
 *       404:
 *         description: Projet non trouvÃ© ou aucun livrable disponible
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id/livrables-with-documents", projetsController.getProjetLivrablesWithDocuments);

module.exports = router;



================================================
File: modules/technique/routes/taches.routes.js
================================================
const express = require("express");
const router = express.Router();
const tachesController = require("../controllers/taches.controller");

/**
 * @swagger
 * components:
 *   schemas:
 *     Tache:
 *       type: object
 *       properties:
 *         id_tache:
 *           type: integer
 *           description: ID unique de la tÃ¢che
 *         nom_tache:
 *           type: string
 *           description: Nom de la tÃ¢che
 *         desc_tache:
 *           type: string
 *           description: Description dÃ©taillÃ©e de la tÃ¢che
 *         statut:
 *           type: string
 *           description: Statut actuel de la tÃ¢che (Ã€ faire, En cours, TerminÃ©e, etc.)
 *         date_debut:
 *           type: string
 *           format: date
 *           description: Date de dÃ©but de la tÃ¢che
 *         date_fin:
 *           type: string
 *           format: date
 *           description: Date de fin prÃ©vue/rÃ©elle de la tÃ¢che
 *         priorite:
 *           type: string
 *           description: Niveau de prioritÃ© de la tÃ¢che (Basse, Moyenne, Haute, etc.)
 *         id_projet:
 *           type: integer
 *           description: ID du projet auquel la tÃ¢che est rattachÃ©e
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date de crÃ©ation de l'enregistrement
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date de derniÃ¨re mise Ã  jour
 *     Employe:
 *       type: object
 *       properties:
 *         id_employes:
 *           type: integer
 *           description: ID unique de l'employÃ©
 *         nom_employes:
 *           type: string
 *           description: Nom de l'employÃ©
 *         prenom_employes:
 *           type: string
 *           description: PrÃ©nom de l'employÃ©
 *         email_employes:
 *           type: string
 *           description: Email de l'employÃ©
 *         contact_employes:
 *           type: string
 *           description: NumÃ©ro de contact de l'employÃ©
 *         status_employes:
 *           type: string
 *           description: Statut de l'employÃ©
 *         fonction:
 *           type: string
 *           description: Fonction/poste de l'employÃ©
 */

/**
 * @swagger
 * /api/technique/taches:
 *   get:
 *     summary: Liste toutes les tÃ¢ches
 *     description: RÃ©cupÃ¨re la liste complÃ¨te des tÃ¢ches avec leurs informations
 *     tags: [TÃ¢ches]
 *     responses:
 *       200:
 *         description: Liste des tÃ¢ches rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 taches:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Tache'
 *       500:
 *         description: Erreur serveur
 */
router.get("/", tachesController.getAllTaches);

/**
 * @swagger
 * /api/technique/taches/{id}:
 *   get:
 *     summary: RÃ©cupÃ¨re une tÃ¢che par son ID
 *     description: Retourne les dÃ©tails d'une tÃ¢che spÃ©cifique
 *     tags: [TÃ¢ches]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la tÃ¢che
 *     responses:
 *       200:
 *         description: DÃ©tails de la tÃ¢che rÃ©cupÃ©rÃ©s avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 tache:
 *                   $ref: '#/components/schemas/Tache'
 *       404:
 *         description: TÃ¢che non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id", tachesController.getTacheById);

/**
 * @swagger
 * /api/technique/taches:
 *   post:
 *     summary: CrÃ©e une nouvelle tÃ¢che
 *     description: Enregistre une nouvelle tÃ¢che dans le systÃ¨me
 *     tags: [TÃ¢ches]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - nom_tache
 *               - id_projet
 *             properties:
 *               nom_tache:
 *                 type: string
 *                 description: Nom de la tÃ¢che
 *               desc_tache:
 *                 type: string
 *                 description: Description dÃ©taillÃ©e de la tÃ¢che
 *               statut:
 *                 type: string
 *                 description: Statut de la tÃ¢che
 *                 enum: [Ã€ faire, En cours, TerminÃ©e, En attente, AnnulÃ©e]
 *               date_debut:
 *                 type: string
 *                 format: date
 *                 description: Date de dÃ©but de la tÃ¢che (YYYY-MM-DD)
 *               date_fin:
 *                 type: string
 *                 format: date
 *                 description: Date de fin prÃ©vue de la tÃ¢che (YYYY-MM-DD)
 *               priorite:
 *                 type: string
 *                 description: Niveau de prioritÃ© de la tÃ¢che
 *                 enum: [Basse, Moyenne, Haute, Urgente]
 *               id_projet:
 *                 type: integer
 *                 description: ID du projet auquel la tÃ¢che est rattachÃ©e
 *     responses:
 *       201:
 *         description: TÃ¢che crÃ©Ã©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 tache:
 *                   $ref: '#/components/schemas/Tache'
 *       400:
 *         description: DonnÃ©es invalides
 *       404:
 *         description: Projet non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post("/", tachesController.createTache);

/**
 * @swagger
 * /api/technique/taches/{id}:
 *   put:
 *     summary: Met Ã  jour une tÃ¢che
 *     description: Modifie les informations d'une tÃ¢che existante
 *     tags: [TÃ¢ches]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la tÃ¢che Ã  modifier
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               nom_tache:
 *                 type: string
 *                 description: Nom de la tÃ¢che
 *               desc_tache:
 *                 type: string
 *                 description: Description dÃ©taillÃ©e de la tÃ¢che
 *               statut:
 *                 type: string
 *                 description: Statut de la tÃ¢che
 *                 enum: [Ã€ faire, En cours, TerminÃ©e, En attente, AnnulÃ©e]
 *               date_debut:
 *                 type: string
 *                 format: date
 *                 description: Date de dÃ©but de la tÃ¢che (YYYY-MM-DD)
 *               date_fin:
 *                 type: string
 *                 format: date
 *                 description: Date de fin prÃ©vue de la tÃ¢che (YYYY-MM-DD)
 *               priorite:
 *                 type: string
 *                 description: Niveau de prioritÃ© de la tÃ¢che
 *                 enum: [Basse, Moyenne, Haute, Urgente]
 *               id_projet:
 *                 type: integer
 *                 description: ID du projet auquel la tÃ¢che est rattachÃ©e
 *     responses:
 *       200:
 *         description: TÃ¢che mise Ã  jour avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 tache:
 *                   $ref: '#/components/schemas/Tache'
 *       400:
 *         description: DonnÃ©es invalides
 *       404:
 *         description: TÃ¢che non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.put("/:id", tachesController.updateTache);

/**
 * @swagger
 * /api/technique/taches/{id}:
 *   delete:
 *     summary: Supprime une tÃ¢che
 *     description: Supprime une tÃ¢che existante par son ID
 *     tags: [TÃ¢ches]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la tÃ¢che Ã  supprimer
 *     responses:
 *       200:
 *         description: TÃ¢che supprimÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: TÃ¢che supprimÃ©e avec succÃ¨s
 *       404:
 *         description: TÃ¢che non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id", tachesController.deleteTache);

/**
 * @swagger
 * /api/technique/taches/{id}/employes:
 *   post:
 *     summary: Assigne un employÃ© Ã  une tÃ¢che
 *     description: Associe un employÃ© Ã  une tÃ¢che existante
 *     tags: [TÃ¢ches]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la tÃ¢che
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id_employes
 *             properties:
 *               id_employes:
 *                 type: integer
 *                 description: ID de l'employÃ© Ã  associer
 *     responses:
 *       201:
 *         description: EmployÃ© assignÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: EmployÃ© assignÃ© Ã  la tÃ¢che avec succÃ¨s
 *       400:
 *         description: DonnÃ©es invalides ou association dÃ©jÃ  existante
 *       404:
 *         description: TÃ¢che ou employÃ© non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.post("/:id/employes", tachesController.addEmployeToTache);

/**
 * @swagger
 * /api/technique/taches/{id}/employes/{employeId}:
 *   delete:
 *     summary: Retire un employÃ© d'une tÃ¢che
 *     description: Dissocie un employÃ© d'une tÃ¢che existante
 *     tags: [TÃ¢ches]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la tÃ¢che
 *       - in: path
 *         name: employeId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de l'employÃ© Ã  retirer
 *     responses:
 *       200:
 *         description: EmployÃ© retirÃ© avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: EmployÃ© retirÃ© de la tÃ¢che avec succÃ¨s
 *       404:
 *         description: TÃ¢che, employÃ© ou association non trouvÃ©
 *       500:
 *         description: Erreur serveur
 */
router.delete("/:id/employes/:employeId", tachesController.removeEmployeFromTache);

/**
 * @swagger
 * /api/technique/taches/{id}/employes:
 *   get:
 *     summary: RÃ©cupÃ¨re les employÃ©s assignÃ©s Ã  une tÃ¢che
 *     description: Retourne la liste des employÃ©s associÃ©s Ã  une tÃ¢che spÃ©cifique
 *     tags: [TÃ¢ches]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la tÃ¢che
 *     responses:
 *       200:
 *         description: Liste des employÃ©s rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 employes:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Employe'
 *       404:
 *         description: TÃ¢che non trouvÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.get("/:id/employes", tachesController.getTacheEmployes);

/**
 * @swagger
 * /api/technique/taches/projet/{projetId}:
 *   get:
 *     summary: RÃ©cupÃ¨re les tÃ¢ches associÃ©es Ã  un projet
 *     description: Retourne la liste des tÃ¢ches appartenant Ã  un projet spÃ©cifique
 *     tags: [TÃ¢ches]
 *     parameters:
 *       - in: path
 *         name: projetId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID du projet
 *     responses:
 *       200:
 *         description: Liste des tÃ¢ches du projet rÃ©cupÃ©rÃ©e avec succÃ¨s
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 taches:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Tache'
 *       404:
 *         description: Projet non trouvÃ© ou aucune tÃ¢che associÃ©e
 *       500:
 *         description: Erreur serveur
 */
router.get("/projet/:projetId", tachesController.getTachesByProjet);

module.exports = router;



================================================
File: modules/technique/routes/technique.routes.js
================================================
const express = require("express");
const router = express.Router();



// Import des sous-routes
const interventionsRoutes = require("./interventions.routes");
const projetsRoutes = require("./projets.routes");
const tachesRoutes = require("./taches.routes");
const livrablesRoutes = require("./livrable.routes");

/**
 * @swagger
 * tags:
 *   - name: Projets
 *     description: Gestion des projets techniques
 *   - name: TÃ¢ches
 *     description: Gestion des tÃ¢ches liÃ©es aux projets
 *   - name: Livrables
 *     description: Gestion des livrables des projets
 *   - name: Interventions
 *     description: Gestion des interventions techniques
 * 
 * @swagger
 * components:
 *   schemas:
 *     ApiResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *           description: Indique si la requÃªte a rÃ©ussi
 *         message:
 *           type: string
 *           description: Message dÃ©crivant le rÃ©sultat de l'opÃ©ration
 */

/**
 * @swagger
 * /api/technique/projets:
 *   get:
 *     summary: API de gestion des projets
 *     description: Point d'entrÃ©e pour toutes les opÃ©rations liÃ©es aux projets
 *     tags: [Projets]
 */
router.use("/projets", projetsRoutes);

/**
 * @swagger
 * /api/technique/taches:
 *   get:
 *     summary: API de gestion des tÃ¢ches
 *     description: Point d'entrÃ©e pour toutes les opÃ©rations liÃ©es aux tÃ¢ches des projets
 *     tags: [TÃ¢ches]
 */
router.use("/taches", tachesRoutes);

/**
 * @swagger
 * /api/technique/livrables:
 *   get:
 *     summary: API de gestion des livrables
 *     description: Point d'entrÃ©e pour toutes les opÃ©rations liÃ©es aux livrables des projets
 *     tags: [Livrables]
 */
router.use("/livrables", livrablesRoutes);

/**
 * @swagger
 * /api/technique/interventions:
 *   get:
 *     summary: API de gestion des interventions
 *     description: Point d'entrÃ©e pour toutes les opÃ©rations liÃ©es aux interventions techniques
 *     tags: [Interventions]
 */
router.use("/interventions", interventionsRoutes);

module.exports = router;



================================================
File: modules/technique/services/interventions.service.js
================================================
const { db } = require('../../../core/database/config');
const { interventions, intervention_employes, employes, intervention_taches, documents } = require("../../../core/database/models");

const { eq, and } = require("drizzle-orm");
const fs = require('fs').promises;  // Ajoutez cette importation
const path = require('path');       // Ajoutez cette importation

const interventionsService = {
  getAllInterventions: async () => {
    return await db.select().from(interventions);
  },

  getInterventionById: async (id) => {
    const result = await db
      .select()
      .from(interventions)
      .where(eq(interventions.id_intervention, id));
    return result.length > 0 ? result[0] : null;
  },

  createIntervention: async (interventionData) => {
    const result = await db
      .insert(interventions)
      .values(interventionData)
      .returning();
    return result[0];
  },

  updateIntervention: async (id, interventionData) => {
    const result = await db
      .update(interventions)
      .set({
        ...interventionData,
        updated_at: new Date(),
      })
      .where(eq(interventions.id_intervention, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  },

  
  deleteIntervention: async (id) => {
    const result = await db
      .delete(interventions)
      .where(eq(interventions.id_intervention, id))
      .returning();
    return result.length > 0;
  },

 
  addDocumentToIntervention: async (documentData) => {
    const result = await db.insert(documents).values(documentData).returning();
    return result[0];
  },

  
  addEmployeToIntervention: async (interventionId, employeId) => {
    const result = await db
      .insert(intervention_employes)
      .values({
        id_intervention: interventionId,
        id_employes: employeId,
      })
      .returning();
    return result[0];
  },
  
  removeEmployeFromIntervention: async (interventionId, employeId) => {
    const result = await db
      .delete(intervention_employes)
      .where(
        and(
          eq(intervention_employes.id_intervention, interventionId),
          eq(intervention_employes.id_employes, employeId)
        )
      )
      .returning();
    return result.length > 0;
  },


  getInterventionEmployes: async (interventionId) => {
    return await db
      .select({
        id_employes: employes.id_employes,
        nom_employes: employes.nom_employes,
        prenom_employes: employes.prenom_employes,
        email_employes: employes.email_employes,
      })
      .from(intervention_employes)
      .innerJoin(
        employes,
        eq(intervention_employes.id_employes, employes.id_employes)
      )
      .where(eq(intervention_employes.id_intervention, interventionId));
  },

 
  getInterventionDocuments: async (interventionId) => {
    try {
      return await db
        .select({
          id_documents: documents.id_documents,
          libelle_document: documents.libelle_document,
          // classification_document: documents.classification_document,
          lien_document: documents.lien_document,
          etat_document: documents.etat_document,
          created_at: documents.created_at,
          updated_at: documents.updated_at
        })
        .from(documents)
        .where(eq(documents.id_intervention, interventionId));
    } catch (error) {
      throw new Error(`Erreur lors de la rÃ©cupÃ©ration des documents: ${error.message}`);
    }
  },

 
  getDocumentById: async (documentId) => {
    try {
      const result = await db
        .select()
        .from(documents)
        .where(eq(documents.id_documents, documentId));
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      throw new Error(`Erreur lors de la rÃ©cupÃ©ration du document: ${error.message}`);
    }
  },


    deleteDocument: async (documentId) => {
      try {
        // 1. RÃ©cupÃ©rer le document
        const document = await interventionsService.getDocumentById(documentId);
        
        if (!document) {
          throw new Error("Document non trouvÃ©");
        }
  
        // 2. Supprimer le fichier physique
        try {
          // Normaliser le chemin stockÃ© dans la BD
          const normalizedPath = document.lien_document.replace(/\\/g, '/');
          
          // Construire le chemin absolu
          const absolutePath = path.join(process.cwd(), normalizedPath);
          
          // VÃ©rifier si le fichier existe avant de le supprimer
          const fileExists = await fs.access(absolutePath)
            .then(() => true)
            .catch(() => false);
  
          if (fileExists) {
            await fs.unlink(absolutePath);
          }
        } catch (fileError) {
          // On continue mÃªme si la suppression du fichier Ã©choue
          // Dans un systÃ¨me de production, on pourrait vouloir enregistrer cette erreur
          // dans un systÃ¨me de journalisation plutÃ´t que de l'afficher en console
        }
  
        // 3. Supprimer l'entrÃ©e de la base de donnÃ©es
        const result = await db
          .delete(documents)
          .where(eq(documents.id_documents, documentId))
          .returning();
  
        if (result.length === 0) {
          throw new Error("Ã‰chec de la suppression en base de donnÃ©es");
        }
  
        return true;
      } catch (error) {
        throw new Error(`Erreur lors de la suppression du document: ${error.message}`);
      }
    
    }


};

module.exports = interventionsService;



================================================
File: modules/technique/services/livrable.service.js
================================================
const { db } = require('../../../core/database/config');
const { livrables, documents } = require("../../../core/database/models");
const { eq } = require("drizzle-orm");
const fs = require('fs').promises;
const path = require('path');

const livrableService = {
  getAllLivrables: async () => {
    return await db.select().from(livrables);
  },

  getLivrableById: async (id) => {
    const result = await db.select().from(livrables).where(eq(livrables.id_livrable, id));
    return result.length > 0 ? result[0] : null;
  },

  createLivrable: async (data) => {
    const [result] = await db.insert(livrables).values(data).returning();
    return result;
  },

  updateLivrable: async (id, data) => {
    const [result] = await db.update(livrables).set({ ...data, updated_at: new Date() })
      .where(eq(livrables.id_livrable, id)).returning();
    return result;
  },

  deleteLivrable: async (id) => {
    const [result] = await db.delete(livrables).where(eq(livrables.id_livrable, id)).returning();
    return result;
  },

  // Documents liÃ©s au livrable
  addDocumentToLivrable: async (documentData) => {
    const [result] = await db.insert(documents).values(documentData).returning();
    return result;
  },

  getLivrableDocuments: async (livrableId) => {
    return await db.select().from(documents).where(eq(documents.id_livrable, livrableId));
  },

  getDocumentById: async (documentId) => {
    const [result] = await db.select().from(documents).where(eq(documents.id_documents, documentId));
    return result;
  },

  deleteDocument: async (documentId) => {
    // 1. RÃ©cupÃ©rer le document
    const document = await livrableService.getDocumentById(documentId);
    if (!document) throw new Error("Document non trouvÃ©");

    // 2. Supprimer le fichier physique
    try {
      const normalizedPath = document.lien_document.replace(/\\/g, '/');
      const absolutePath = path.join(process.cwd(), normalizedPath);
      await fs.unlink(absolutePath).catch(() => {});
    } catch (e) {}

    // 3. Supprimer l'entrÃ©e en base
    const [result] = await db.delete(documents).where(eq(documents.id_documents, documentId)).returning();
    return result;
  },

  getLivrablesByProjet: async (projetId) => {
    return await db.select().from(livrables).where(eq(livrables.id_projet, projetId));
  }
};

module.exports = livrableService;


================================================
File: modules/technique/services/projets.service.js
================================================
const { db } = require('../../../core/database/config');
const { projets, partenaire_projets, documents, livrables, partenaires } = require("../../../core/database/models");
const { eq, and } = require("drizzle-orm");
const fs = require('fs').promises;  // Ajoutez cette importation
const path = require('path');       // Ajoutez cette importation

const projetsService = {
  getAllProjets: async () => {
    return await db.select().from(projets);
  },

  getProjetById: async (id) => {
    const result = await db
      .select()
      .from(projets)
      .where(eq(projets.id_projet, id));
    return result.length > 0 ? result[0] : null;
  },

  createProjet: async (projetData) => {
    const result = await db
      .insert(projets)
      .values(projetData)
      .returning();
    return result[0];
  },

  updateProjet: async (id, projetData) => {
    const result = await db
      .update(projets)
      .set({
        ...projetData,
        updated_at: new Date(),
      })
      .where(eq(projets.id_projet, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  },

  deleteProjet: async (id) => {
    const result = await db
      .delete(projets)
      .where(eq(projets.id_projet, id))
      .returning();
    return result.length > 0;
  },

  addDocumentToProjet: async (documentData) => {
    const result = await db.insert(documents).values(documentData).returning();
    return result[0];
  },

  addPartenaireToProjet: async (projetId, partenaireId) => {
    const result = await db
      .insert(partenaire_projets)
      .values({
        id_projet: projetId,
        id_partenaire: partenaireId,
      })
      .returning();
    return result[0];
  },

  removePartenaireFromProjet: async (projetId, partenaireId) => {
    const result = await db
      .delete(partenaire_projets)
      .where(
        and(
          eq(partenaire_projets.id_projet, projetId),
          eq(partenaire_projets.id_partenaire, partenaireId)
        )
      )
      .returning();
    return result.length > 0;
  },

  getProjetPartenaires: async (projetId) => {
    return await db
      .select({
        id_partenaire: partenaires.id_partenaire,
        nom_partenaire: partenaires.nom_partenaire,
        email_partenaire: partenaires.email_partenaire,
        telephone_partenaire: partenaires.telephone_partenaire,
        specialite: partenaires.specialite
      })
      .from(partenaire_projets)
      .innerJoin(
        partenaires,
        eq(partenaire_projets.id_partenaire, partenaires.id_partenaire)
      )
      .where(eq(partenaire_projets.id_projet, projetId));
  },

  getProjetLivrables: async (projetId) => {
    return await db
      .select()
      .from(livrables)
      .where(eq(livrables.id_projet, projetId));
  },

  // Ajout des nouvelles mÃ©thodes pour la gestion des documents
  getProjetDocuments: async (projetId) => {
    try {
      return await db
        .select({
          id_documents: documents.id_documents,
          libelle_document: documents.libelle_document,
          // classification_document: documents.classification_document,
          lien_document: documents.lien_document,
          etat_document: documents.etat_document,
          created_at: documents.created_at,
          updated_at: documents.updated_at
        })
        .from(documents)
        .where(eq(documents.id_projet, projetId));
    } catch (error) {
      throw new Error(`Erreur lors de la rÃ©cupÃ©ration des documents: ${error.message}`);
    }
  },

  getDocumentById: async (documentId) => {
    try {
      const result = await db
        .select()
        .from(documents)
        .where(eq(documents.id_documents, documentId));
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      throw new Error(`Erreur lors de la rÃ©cupÃ©ration du document: ${error.message}`);
    }
  },


  deleteDocument: async (documentId) => {
    try {
      // 1. RÃ©cupÃ©rer le document
      const document = await projetsService.getDocumentById(documentId);
      
      if (!document) {
        throw new Error("Document non trouvÃ©");
      }

      // 2. Supprimer le fichier physique
      try {
        // Normaliser le chemin stockÃ© dans la BD
        const normalizedPath = document.lien_document.replace(/\\/g, '/');
        
        // Construire le chemin absolu
        const absolutePath = path.join(process.cwd(), normalizedPath);
        
        // VÃ©rifier si le fichier existe avant de le supprimer
        const fileExists = await fs.access(absolutePath)
          .then(() => true)
          .catch(() => false);

        if (fileExists) {
          await fs.unlink(absolutePath);
        }
      } catch (fileError) {
        // On continue mÃªme si la suppression du fichier Ã©choue
        // Dans un systÃ¨me de production, on pourrait vouloir enregistrer cette erreur
        // dans un systÃ¨me de journalisation plutÃ´t que de l'afficher en console
      }

      // 3. Supprimer l'entrÃ©e de la base de donnÃ©es
      const result = await db
        .delete(documents)
        .where(eq(documents.id_documents, documentId))
        .returning();

      if (result.length === 0) {
        throw new Error("Ã‰chec de la suppression en base de donnÃ©es");
      }

      return true;
    } catch (error) {
      throw new Error(`Erreur lors de la suppression du document: ${error.message}`);
    }
  
  },

  getProjetLivrablesWithDocuments: async (projetId) => {
    // RÃ©cupÃ©rer tous les livrables du projet
    const livrablesList = await db
      .select()
      .from(livrables)
      .where(eq(livrables.id_projet, projetId));

    // Pour chaque livrable, rÃ©cupÃ©rer ses documents associÃ©s
    const result = [];
    for (const livrable of livrablesList) {
      const docs = await db
        .select()
        .from(documents)
        .where(eq(documents.id_livrable, livrable.id_livrable));
      result.push({
        ...livrable,
        documents: docs
      });
    }
    return result;
  }
};

module.exports = projetsService;



================================================
File: modules/technique/services/taches.service.js
================================================
const { db } = require('../../../core/database/config');
const { taches, intervention_taches, employes } = require("../../../core/database/models");
const { eq, and } = require("drizzle-orm");

const tachesService = {
  getAllTaches: async () => {
    return await db.select().from(taches);
  },

  getTacheById: async (id) => {
    const result = await db
      .select()
      .from(taches)
      .where(eq(taches.id_tache, id));
    return result.length > 0 ? result[0] : null;
  },

  createTache: async (tacheData) => {
    const result = await db
      .insert(taches)
      .values({
        ...tacheData,
        created_at: new Date(),
        updated_at: new Date(),
      })
      .returning();
    return result[0];
  },

  updateTache: async (id, tacheData) => {
    const result = await db
      .update(taches)
      .set({
        ...tacheData,
        updated_at: new Date(),
      })
      .where(eq(taches.id_tache, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  },

  deleteTache: async (id) => {
    const result = await db
      .delete(taches)
      .where(eq(taches.id_tache, id))
      .returning();
    return result.length > 0;
  },

  // Gestion des employÃ©s associÃ©s Ã  une tÃ¢che
  addEmployeToTache: async (tacheId, employeId) => {
    const result = await db
      .insert(intervention_taches)
      .values({
        id_tache: tacheId,
        id_employes: employeId,
        created_at: new Date(),
        updated_at: new Date(),
      })
      .returning();
    return result[0];
  },

  removeEmployeFromTache: async (tacheId, employeId) => {
    const result = await db
      .delete(intervention_taches)
      .where(
        and(
          eq(intervention_taches.id_tache, tacheId),
          eq(intervention_taches.id_employes, employeId)
        )
      )
      .returning();
    return result.length > 0;
  },

  getTacheEmployes: async (tacheId) => {
    return await db
      .select({
        id_employes: employes.id_employes,
        nom_employes: employes.nom_employes,
        prenom_employes: employes.prenom_employes,
        email_employes: employes.email_employes,
      })
      .from(intervention_taches)
      .innerJoin(
        employes,
        eq(intervention_taches.id_employes, employes.id_employes)
      )
      .where(eq(intervention_taches.id_tache, tacheId));
  },

  getTachesByProjet: async (projetId) => {
    return await db
      .select()
      .from(taches)
      .where(eq(taches.id_projet, projetId));
  },
};

module.exports = tachesService;



================================================
File: modules/utils/middleware/uploadMiddleware.js
================================================
/**
 * Middleware pour la gestion de l'upload de fichiers
 * Ce module configure Multer pour permettre le tÃ©lÃ©chargement de fichiers
 * dans l'application, avec des rÃ¨gles spÃ©cifiques sur les types et emplacements
 * de stockage des fichiers.
 */

const multer = require('multer');  // Importe la bibliothÃ¨que Multer pour gÃ©rer l'upload de fichiers
const path = require('path');      // Importe le module path pour manipuler les chemins de fichiers
const fs = require('fs');          // Importe le module fs (file system) pour manipuler les fichiers

/**
 * Configuration du stockage des fichiers tÃ©lÃ©chargÃ©s
 * DÃ©finit comment et oÃ¹ les fichiers seront enregistrÃ©s
 */
const storage = multer.diskStorage({
  /**
   * DÃ©termine le dossier de destination pour les fichiers tÃ©lÃ©chargÃ©s
   * @param {Object} req - La requÃªte HTTP
   * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
   * @param {Function} cb - Fonction de callback Ã  appeler avec le chemin de destination
   */
  destination: function (req, file, cb) {
    // Le chemin de destination est dÃ©fini dynamiquement dans le contrÃ´leur via req.uploadPath
    const uploadPath = req.uploadPath;
    
    // CrÃ©e le dossier de destination s'il n'existe pas dÃ©jÃ 
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    // Appelle le callback avec le chemin de destination
    cb(null, uploadPath);
  },
  
  /**
   * GÃ©nÃ¨re un nom unique pour le fichier tÃ©lÃ©chargÃ©
   * @param {Object} req - La requÃªte HTTP
   * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
   * @param {Function} cb - Fonction de callback Ã  appeler avec le nom du fichier
   */
  filename: function (req, file, cb) {
    // Ajoute un timestamp au nom du fichier pour Ã©viter les collisions
    const timestamp = Date.now();
    
    // Extrait le nom et l'extension du fichier original
    const originalName = path.parse(file.originalname);
    
    // CrÃ©e un nouveau nom avec le format: nom-original_timestamp.extension
    const newFilename = `${originalName.name}_${timestamp}${originalName.ext}`;
    
    // Appelle le callback avec le nouveau nom de fichier
    cb(null, newFilename);
  }
});

/**
 * Fonction de filtrage des types de fichiers autorisÃ©s
 * @param {Object} req - La requÃªte HTTP
 * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
 * @param {Function} cb - Fonction de callback pour accepter ou refuser le fichier
 */
const fileFilter = (req, file, cb) => {
  // Liste des types MIME autorisÃ©s pour l'upload
  const allowedMimeTypes = [
    // Images
    'image/jpeg', 'image/png', 'image/gif',
    
    // Documents PDF
    'application/pdf',
    
    // Documents Microsoft Office
    'application/msword',  // Word (.doc)
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // Word (.docx)
    'application/vnd.ms-excel', // Excel (.xls)
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // Excel (.xlsx)
    'application/vnd.ms-powerpoint', // PowerPoint (.ppt)
    'application/vnd.openxmlformats-officedocument.presentationml.presentation', // PowerPoint (.pptx)
    
    // Fichiers texte
    'text/plain',
    
    // Archives
    'application/zip',
    'application/x-rar-compressed'
  ];
  
  // VÃ©rifie si le type MIME du fichier est autorisÃ©
  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true); // Accepte le fichier
  } else {
    // Rejette le fichier avec un message d'erreur
    cb(new Error(`Type de fichier non autorisÃ©: ${file.mimetype}`), false);
  }
};

/**
 * Configuration complÃ¨te de Multer avec les options dÃ©finies
 * - storage: dÃ©finit comment et oÃ¹ stocker les fichiers
 * - fileFilter: dÃ©finit quels types de fichiers sont acceptÃ©s
 * - limits: dÃ©finit les limites pour l'upload (taille, nombre de fichiers, etc.)
 */
const upload = multer({ 
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: Infinity } // Permet des fichiers de taille illimitÃ©e
});

// Exporte le middleware configurÃ© pour Ãªtre utilisÃ© dans les routes
module.exports = upload;



================================================
File: modules/utils/middleware/uploadOriginalNameMiddleware.js
================================================
/**
 * Middleware pour la gestion des uploads de fichiers avec conservation du nom original
 * Ce middleware configure Multer spÃ©cifiquement pour les cas oÃ¹ le nom du fichier
 * original doit Ãªtre conservÃ© tel quel, sans modification.
 */

const multer = require('multer');
const path = require('path');
const fs = require('fs');

/**
 * Configuration du stockage des fichiers tÃ©lÃ©chargÃ©s avec prÃ©servation du nom d'origine
 */
const storage = multer.diskStorage({
  /**
   * DÃ©termine le dossier de destination pour les fichiers tÃ©lÃ©chargÃ©s
   * @param {Object} req - La requÃªte HTTP
   * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
   * @param {Function} cb - Fonction de callback Ã  appeler avec le chemin de destination
   */
  destination: function (req, file, cb) {
    // Le chemin de destination est dÃ©fini dynamiquement dans le contrÃ´leur via req.uploadPath
    const uploadPath = req.uploadPath;
    
    // CrÃ©e le dossier de destination s'il n'existe pas dÃ©jÃ 
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    // Appelle le callback avec le chemin de destination
    cb(null, uploadPath);
  },
  
  /**
   * Conserve le nom original du fichier
   * @param {Object} req - La requÃªte HTTP
   * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
   * @param {Function} cb - Fonction de callback Ã  appeler avec le nom du fichier
   */
  filename: function (req, file, cb) {
    // Utilise directement le nom original du fichier
    cb(null, file.originalname);
  }
});

/**
 * Fonction de filtrage des types de fichiers autorisÃ©s
 * @param {Object} req - La requÃªte HTTP
 * @param {Object} file - Informations sur le fichier tÃ©lÃ©chargÃ©
 * @param {Function} cb - Fonction de callback pour accepter ou refuser le fichier
 */
const fileFilter = (req, file, cb) => {
  // Pour les images, on limite aux formats courants
  const allowedMimeTypes = [
    // Images uniquement
    'image/jpeg', 
    'image/png', 
    'image/gif',
    'image/webp',
    'image/svg+xml'
  ];
  
  // VÃ©rifie si le type MIME du fichier est autorisÃ©
  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true); // Accepte le fichier
  } else {
    // Rejette le fichier avec un message d'erreur
    cb(new Error(`Type de fichier non autorisÃ©: ${file.mimetype}. Seules les images sont acceptÃ©es.`), false);
  }
};

/**
 * Configuration complÃ¨te de Multer avec les options dÃ©finies
 */
const upload = multer({ 
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 } // Limite Ã  5 Mo
});

// Exporte le middleware configurÃ© pour Ãªtre utilisÃ© dans les routes
module.exports = upload; 


================================================
File: .github/workflows/main.yml
================================================
# name: Build and deploy

# on:
#   push:
#     branches:
#       - dev

# jobs:
#   build-and-deploy:
#     runs-on: self-hosted
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Build and deploy
#         run: |
#           docker-compose build
#           docker-compose up -d



# name: Build and deploy

# on:
#   push:
#     branches:
#       - dev

# jobs:
#   build-and-deploy:
#     runs-on: self-hosted
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Debug environment
#         run: |
#           # Check Docker installation
#           which docker || echo "Docker binary not found"
#           which docker-compose || echo "Docker Compose binary not found"
          
#           # Check versions
#           docker --version || echo "Docker command failed"
#           docker-compose --version || echo "Docker Compose command failed"
          
#           # Check if Docker daemon is running
#           docker info || echo "Docker daemon not accessible"
          
#           # Check Docker socket
#           ls -la /var/run/docker.sock || echo "Docker socket not found at default location"
          
#           # Check user permissions
#           id
#           groups
          
#           # Check Docker group
#           getent group docker || echo "Docker group not found"

#       - name: Try alternate Docker Compose approach
#         run: |
#           # Try using Docker CLI plugin (v2 compose)
#           docker compose version || echo "Docker Compose plugin not available"
          
#           # Check Python environment
#           python3 --version
#           pip3 list | grep -E "docker|compose|urllib3|requests"

# name: Build and deploy

# on:
#   push:
#     branches:
#       - dev

# jobs:
#   build-and-deploy:
#     runs-on: self-hosted
#     if: contains(github.event.head_commit.message, '[deploy]')
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       # - name: Show commit message
#       #   run: echo "Deploying based on commit message: ${{ github.event.head_commit.message }}"

#       - name: Build and deploy
#         run: |
#           echo "Starting deployment..."
#           docker-compose build
#           docker-compose up -d
#           echo "Deployment completed!"



# name: Build and deploy

# on:
#   push:
#     branches:
#       - dev

# jobs:
#   build-and-deploy:
#     runs-on: self-hosted
#     if: contains(github.event.head_commit.message, '[deploy]')
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Build and deploy
#         env:
#           KC_HOSTNAME: ${{ secrets.KC_HOSTNAME }}
#         run: |
#           echo "KC_HOSTNAME=$KC_HOSTNAME"
#           echo "Starting deployment..."
#           docker-compose build
#           docker-compose up -d
#           echo "Deployment completed!"



name: Build and deploy

on:
  push:
    branches:
      - dev

jobs:
  build-and-deploy:
    runs-on: self-hosted
    if: contains(github.event.head_commit.message, '[deploy]')
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build and deploy
        env:
          KC_HOSTNAME: ${{ secrets.KC_HOSTNAME }}
        run: |
          echo "KC_HOSTNAME=$KC_HOSTNAME"
          echo "Starting deployment..."
          docker-compose -f docker-compose.prod.yml build
          docker-compose -f docker-compose.prod.yml up -d
          echo "Deployment completed!"


