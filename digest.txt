Directory structure:
└── backend/
    ├── README.md
    ├── Dockerfile
    ├── docker-compose.yml
    ├── drizzle.config.js
    ├── init.sql
    ├── package.json
    ├── server.js
    ├── core/
    │   ├── auth/
    │   │   ├── digest.txt
    │   │   ├── keycloak.config.js
    │   │   ├── middleware.js
    │   │   └── setupKeycloak.js
    │   ├── database/
    │   │   ├── config.js
    │   │   ├── db.config.js
    │   │   ├── migration.js
    │   │   ├── models.js
    │   │   ├── test-db.js
    │   │   └── migrations/
    │   │       ├── 0000_stale_lenny_balinger.sql
    │   │       └── meta/
    │   │           ├── 0000_snapshot.json
    │   │           └── _journal.json
    │   └── utils/
    │       └── logger.js
    ├── docs/
    ├── init-db/
    │   └── nit-multiple-dbs.sh
    ├── keycloak-setup/
    │   ├── keycloak-setup-back.js
    │   └── keycloak-setup-front.js
    └── modules/
        ├── administration/
        │   └── accounting/
        │       ├── controllers/
        │       │   ├── accounting.controller.js
        │       │   └── partner.controller.js
        │       └── routes/
        │           ├── accounting.routes.js
        │           └── partner.route.js
        ├── clients/
        │   ├── controllers/
        │   │   └── clients.controller.js
        │   ├── routes/
        │   │   └── clients.routes.js
        │   └── services/
        ├── dashboard/
        │   ├── controllers/
        │   │   └── dashboard.controller.js
        │   ├── routes/
        │   │   └── dashboard.routes.js
        │   ├── services/
        │   └── tests/
        ├── interventions/
        │   ├── controllers/
        │   │   └── interventions.controller.js
        │   ├── routes/
        │   │   └── interventions.routes.js
        │   ├── services/
        │   │   └── interventions.service.js
        │   └── tests/
        │       └── interventions.mock.js
        ├── projects/
        │   ├── controllers/
        │   │   └── projects.controller.js
        │   ├── models/
        │   │   └── projects.model.js
        │   ├── routes/
        │   │   └── projects.routes.js
        │   └── services/
        ├── stocks/
        │   ├── controllers/
        │   │   ├── categorie.controller.js
        │   │   ├── entite.controller.js
        │   │   ├── famille.controller.js
        │   │   ├── marque.controller.js
        │   │   ├── modele.controller.js
        │   │   └── stocks.controller.js
        │   ├── routes/
        │   │   ├── categorie.routes.js
        │   │   ├── entite.routes.js
        │   │   ├── famille.routes.js
        │   │   ├── marque.routes.js
        │   │   ├── modele.route.js
        │   │   └── stocks.routes.js
        │   ├── services/
        │   │   ├── categorie.service.js
        │   │   ├── entite.service.js
        │   │   ├── famille.service.js
        │   │   ├── marque.service.js
        │   │   ├── modele.service.js
        │   │   └── stocks.service.js
        │   ├── tests/
        │   │   └── stocks.mock.js
        │   └── utils/
        │       └── drizzle-wrapper.js
        └── users/
            ├── digest.txt
            ├── controllers/
            │   ├── sync.controller.js
            │   └── users.controller.js
            ├── routes/
            │   └── users.routes.js
            ├── services/
            │   └── users.service.js
            └── tests/

================================================
File: README.md
================================================
[Non-text file]


================================================
File: Dockerfile
================================================
# Ã‰tape 1 : Builder les dÃ©pendances
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev  # Installe uniquement les dÃ©pendances de production

# Ã‰tape 2 : Image finale
FROM node:18-alpine

WORKDIR /app

# Copie des dÃ©pendances et du code
COPY --from=builder /app/node_modules ./node_modules
COPY . .

# SÃ©curitÃ©
RUN chown -R node:node /app \
    && apk add --no-cache tini  # Pour gÃ©rer correctement les signaux
USER node

# Port exposÃ© (doit correspondre Ã  votre .env)
EXPOSE 2000

# Point d'entrÃ©e avec Tini pour Ã©viter les zombies
ENTRYPOINT ["/sbin/tini", "--"]

# Commande de dÃ©marrage (utilise la variable PORT depuis .env)
CMD node server.js


================================================
File: docker-compose.yml
================================================
# # # # # services:
# # # # #   app:
# # # # #     build: .
# # # # #     ports:
# # # # #       - "3000:3000"
# # # # #     environment:
# # # # #       NODE_ENV: production
# # # # #       DB_HOST: postgres
# # # # #       KEYCLOAK_URL: http://keycloak:8080
# # # # #     depends_on:
# # # # #       - postgres
# # # # #       - keycloak
# # # # #     networks:
# # # # #       - backend
# # # # #   keycloak:
# # # # #     image: quay.io/keycloak/keycloak:26.1.4
# # # # #     container_name: keycloak
# # # # #     environment:
# # # # #       KC_BOOTSTRAP_ADMIN_USERNAME: admin
# # # # #       KC_BOOTSTRAP_ADMIN_PASSWORD: admin
# # # # #       KEYCLOAK_ADMIN: admin
# # # # #       KEYCLOAK_ADMIN_PASSWORD: admin
# # # # #       KC_HOSTNAME: localhost
# # # # #       KC_HTTP_ENABLED: "true"
# # # # #       KC_PROXY: edge
# # # # #       KC_DB: postgres
# # # # #       KC_DB_URL: jdbc:postgresql://postgres:5432/${DB_NAME:-dcat_db}
# # # # #       KC_DB_USERNAME: ${DB_USER:-dcat_user}
# # # # #       KC_DB_PASSWORD: ${DB_PASSWORD:-dcat_password}
# # # # #     ports:
# # # # #       - "8080:8080"
# # # # #     volumes:
# # # # #       - ./keycloak-setup:/opt/keycloak/data/import
# # # # #     depends_on:
# # # # #       postgres:
# # # # #         condition: service_healthy
# # # # #     command: 
# # # # #       - start-dev
# # # # #       - --import-realm
# # # # #     networks:
# # # # #       - dcat_network

# # # # #   postgres:
# # # # #     image: postgres:15-alpine
# # # # #     container_name: dcat_postgres
# # # # #     environment:
# # # # #       POSTGRES_DB: ${DB_NAME:-dcat_db}
# # # # #       POSTGRES_USER: ${DB_USER:-dcat_user}
# # # # #       POSTGRES_PASSWORD: ${DB_PASSWORD:-dcat_password}
# # # # #     volumes:
# # # # #       - postgres_data:/var/lib/postgresql/data
# # # # #       - ./init-db:/docker-entrypoint-initdb.d
# # # # #     ports:
# # # # #       - "${DB_PORT:-5432}:5432"
# # # # #     networks:
# # # # #       - dcat_network
# # # # #     healthcheck:
# # # # #       test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-dcat_user} -d ${DB_NAME:-dcat_db}"]
# # # # #       interval: 5s
# # # # #       timeout: 5s
# # # # #       retries: 5

# # # # # networks:
# # # # #   dcat_network:
# # # # #     driver: bridge

# # # # # volumes:
# # # # #   postgres_data:

# # # #   # api:
# # # #   #   build: .
# # # #   #   container_name: api
# # # #   #   environment:
# # # #   #     - NODE_ENV=development
# # # #   #     - KEYCLOAK_URL=http://keycloak:8080
# # # #   #   ports:
# # # #   #     - "3000:3000"
# # # #   #   volumes:
# # # #   #     - .:/app
# # # #   #     - /app/node_modules
# # # #   #   depends_on:
# # # #   #     - keycloak
# # # #   #   restart: unless-stopped



# # # # version: '3.8'

# # # # services:
# # # #   app:
# # # #     build: .
# # # #     container_name: dcat_backend
# # # #     ports:
# # # #       - "${PORT:-2000}:${PORT:-2000}"  # Utilise le PORT depuis .env
# # # #     env_file:
# # # #       - .env  # Charge toutes les variables depuis .env
# # # #     environment:
# # # #       NODE_ENV: ${NODE_ENV:-production}
# # # #       DB_HOST: postgres  # Nom du service, pas localhost
# # # #       # KEYCLOAK_URL: http://keycloak:8080  # Communication interne entre containers
# # # #     depends_on:
# # # #       - postgres
# # # #       - keycloak
# # # #     networks:
# # # #       - dcat_network

# # # #   keycloak:
# # # #     image: quay.io/keycloak/keycloak:26.1.4
# # # #     container_name: keycloak
# # # #     env_file:
# # # #       - .env  # Partage les mÃªmes variables
# # # #     environment:
# # # #       KC_BOOTSTRAP_ADMIN_USERNAME: admin
# # # #       KC_BOOTSTRAP_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin}  # Ã€ sÃ©curiser en prod
# # # #       KC_HOSTNAME: localhost
# # # #       KC_HTTP_ENABLED: "true"
# # # #       KC_PROXY: edge
# # # #       KC_DB: postgres
# # # #       KC_DB_URL: jdbc:postgresql://postgres:5432/${DB_NAME:-dcat_db}
# # # #       KC_DB_USERNAME: ${DB_USER:-dcat_user}
# # # #       KC_DB_PASSWORD: ${DB_PASSWORD:-dcat_password}
# # # #       KEYCLOAK_ADMIN: admin
# # # #       KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin}
# # # #     ports:
# # # #       - "8080:8080"  # Expose Keycloak sur le port standard
# # # #     volumes:
# # # #       - ./keycloak-setup:/opt/keycloak/data/import
# # # #     depends_on:
# # # #       postgres:
# # # #         condition: service_healthy
# # # #     command: 
# # # #       - start-dev
# # # #       - --import-realm
# # # #     networks:
# # # #       - dcat_network

# # # #   postgres:
# # # #     image: postgres:15-alpine
# # # #     container_name: dcat_postgres
# # # #     env_file:
# # # #       - .env  # Utilise les variables DB_* depuis .env
# # # #     environment:
# # # #       POSTGRES_DB: ${DB_NAME:-dcat_db}
# # # #       POSTGRES_USER: ${DB_USER:-dcat_user}
# # # #       POSTGRES_PASSWORD: ${DB_PASSWORD:-dcat_password}
# # # #     volumes:
# # # #       - postgres_data:/var/lib/postgresql/data
# # # #       - ./init-db:/docker-entrypoint-initdb.d
# # # #     ports:
# # # #       - "${DB_PORT:-5432}:5432"
# # # #     networks:
# # # #       - dcat_network
# # # #     healthcheck:
# # # #       test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-dcat_user} -d ${DB_NAME:-dcat_db}"]
# # # #       interval: 5s
# # # #       timeout: 5s
# # # #       retries: 5

# # # # networks:
# # # #   dcat_network:
# # # #     driver: bridge

# # # # volumes:
# # # #   postgres_data:



# version: '3.8'

# services:
#   app:
#     build: .
#     container_name: dcat_backend
#     ports:
#       - "2000:2000"
#     env_file:
#       - .env
#     environment:
#       DB_HOST: postgres
#       DB_NAME: ${APP_DB_NAME:-app_db_name}
#       DB_USER: ${APP_DB_USER:-app_db_user}
#       DB_PASSWORD: ${APP_DB_PASSWORD:-app_db_password}
#     depends_on:
#       - postgres
#       - keycloak
#     networks:
#       - dcat_network

#   keycloak:
#     image: quay.io/keycloak/keycloak:26.1.4
#     container_name: keycloak
#     env_file:
#       - .env
#     environment:
#       KC_HOSTNAME: localhost
#       KC_HTTP_ENABLED: "true"
#       KC_PROXY: edge
#       KC_DB: postgres
#       KC_DB_URL: jdbc:postgresql://postgres:5432/${KEYCLOAK_DB_NAME}
#       KC_DB_USERNAME: ${KEYCLOAK_DB_USER}
#       KC_DB_PASSWORD: ${KEYCLOAK_DB_PASSWORD}
#       KEYCLOAK_ADMIN: admin
#       KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
#       KC_HEALTH_ENABLED: "true"
#     ports:
#       - "8080:8080"
#     volumes:
#       - ./keycloak-setup:/opt/keycloak/data/import
#     depends_on:
#       postgres:
#         condition: service_healthy
#     command: ["start-dev"]
#     healthcheck:
#       test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
#       interval: 10s
#       timeout: 5s
#       retries: 3
#     networks:
#       - dcat_network

#   postgres:
#     image: postgres:15-alpine
#     container_name: dcat_postgres
#     environment:
#       POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
#       POSTGRES_USER: postgres
#       POSTGRES_DB: postgres
#       POSTGRES_MULTIPLE_DATABASES: ${KEYCLOAK_DB_NAME},${APP_DB_NAME}
#       POSTGRES_MULTIPLE_USERS: ${KEYCLOAK_DB_USER}:${KEYCLOAK_DB_PASSWORD},${APP_DB_USER}:${APP_DB_PASSWORD}
#     volumes:
#       - postgres_data:/var/lib/postgresql/data
#       - ./init-db:/docker-entrypoint-initdb.d
#       - ./.env:/tmp/.env:ro
#     ports:
#       - "${DB_PORT:-5432}:5432"
#     healthcheck:
#       test: ["CMD-SHELL", "pg_isready -U postgres"]
#       interval: 5s
#       timeout: 5s
#       retries: 5
#     networks:
#       - dcat_network

# networks:
#   dcat_network:
#     driver: bridge

# volumes:
#   postgres_data:


# # version: '3.8'

# # services:
# #   postgres:
# #     image: postgres:15-alpine
# #     container_name: dcat_postgres
# #     environment:
# #       POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
# #       POSTGRES_USER: postgres
# #       POSTGRES_DB: postgres
# #     volumes:
# #       - postgres_data:/var/lib/postgresql/data
# #       - ./init-db:/docker-entrypoint-initdb.d
# #     healthcheck:
# #       test: ["CMD-SHELL", "pg_isready -U postgres"]
# #       interval: 5s
# #       timeout: 5s
# #       retries: 5

# #   keycloak:
# #     image: quay.io/keycloak/keycloak:26.1.4
# #     container_name: keycloak
# #     depends_on:
# #       postgres:
# #         condition: service_healthy
# #     environment:
# #       KC_DB: postgres
# #       KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak_db
# #       KC_DB_USERNAME: keycloak_user
# #       KC_DB_PASSWORD: keycloak123
# #       KEYCLOAK_ADMIN: admin
# #       KEYCLOAK_ADMIN_PASSWORD: admin123
# #       KC_HOSTNAME: localhost
# #       KC_HTTP_ENABLED: "true"
# #       KC_PROXY: edge
# #     ports:
# #       - "8080:8080"
# #     volumes:
# #       - ./keycloak-setup:/opt/keycloak/data/import
# #     command: ["start-dev"]

# # volumes:
# #   postgres_data:


# # version: '3.8'

# # services:
# #   postgres:
# #     image: postgres:15-alpine
# #     container_name: dcat_postgres
# #     environment:
# #       POSTGRES_PASSWORD: postgres123
# #       POSTGRES_USER: postgres
# #       POSTGRES_DB: postgres
# #     volumes:
# #       - postgres_data:/var/lib/postgresql/data
# #       - ./init-db:/docker-entrypoint-initdb.d
# #       - ./.env:/tmp/.env:ro
# #     ports:
# #       - "${DB_PORT:-5432}:5432"
# #     healthcheck:
# #       test: ["CMD-SHELL", "pg_isready -U postgres"]
# #       interval: 5s
# #       timeout: 5s
# #       retries: 5

# #   keycloak:
# #     image: quay.io/keycloak/keycloak:26.1.4
# #     container_name: keycloak
# #     depends_on:
# #       postgres:
# #         condition: service_healthy
# #     environment:
# #       KC_DB: postgres
# #       KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak_db
# #       KC_DB_USERNAME: keycloak_user
# #       KC_DB_PASSWORD: keycloak123
# #       KEYCLOAK_ADMIN: admin
# #       KEYCLOAK_ADMIN_PASSWORD: admin123
# #       KC_HOSTNAME: localhost
# #       KC_HTTP_ENABLED: "true"
# #       KC_PROXY: edge
# #     ports:
# #       - "8080:8080"
# #     volumes:
# #       - ./keycloak-setup:/opt/keycloak/data/import
# #     command: ["start-dev"]

# # volumes:
# #   postgres_data:


version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: dcat_postgres
    env_file: .env
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-default_postgres_password}
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db:/docker-entrypoint-initdb.d
      - ./.env:/tmp/.env:ro
    ports:
      - "${DB_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  keycloak:
    image: quay.io/keycloak/keycloak:26.1.4
    container_name: keycloak
    env_file: .env
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/${KEYCLOAK_DB_NAME:-keycloak_db}
      KC_DB_USERNAME: ${KEYCLOAK_DB_USER:-keycloak_user}
      KC_DB_PASSWORD: ${KEYCLOAK_DB_PASSWORD:-keycloak123}
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin123}
      KC_HOSTNAME: ${KC_HOSTNAME:-localhost}
      KC_HTTP_ENABLED: "true"
      KC_PROXY: edge
    ports:
      - "8080:8080"
    depends_on:
      postgres:
        condition: service_healthy
    command: ["start-dev"]

volumes:
  postgres_data:


================================================
File: drizzle.config.js
================================================
require('dotenv').config();

module.exports = {
  schema: "./core/database/models.js",
  out: "./core/database/migrations",
  dialect: "postgresql", 
  dbCredentials: {
  url: `postgresql://${process.env.APP_DB_USER}:${process.env.APP_DB_PASSWORD}@${process.env.DB_HOST}:${process.env.DB_PORT}/${process.env.APP_DB_NAME}`
  },
  verbose: true,
  strict: true,
  ...(process.env.NODE_ENV === 'development' && {
    debug: true,
    migrationsTable: 'migrations_dev'
  })
};





================================================
File: init.sql
================================================
-- Utilisation des variables d'environnement via Docker
CREATE USER "${KEYCLOAK_DB_USER:-keycloak_user}" WITH PASSWORD '${KEYCLOAK_DB_PASSWORD:-keycloak123}';
CREATE DATABASE "${KEYCLOAK_DB_NAME:-keycloak_db}" OWNER "${KEYCLOAK_DB_USER:-keycloak_user}";

CREATE USER "${APP_DB_USER:-dcat_user}" WITH PASSWORD '${APP_DB_PASSWORD:-dcat123}';
CREATE DATABASE "${APP_DB_NAME:-dcat_db}" OWNER "${APP_DB_USER:-dcat_user}";


================================================
File: package.json
================================================
{
  "scripts": {
    "start": "nodemon server.js"
  },
  "dependencies": {
    "@keycloak/keycloak-admin-client": "^26.1.4",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "drizzle-kit": "^0.30.6",
    "drizzle-orm": "^0.41.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "helmet": "^8.1.0",
    "jose": "^6.0.10",
    "keycloak-connect": "^26.1.1",
    "nodemon": "^3.1.9",
    "openid-client": "^6.4.1",
    "pg": "^8.14.1",
    "pg-promise": "^11.13.0",
    "postgres-js": "^0.1.0",
    "sequelize": "^6.37.7",
    "winston": "^3.17.0"
  }
}



================================================
File: server.js
================================================
ï»¿const express = require('express');
const path = require('path');
const helmet = require('helmet');
const { keycloak } = require('./core/auth/keycloak.config');
const { initKeycloak, protect } = require('./core/auth/middleware');
const logger = require('./core/utils/logger');
require('dotenv').config();

const app = express();

// =============== MIDDLEWARES DE BASE ===============
app.use(helmet());
app.disable('x-powered-by');
app.use(express.json({ limit: '10kb' }));
app.use(express.urlencoded({ extended: true, limit: '10kb' }));

// =============== KEYCLOAK ===============
app.use(initKeycloak());

// =============== CHARGEMENT DES MODULES ===============
function loadModule(moduleName) {
  try {
    const modulePath = path.join(__dirname, 'modules', moduleName, 'routes', `${moduleName}.routes.js`);
    const router = require(modulePath);
    logger.info(`Module chargÃ©: ${moduleName}`);
    return router;
  } catch (error) {
    logger.error(`Ã‰chec du chargement du module ${moduleName}`, error);
    process.exit(1);
  }
}

app.use('/api/interventions', loadModule('interventions'));
app.use('/api/stocks', loadModule('stocks'));
app.use('/api/users', loadModule('users'));

// =============== ROUTES PUBLIQUES ===============
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK',
    auth: 'bearer-only',
    keycloak: {
      realm: keycloak.config.realm,
      clientId: keycloak.config.resource
    }
  });
});

// =============== ROUTES PROTÃ‰GÃ‰ES ===============
app.get('/api/protected', protect(), (req, res) => {
  res.json({ 
    message: 'AccÃ¨s autorisÃ©',
    user: req.kauth.grant.access_token.content 
  });
});

// =============== GESTION DES ERREURS ===============
app.use((req, res) => {
  res.status(404).json({ 
    error: 'Endpoint non trouvÃ©',
    path: req.path 
  });
});

app.use((err, req, res, next) => {
  const status = err.status || 500;
  logger.error({
    status,
    message: err.message,
    path: req.path,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
  res.status(status).json({ 
    error: status === 500 ? 'Erreur interne' : err.message 
  });
});

// =============== DÃ‰MARRAGE ===============
const PORT = process.env.PORT || 3000;
const server = app.listen(PORT, () => {
  logger.info(`Serveur dÃ©marrÃ© sur http://localhost:${PORT} [${process.env.NODE_ENV || 'development'}]`);
});

// Gestion propre des arrÃªts
['SIGINT', 'SIGTERM'].forEach(signal => {
  process.on(signal, () => {
    logger.info(`ReÃ§u ${signal}, arrÃªt du serveur...`);
    server.close(() => {
      logger.info('Serveur arrÃªtÃ© proprement');
      process.exit(0);
    });
  });
});


================================================
File: core/auth/digest.txt
================================================
Directory structure:
â””â”€â”€ auth/
    â”œâ”€â”€ keycloak.config.js
    â”œâ”€â”€ middleware.js
    â””â”€â”€ setupKeycloak.js

================================================
File: keycloak.config.js
================================================
Ã¯Â»Â¿const Keycloak = require('keycloak-connect');
const session = require('express-session');
const logger = require('../utils/logger');
require('dotenv').config();

const memoryStore = new session.MemoryStore();

const keycloakConfig = {
  realm: process.env.KEYCLOAK_REALM,
  'auth-server-url': process.env.KEYCLOAK_URL,
  'ssl-required': 'external',
  resource: process.env.KEYCLOAK_CLIENT_ID,
  'public-client': false,
  'confidential-port': 0,
  credentials: {
    secret: process.env.KEYCLOAK_CLIENT_SECRET
  }
};

logger.info('Keycloak Config:', {
  realm: keycloakConfig.realm,
  authServer: keycloakConfig['auth-server-url'],
  clientId: keycloakConfig.resource
});

const keycloak = new Keycloak(
  { store: memoryStore },
  keycloakConfig
);

module.exports = {
  keycloak,
  memoryStore,
  keycloakConfig
};


console.log('Configuration Keycloak chargÃƒÂ©e:', {
  realm: process.env.KEYCLOAK_REALM,
  url: process.env.KEYCLOAK_URL,
  clientId: process.env.KEYCLOAK_CLIENT_ID,
  hasSecret: !!process.env.KEYCLOAK_CLIENT_SECRET
});


================================================
File: middleware.js
================================================

const { keycloak, memoryStore } = require('./keycloak.config');
const logger = require('../utils/logger');
const { db } = require('../../core/database/config');
const { employes } = require('../../core/database/models');
const { eq } = require('drizzle-orm');
const { jwtVerify } = require('jose');
const { getKeycloakPublicKey } = require('./setupKeycloak');

// Initialisation Keycloak
const initKeycloak = () => {
  logger.info('Initializing Keycloak middleware');
  return keycloak.middleware({
    admin: '/admin',
    logout: '/logout'
  });
};

// Middleware de protection avec rÃƒÂ´les
const protect = (requiredRoles = []) => {
  return [
    keycloak.protect(),
    (req, res, next) => {
      const token = req.kauth.grant.access_token;
      if (requiredRoles.length && !requiredRoles.some(r => token.hasRole(r))) {
        return res.status(403).json({ error: 'Permissions insuffisantes' });
      }
      next();
    }
  ];
};

// Validation JWT directe
const validateJWT = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader) return res.status(401).json({ error: 'Token manquant' });

    const token = authHeader.split(' ')[1];
    const { payload } = await jwtVerify(token, await getKeycloakPublicKey());
    req.userToken = payload;
    next();
  } catch (error) {
    logger.error('Erreur validation JWT:', error);
    res.status(401).json({ error: 'Token invalide' });
  }
};

// Synchronisation utilisateur optimisÃƒÂ©e
const syncUserOnLogin = async (req, res, next) => {
  if (!req.kauth?.grant?.access_token?.content) {
    return next();
  }

  const keycloakUser = req.kauth.grant.access_token.content;
  
  if (!keycloakUser?.sub) {
    logger.warn('Token Keycloak invalide: sub manquant');
    return next();
  }

  try {
    // Solution avec UPSERT (INSERT ON CONFLICT UPDATE)
    await db.insert(employes)
      .values({
        keycloak_id: keycloakUser.sub,
        email: keycloakUser.email || `${keycloakUser.sub}@temp.dcat`,
        nom: keycloakUser.given_name || 'Ãƒâ‚¬ complÃƒÂ©ter',
        prenom: keycloakUser.family_name || 'Ãƒâ‚¬ complÃƒÂ©ter',
        status: 'actif',
        fonctionId: 1,
        contact: '',
        adresse: ''
      })
      .onConflictDoUpdate({
        target: employes.keycloak_id,
        set: { 
          email: keycloakUser.email,
          nom: keycloakUser.given_name || db.sql`excluded.nom`,
          prenom: keycloakUser.family_name || db.sql`excluded.prenom`,
          status: 'actif'
        }
      })
      .execute();

    logger.info(`Utilisateur synchronisÃƒÂ©: ${keycloakUser.sub}`);
    next();
  } catch (error) {
    logger.error('Erreur synchronisation utilisateur', {
      error: error.message,
      userId: keycloakUser.sub,
      stack: error.stack
    });
    next(error);
  }
};

// Middleware de dÃƒÂ©connexion complet
const handleLogout = async (req, res, next) => {
  try {
    if (!req.kauth?.grant) {
      return res.status(200).send('DÃƒÂ©connectÃƒÂ©');
    }

    // 1. RÃƒÂ©voquer le token Keycloak
    await keycloak.grantManager.revoke(req.kauth.grant);
    
    // 2. DÃƒÂ©truire la session
    req.session.destroy(err => {
      if (err) logger.error('Erreur destruction session:', err);
      
      // 3. Nettoyer les cookies
      res.clearCookie('connect.sid');
      res.clearCookie('keycloak_token');
      
      res.status(200).send('DÃƒÂ©connectÃƒÂ© avec succÃƒÂ¨s');
    });
  } catch (error) {
    logger.error('Erreur lors de la dÃƒÂ©connexion:', error);
    next(error);
  }
};

module.exports = {
  syncUserOnLogin,
  keycloak,
  memoryStore,
  initKeycloak,
  protect,
  validateJWT,
  handleLogout
};


================================================
File: setupKeycloak.js
================================================
const session = require('express-session');
const { memoryStore, keycloak } = require('./keycloak.config');
const { createRemoteJWKSet } = require('jose');
const { Issuer } = require('openid-client');

const sessionConfig = session({
  secret: process.env.SESSION_SECRET || 'your-strong-secret-here',
  resave: false,
  saveUninitialized: true,
  store: memoryStore
});

// Fonction pour obtenir les clÃƒÂ©s publiques Keycloak
async function getKeycloakPublicKey() {
  const keycloakIssuer = await Issuer.discover(
    `${keycloak.config['auth-server-url']}/realms/${keycloak.config.realm}`
  );
  
  const jwksUri = keycloakIssuer.metadata.jwks_uri;
  return createRemoteJWKSet(new URL(jwksUri));
}

module.exports = {
  sessionConfig,
  getKeycloakPublicKey // Exportez la nouvelle fonction
};




================================================
File: core/auth/keycloak.config.js
================================================
ï»¿const Keycloak = require('keycloak-connect');
const logger = require('../utils/logger');
require('dotenv').config();

const keycloakConfig = {
  realm: process.env.KEYCLOAK_REALM,
  'auth-server-url': process.env.KEYCLOAK_URL,
  'ssl-required': 'external',
  resource: process.env.KEYCLOAK_CLIENT_ID,
  'bearer-only': true,
  'verify-token-audience': true,
  credentials: {
    secret: process.env.KEYCLOAK_CLIENT_SECRET
  }
};

// Validation de la configuration
if (!process.env.KEYCLOAK_CLIENT_SECRET) {
  logger.error('Configuration Keycloak incomplÃ¨te : KEYCLOAK_CLIENT_SECRET manquant');
  process.exit(1);
}

const keycloak = new Keycloak({}, keycloakConfig);

module.exports = {
  keycloak,
  keycloakConfig
};


================================================
File: core/auth/middleware.js
================================================
const { keycloak } = require('./keycloak.config');
const { getKeycloakPublicKey } = require('./setupKeycloak');
const { jwtVerify } = require('jose');
const logger = require('../utils/logger');
const { db } = require('../../core/database/config');
const { employes } = require('../../core/database/models');
const { eq } = require('drizzle-orm');

// Middleware d'initialisation Keycloak
const initKeycloak = () => {
  logger.info('Middleware Keycloak initialisÃ© (mode bearer-only)');
  return keycloak.middleware();
};

// Protection de base
const protect = (requiredRoles = []) => {
  return [
    keycloak.protect(),
    async (req, res, next) => {
      if (requiredRoles.length === 0) return next();
      
      const token = req.kauth.grant.access_token;
      const hasRole = requiredRoles.some(role => token.hasRole(role));
      
      if (!hasRole) {
        logger.warn(`AccÃ¨s refusÃ© - RÃ´les manquants`, {
          user: token.content.sub,
          requiredRoles,
          actualRoles: token.content.realm_access?.roles
        });
        return res.status(403).json({ error: 'Permissions insuffisantes' });
      }
      next();
    }
  ];
};

// Validation JWT autonome
const validateJWT = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ error: 'Authorization header manquant' });
  }

  try {
    const token = authHeader.split(' ')[1];
    const { payload } = await jwtVerify(token, await getKeycloakPublicKey());
    req.userToken = payload;
    next();
  } catch (error) {
    logger.error('Ã‰chec de validation JWT', error);
    res.status(401).json({ error: 'Token invalide' });
  }
};

module.exports = {
  initKeycloak,
  protect,
  validateJWT,
  keycloak
};


================================================
File: core/auth/setupKeycloak.js
================================================
const { keycloak } = require('./keycloak.config');
const { createRemoteJWKSet } = require('jose');
const { Issuer } = require('openid-client');
const logger = require('../utils/logger');

async function getKeycloakPublicKey() {
  try {
    const issuer = await Issuer.discover(
      `${keycloak.config['auth-server-url']}/realms/${keycloak.config.realm}`
    );
    return createRemoteJWKSet(new URL(issuer.metadata.jwks_uri));
  } catch (error) {
    logger.error('Erreur de rÃ©cupÃ©ration des clÃ©s Keycloak', error);
    throw new Error('Service d\'authentification indisponible');
  }
}

module.exports = {
  getKeycloakPublicKey
};


================================================
File: core/database/config.js
================================================
const pg = require('pg');
const { drizzle } = require('drizzle-orm/node-postgres');
const schema = require('./models.js');
require('dotenv').config();

// Configuration du pool PostgreSQL
const pool = new pg.Pool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.APP_DB_USER,
  password: process.env.APP_DB_PASSWORD,
  database: process.env.APP_DB_NAME,
  ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false
});

// Test de connexion
pool.connect()
  .then(() => console.log('✅ Connected to PostgreSQL'))
  .catch(err => console.error('❌ PostgreSQL connection error:', err));

// Export en CommonJS
module.exports = {
  db: drizzle(pool, { schema }),
  pool
};


================================================
File: core/database/db.config.js
================================================
ï»¿module.exports = {
  HOST: process.env.DB_HOST || "postgres", 
  USER: process.env.DB_USER || "dcat_user",
  PASSWORD: process.env.DB_PASSWORD || "dcat_password",
  DB: process.env.DB_NAME || "dcat_db",
  dialect: "postgres",
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
};


================================================
File: core/database/migration.js
================================================
require("dotenv").config();
const { migrate } = require("drizzle-orm/node-postgres/migrator");
const { db } = require("./db.config");

(async () => {
  console.log("⏳ Migration en cours...");
  await migrate(db, { migrationsFolder: "backend/migrations" });
  console.log("✅ Migration terminée !");
  process.exit(0);
})();



================================================
File: core/database/models.js
================================================
const { text } = require("drizzle-orm/gel-core");
const {
  pgTable,
  serial,
  varchar,
  integer,
  primaryKey,
  foreignKey,
} = require("drizzle-orm/pg-core");

// Famille
const famille = pgTable("famille", {
  id: serial("id").primaryKey(),
  libelle: varchar("libelle", { length: 100 }),
});

// Categorie
const categorie = pgTable("categorie", {
  id: serial("id").primaryKey(),
  libelle: varchar("libelle", { length: 100 }),
});

// Modele
const modele = pgTable("modele", {
  id: serial("id").primaryKey(),
  libelle: varchar("libelle", { length: 100 }),
});

// Marque
const marque = pgTable("marque", {
  id: serial("id").primaryKey(),
  libelle: varchar("libelle", { length: 100 }),
});

// Fonction
const fonction = pgTable("fonction", {
  id: serial("id").primaryKey(),
  nom: varchar("nom", { length: 50 }).unique(),
});

// Employes
const employes = pgTable("employes", {
  id: serial("id").primaryKey(),
  nom: varchar("nom", { length: 50 }),
  keycloak_id: varchar("keycloak_id", { length: 36 }).unique().notNull(),
  prenom: varchar("prenom", { length: 50 }),
  email: varchar("email", { length: 100 }),
  contact: varchar("contact", { length: 20 }),
  adresse: varchar("adresse", { length: 200 }),
  status: varchar("status", { length: 50 }),
  fonctionId: integer("fonction_id")
    .notNull()
    .references(() => fonction.id),
});

// Demande
const demande = pgTable("demande", {
  id: serial("id").primaryKey(),
  dateDebut: varchar("date_debut", { length: 25 }),
  status: varchar("status", { length: 20 }),
  dateFin: varchar("date_fin", { length: 25 }),
  motif: varchar("motif", { length: 200 }),
  type: varchar("type", { length: 50 }),
  employeId: integer("employe_id")
    .notNull()
    .references(() => employes.id),
});

// TypeDoc
const typeDoc = pgTable("type_doc", {
  id: serial("id").primaryKey(),
  libelle: varchar("libelle", { length: 100 }),
});

// EntitÃ©
const entite = pgTable("entite", {
  id: serial("id").primaryKey(),
  libelle: varchar("libelle", { length: 100 }),
});

// Produit (avec clÃ© primaire composÃ©e id + code)
const produit = pgTable(
  "produit",
  {
    id: serial("id").notNull(),
    code: varchar("code", { length: 50 }).notNull(),
    nom: varchar("nom", { length: 100 }),
    description: text("description"),
    type: varchar("type", { length: 50 }),
    image: varchar("image", { length: 255 }),
    quantite: varchar("quantite", { length: 20 }),
    modeleId: integer("modele_id")
      .notNull()
      .references(() => modele.id),
    categorieId: integer("categorie_id")
      .notNull()
      .references(() => categorie.id),
    familleId: integer("famille_id")
      .notNull()
      .references(() => famille.id),
    marqueId: integer("marque_id")
      .notNull()
      .references(() => marque.id),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.id, table.code] }),
  })
);

// Documents
const documents = pgTable("documents", {
  id: serial("id").primaryKey(),
  titre: varchar("titre", { length: 200 }),
  fichier: varchar("fichier", { length: 255 }),
  dateAjout: varchar("date_ajout", { length: 25 }),
  employeId: integer("employe_id").references(() => employes.id),
  typeDocId: integer("type_doc_id")
    .notNull()
    .references(() => typeDoc.id),
});

// Partenaire
const partenaire = pgTable("partenaire", {
  id: serial("id").primaryKey(),
  nom: varchar("nom", { length: 100 }),
  telephone: varchar("telephone", { length: 20 }),
  email: varchar("email", { length: 100 }).unique(),
  specialite: varchar("specialite", { length: 100 }),
  localisation: varchar("localisation", { length: 200 }),
  type: varchar("type", { length: 50 }),
  entiteId: integer("entite_id")
    .notNull()
    .references(() => entite.id),
});

// Contrat
const contrat = pgTable("contrat", {
  id: serial("id").primaryKey(),
  nom: varchar("nom", { length: 100 }),
  duree: varchar("duree", { length: 50 }),
  dateDebut: varchar("date_debut", { length: 25 }),
  dateFin: varchar("date_fin", { length: 25 }),
  lien: text("lien"),
  partenaireId: integer("partenaire_id")
    .notNull()
    .references(() => partenaire.id),
});

// Intervention
const intervention = pgTable("intervention", {
  id: serial("id").primaryKey(),
  date: varchar("date", { length: 25 }),
  causeDefaillance: varchar("cause_defaillance", { length: 100 }),
  rapport: varchar("rapport", { length: 255 }),
  typeMaintenance: varchar("type_maintenance", { length: 50 }),
  typeDefaillance: varchar("type_defaillance", { length: 50 }),
  superviseur: varchar("superviseur", { length: 100 }),
  duree: varchar("duree", { length: 20 }),
  numero: varchar("numero", { length: 50 }),
  lieu: varchar("lieu", { length: 100 }),
  contratId: integer("contrat_id")
    .notNull()
    .references(() => contrat.id),
});

// Projet
const projet = pgTable("projet", {
  id: serial("id").primaryKey(),
  nom: varchar("nom", { length: 100 }),
  type: varchar("type", { length: 50 }),
  devis: varchar("devis", { length: 50 }),
  dateDebut: varchar("date_debut", { length: 25 }),
  dateFin: varchar("date_fin", { length: 25 }),
  duree: varchar("duree", { length: 50 }),
  description: varchar("description", { length: 1000 }),
  etat: varchar("etat", { length: 20 }),
  partenaireId: integer("partenaire_id")
    .notNull()
    .references(() => partenaire.id),
  familleId: integer("famille_id")
    .notNull()
    .references(() => famille.id),
});

// Livraison
const livraison = pgTable("livraison", {
  id: serial("id").primaryKey(),
  autresFrais: varchar("autres_frais", { length: 50 }),
  periodeAchat: varchar("periode_achat", { length: 50 }),
  prixAchat: varchar("prix_achat", { length: 50 }),
  dedouanement: varchar("dedouanement", { length: 50 }),
  prixTransport: varchar("prix_transport", { length: 50 }),
  dateLivraison: varchar("date_livraison", { length: 25 }),
  quantite: varchar("quantite", { length: 20 }),
  partenaireId: integer("partenaire_id")
    .notNull()
    .references(() => partenaire.id),
});

// Mission
const mission = pgTable("mission", {
  id: serial("id").primaryKey(),
  nom: varchar("nom", { length: 100 }),
  description: text("description"),
  statut: varchar("statut", { length: 20 }),
  lieu: varchar("lieu", { length: 200 }),
  projetId: integer("projet_id")
    .notNull()
    .references(() => projet.id),
});

// Exemplaire
const exemplaire = pgTable(
  "exemplaire",
  {
    id: serial("id").primaryKey(),
    numSerie: varchar("num_serie", { length: 100 }),
    prix: varchar("prix", { length: 50 }),
    etat: varchar("etat", { length: 20 }),
    livraisonId: integer("livraison_id")
      .notNull()
      .references(() => livraison.id),
    produitId: integer("produit_id").notNull(),
    produitCode: varchar("produit_code", { length: 50 }).notNull(),
  },
  (table) => ({
    fk: foreignKey({
      columns: [table.produitId, table.produitCode],
      foreignColumns: [produit.id, produit.code],
    }),
  })
);

// Tache
const tache = pgTable("tache", {
  id: serial("id").primaryKey(),
  nom: varchar("nom", { length: 100 }),
  description: text("description"),
  statut: varchar("statut", { length: 20 }),
  dateDebut: varchar("date_debut", { length: 25 }),
  dateFin: varchar("date_fin", { length: 25 }),
  responsable: varchar("responsable", { length: 100 }),
  missionId: integer("mission_id")
    .notNull()
    .references(() => mission.id),
});

// Tables de liaison
const projetExemplaireEmployes = pgTable(
  "projet_exemplaire_employes",
  {
    exemplaireId: integer("exemplaire_id")
      .notNull()
      .references(() => exemplaire.id),
    projetId: integer("projet_id")
      .notNull()
      .references(() => projet.id),
    employeId: integer("employe_id")
      .notNull()
      .references(() => employes.id),
    dateUtilisation: varchar("date_utilisation", { length: 25 }),
    dateFin: varchar("date_fin", { length: 25 }),
    dateDebut: varchar("date_debut", { length: 25 }),
  },
  (table) => ({
    pk: primaryKey({
      columns: [table.exemplaireId, table.projetId, table.employeId],
    }),
  })
);

const exemplaireAcheter = pgTable(
  "exemplaire_acheter",
  {
    exemplaireId: integer("exemplaire_id")
      .notNull()
      .references(() => exemplaire.id),
    partenaireId: integer("partenaire_id")
      .notNull()
      .references(() => partenaire.id),
    lieuLivraison: varchar("lieu_livraison", { length: 200 }),
    quantite: varchar("quantite", { length: 20 }),
    dateAchat: varchar("date_achat", { length: 25 }),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.exemplaireId, table.partenaireId] }),
  })
);

const missionEmployes = pgTable(
  "mission_employes",
  {
    employeId: integer("employe_id")
      .notNull()
      .references(() => employes.id),
    missionId: integer("mission_id")
      .notNull()
      .references(() => mission.id),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.employeId, table.missionId] }),
  })
);

const interventionProduit = pgTable(
  "Intervention_Produits",
  {
    exemplaireId: integer("exemplaire_id")
      .notNull()
      .references(() => exemplaire.id),
    interventionId: integer("intervention_id")
      .notNull()
      .references(() => intervention.id),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.exemplaireId, table.interventionId] }),
  })
);

const interventionEmploye = pgTable(
  "Intervention_enployer",
  {
    employeId: integer("employe_id")
      .notNull()
      .references(() => employes.id),
    interventionId: integer("intervention_id")
      .notNull()
      .references(() => intervention.id),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.employeId, table.interventionId] }),
  })
);

const sollicitationProduits = pgTable(
  "Sollicitation_Produits",
  {
    produitId: integer("produit_id").notNull(),
    produitCode: varchar("produit_code", { length: 50 }).notNull(),
    partenaireId: integer("partenaire_id")
      .notNull()
      .references(() => partenaire.id),
    etat: varchar("etat", { length: 20 }),
    description: text("description"),
  },
  (table) => ({
    pk: primaryKey({
      columns: [table.produitId, table.produitCode, table.partenaireId],
    }),
    fk: foreignKey({
      columns: [table.produitId, table.produitCode],
      foreignColumns: [produit.id, produit.code],
    }),
  })
);

const sollicitationInterventions = pgTable(
  "Sollicitation_Interventions",
  {
    partenaireId: integer("partenaire_id")
      .notNull()
      .references(() => partenaire.id),
    interventionId: integer("intervention_id")
      .notNull()
      .references(() => intervention.id),
    etat: varchar("etat", { length: 20 }),
    description: text("description"),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.partenaireId, table.interventionId] }),
  })
);

module.exports = {
  famille,
  categorie,
  modele,
  marque,
  fonction,
  employes,
  demande,
  typeDoc,
  entite,
  produit,
  documents,
  partenaire,
  contrat,
  intervention,
  projet,
  livraison,
  mission,
  exemplaire,
  tache,
  projetExemplaireEmployes,
  exemplaireAcheter,
  missionEmployes,
  interventionProduit,
  interventionEmploye,
  sollicitationProduits,
  sollicitationInterventions,
};



================================================
File: core/database/test-db.js
================================================
// test-db.js
const { db } = require('./config');
const { intervention } = require('./models');

(async () => {
  try {
    console.log("Testing database connection...");
    const result = await db.select().from(intervention).limit(1);
    console.log("Success! Found", result.length, "interventions");
  } catch (err) {
    console.error("Database test failed:", err);
  } finally {
    process.exit();
  }
})();


================================================
File: core/database/migrations/0000_stale_lenny_balinger.sql
================================================
CREATE TABLE "famille" (
	"id" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(100)
);
--> statement-breakpoint
CREATE TABLE "categorie" (
	"id" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(100)
);
--> statement-breakpoint
CREATE TABLE "modele" (
	"id" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(100)
);
--> statement-breakpoint
CREATE TABLE "marque" (
	"id" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(100)
);
--> statement-breakpoint
CREATE TABLE "fonction" (
	"id" serial PRIMARY KEY NOT NULL,
	"nom" varchar(50),
	CONSTRAINT "fonction_nom_unique" UNIQUE("nom")
);
--> statement-breakpoint
CREATE TABLE "employes" (
	"id" serial PRIMARY KEY NOT NULL,
	"nom" varchar(50),
	"keycloak_id" varchar(36) NOT NULL,
	"prenom" varchar(50),
	"email" varchar(100),
	"contact" varchar(20),
	"adresse" varchar(200),
	"status" varchar(50),
	"fonction_id" integer NOT NULL,
	CONSTRAINT "employes_keycloak_id_unique" UNIQUE("keycloak_id")
);
--> statement-breakpoint
CREATE TABLE "demande" (
	"id" serial PRIMARY KEY NOT NULL,
	"date_debut" varchar(25),
	"status" varchar(20),
	"date_fin" varchar(25),
	"motif" varchar(200),
	"type" varchar(50),
	"employe_id" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE "type_doc" (
	"id" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(100)
);
--> statement-breakpoint
CREATE TABLE "entite" (
	"id" serial PRIMARY KEY NOT NULL,
	"libelle" varchar(100)
);
--> statement-breakpoint
CREATE TABLE "produit" (
	"id" serial NOT NULL,
	"code" varchar(50) NOT NULL,
	"nom" varchar(100),
	"description" text,
	"type" varchar(50),
	"image" varchar(255),
	"quantite" varchar(20),
	"modele_id" integer NOT NULL,
	"categorie_id" integer NOT NULL,
	"famille_id" integer NOT NULL,
	"marque_id" integer NOT NULL,
	CONSTRAINT "produit_id_code_pk" PRIMARY KEY("id","code")
);
--> statement-breakpoint
CREATE TABLE "documents" (
	"id" serial PRIMARY KEY NOT NULL,
	"titre" varchar(200),
	"fichier" varchar(255),
	"date_ajout" varchar(25),
	"employe_id" integer,
	"type_doc_id" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE "partenaire" (
	"id" serial PRIMARY KEY NOT NULL,
	"nom" varchar(100),
	"telephone" varchar(20),
	"email" varchar(100),
	"specialite" varchar(100),
	"localisation" varchar(200),
	"type" varchar(50),
	"entite_id" integer NOT NULL,
	CONSTRAINT "partenaire_email_unique" UNIQUE("email")
);
--> statement-breakpoint
CREATE TABLE "contrat" (
	"id" serial PRIMARY KEY NOT NULL,
	"nom" varchar(100),
	"duree" varchar(50),
	"date_debut" varchar(25),
	"date_fin" varchar(25),
	"lien" text,
	"partenaire_id" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE "intervention" (
	"id" serial PRIMARY KEY NOT NULL,
	"date" varchar(25),
	"cause_defaillance" varchar(100),
	"rapport" varchar(255),
	"type_maintenance" varchar(50),
	"type_defaillance" varchar(50),
	"superviseur" varchar(100),
	"duree" varchar(20),
	"numero" varchar(50),
	"lieu" varchar(100),
	"contrat_id" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE "projet" (
	"id" serial PRIMARY KEY NOT NULL,
	"nom" varchar(100),
	"type" varchar(50),
	"devis" varchar(50),
	"date_debut" varchar(25),
	"date_fin" varchar(25),
	"duree" varchar(50),
	"description" varchar(1000),
	"etat" varchar(20),
	"partenaire_id" integer NOT NULL,
	"famille_id" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE "livraison" (
	"id" serial PRIMARY KEY NOT NULL,
	"autres_frais" varchar(50),
	"periode_achat" varchar(50),
	"prix_achat" varchar(50),
	"dedouanement" varchar(50),
	"prix_transport" varchar(50),
	"date_livraison" varchar(25),
	"quantite" varchar(20),
	"partenaire_id" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE "mission" (
	"id" serial PRIMARY KEY NOT NULL,
	"nom" varchar(100),
	"description" text,
	"statut" varchar(20),
	"lieu" varchar(200),
	"projet_id" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE "exemplaire" (
	"id" serial PRIMARY KEY NOT NULL,
	"num_serie" varchar(100),
	"prix" varchar(50),
	"etat" varchar(20),
	"livraison_id" integer NOT NULL,
	"produit_id" integer NOT NULL,
	"produit_code" varchar(50) NOT NULL
);
--> statement-breakpoint
CREATE TABLE "tache" (
	"id" serial PRIMARY KEY NOT NULL,
	"nom" varchar(100),
	"description" text,
	"statut" varchar(20),
	"date_debut" varchar(25),
	"date_fin" varchar(25),
	"responsable" varchar(100),
	"mission_id" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE "projet_exemplaire_employes" (
	"exemplaire_id" integer NOT NULL,
	"projet_id" integer NOT NULL,
	"employe_id" integer NOT NULL,
	"date_utilisation" varchar(25),
	"date_fin" varchar(25),
	"date_debut" varchar(25),
	CONSTRAINT "projet_exemplaire_employes_exemplaire_id_projet_id_employe_id_pk" PRIMARY KEY("exemplaire_id","projet_id","employe_id")
);
--> statement-breakpoint
CREATE TABLE "exemplaire_acheter" (
	"exemplaire_id" integer NOT NULL,
	"partenaire_id" integer NOT NULL,
	"lieu_livraison" varchar(200),
	"quantite" varchar(20),
	"date_achat" varchar(25),
	CONSTRAINT "exemplaire_acheter_exemplaire_id_partenaire_id_pk" PRIMARY KEY("exemplaire_id","partenaire_id")
);
--> statement-breakpoint
CREATE TABLE "mission_employes" (
	"employe_id" integer NOT NULL,
	"mission_id" integer NOT NULL,
	CONSTRAINT "mission_employes_employe_id_mission_id_pk" PRIMARY KEY("employe_id","mission_id")
);
--> statement-breakpoint
CREATE TABLE "Intervention_Produits" (
	"exemplaire_id" integer NOT NULL,
	"intervention_id" integer NOT NULL,
	CONSTRAINT "Intervention_Produits_exemplaire_id_intervention_id_pk" PRIMARY KEY("exemplaire_id","intervention_id")
);
--> statement-breakpoint
CREATE TABLE "Intervention_enployer" (
	"employe_id" integer NOT NULL,
	"intervention_id" integer NOT NULL,
	CONSTRAINT "Intervention_enployer_employe_id_intervention_id_pk" PRIMARY KEY("employe_id","intervention_id")
);
--> statement-breakpoint
CREATE TABLE "Sollicitation_Produits" (
	"produit_id" integer NOT NULL,
	"produit_code" varchar(50) NOT NULL,
	"partenaire_id" integer NOT NULL,
	"etat" varchar(20),
	"description" text,
	CONSTRAINT "Sollicitation_Produits_produit_id_produit_code_partenaire_id_pk" PRIMARY KEY("produit_id","produit_code","partenaire_id")
);
--> statement-breakpoint
CREATE TABLE "Sollicitation_Interventions" (
	"partenaire_id" integer NOT NULL,
	"intervention_id" integer NOT NULL,
	"etat" varchar(20),
	"description" text,
	CONSTRAINT "Sollicitation_Interventions_partenaire_id_intervention_id_pk" PRIMARY KEY("partenaire_id","intervention_id")
);
--> statement-breakpoint
ALTER TABLE "employes" ADD CONSTRAINT "employes_fonction_id_fonction_id_fk" FOREIGN KEY ("fonction_id") REFERENCES "public"."fonction"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "demande" ADD CONSTRAINT "demande_employe_id_employes_id_fk" FOREIGN KEY ("employe_id") REFERENCES "public"."employes"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produit" ADD CONSTRAINT "produit_modele_id_modele_id_fk" FOREIGN KEY ("modele_id") REFERENCES "public"."modele"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produit" ADD CONSTRAINT "produit_categorie_id_categorie_id_fk" FOREIGN KEY ("categorie_id") REFERENCES "public"."categorie"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produit" ADD CONSTRAINT "produit_famille_id_famille_id_fk" FOREIGN KEY ("famille_id") REFERENCES "public"."famille"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "produit" ADD CONSTRAINT "produit_marque_id_marque_id_fk" FOREIGN KEY ("marque_id") REFERENCES "public"."marque"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_employe_id_employes_id_fk" FOREIGN KEY ("employe_id") REFERENCES "public"."employes"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_type_doc_id_type_doc_id_fk" FOREIGN KEY ("type_doc_id") REFERENCES "public"."type_doc"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "partenaire" ADD CONSTRAINT "partenaire_entite_id_entite_id_fk" FOREIGN KEY ("entite_id") REFERENCES "public"."entite"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "contrat" ADD CONSTRAINT "contrat_partenaire_id_partenaire_id_fk" FOREIGN KEY ("partenaire_id") REFERENCES "public"."partenaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "intervention" ADD CONSTRAINT "intervention_contrat_id_contrat_id_fk" FOREIGN KEY ("contrat_id") REFERENCES "public"."contrat"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "projet" ADD CONSTRAINT "projet_partenaire_id_partenaire_id_fk" FOREIGN KEY ("partenaire_id") REFERENCES "public"."partenaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "projet" ADD CONSTRAINT "projet_famille_id_famille_id_fk" FOREIGN KEY ("famille_id") REFERENCES "public"."famille"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "livraison" ADD CONSTRAINT "livraison_partenaire_id_partenaire_id_fk" FOREIGN KEY ("partenaire_id") REFERENCES "public"."partenaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "mission" ADD CONSTRAINT "mission_projet_id_projet_id_fk" FOREIGN KEY ("projet_id") REFERENCES "public"."projet"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaire" ADD CONSTRAINT "exemplaire_livraison_id_livraison_id_fk" FOREIGN KEY ("livraison_id") REFERENCES "public"."livraison"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaire" ADD CONSTRAINT "exemplaire_produit_id_produit_code_produit_id_code_fk" FOREIGN KEY ("produit_id","produit_code") REFERENCES "public"."produit"("id","code") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tache" ADD CONSTRAINT "tache_mission_id_mission_id_fk" FOREIGN KEY ("mission_id") REFERENCES "public"."mission"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "projet_exemplaire_employes" ADD CONSTRAINT "projet_exemplaire_employes_exemplaire_id_exemplaire_id_fk" FOREIGN KEY ("exemplaire_id") REFERENCES "public"."exemplaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "projet_exemplaire_employes" ADD CONSTRAINT "projet_exemplaire_employes_projet_id_projet_id_fk" FOREIGN KEY ("projet_id") REFERENCES "public"."projet"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "projet_exemplaire_employes" ADD CONSTRAINT "projet_exemplaire_employes_employe_id_employes_id_fk" FOREIGN KEY ("employe_id") REFERENCES "public"."employes"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaire_acheter" ADD CONSTRAINT "exemplaire_acheter_exemplaire_id_exemplaire_id_fk" FOREIGN KEY ("exemplaire_id") REFERENCES "public"."exemplaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "exemplaire_acheter" ADD CONSTRAINT "exemplaire_acheter_partenaire_id_partenaire_id_fk" FOREIGN KEY ("partenaire_id") REFERENCES "public"."partenaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "mission_employes" ADD CONSTRAINT "mission_employes_employe_id_employes_id_fk" FOREIGN KEY ("employe_id") REFERENCES "public"."employes"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "mission_employes" ADD CONSTRAINT "mission_employes_mission_id_mission_id_fk" FOREIGN KEY ("mission_id") REFERENCES "public"."mission"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "Intervention_Produits" ADD CONSTRAINT "Intervention_Produits_exemplaire_id_exemplaire_id_fk" FOREIGN KEY ("exemplaire_id") REFERENCES "public"."exemplaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "Intervention_Produits" ADD CONSTRAINT "Intervention_Produits_intervention_id_intervention_id_fk" FOREIGN KEY ("intervention_id") REFERENCES "public"."intervention"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "Intervention_enployer" ADD CONSTRAINT "Intervention_enployer_employe_id_employes_id_fk" FOREIGN KEY ("employe_id") REFERENCES "public"."employes"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "Intervention_enployer" ADD CONSTRAINT "Intervention_enployer_intervention_id_intervention_id_fk" FOREIGN KEY ("intervention_id") REFERENCES "public"."intervention"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "Sollicitation_Produits" ADD CONSTRAINT "Sollicitation_Produits_partenaire_id_partenaire_id_fk" FOREIGN KEY ("partenaire_id") REFERENCES "public"."partenaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "Sollicitation_Produits" ADD CONSTRAINT "Sollicitation_Produits_produit_id_produit_code_produit_id_code_fk" FOREIGN KEY ("produit_id","produit_code") REFERENCES "public"."produit"("id","code") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "Sollicitation_Interventions" ADD CONSTRAINT "Sollicitation_Interventions_partenaire_id_partenaire_id_fk" FOREIGN KEY ("partenaire_id") REFERENCES "public"."partenaire"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "Sollicitation_Interventions" ADD CONSTRAINT "Sollicitation_Interventions_intervention_id_intervention_id_fk" FOREIGN KEY ("intervention_id") REFERENCES "public"."intervention"("id") ON DELETE no action ON UPDATE no action;


================================================
File: core/database/migrations/meta/0000_snapshot.json
================================================
{
  "id": "0b552a57-521f-46ae-bdcc-d9a56caad15a",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.famille": {
      "name": "famille",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.categorie": {
      "name": "categorie",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.modele": {
      "name": "modele",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.marque": {
      "name": "marque",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.fonction": {
      "name": "fonction",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom": {
          "name": "nom",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "fonction_nom_unique": {
          "name": "fonction_nom_unique",
          "nullsNotDistinct": false,
          "columns": [
            "nom"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.employes": {
      "name": "employes",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom": {
          "name": "nom",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "keycloak_id": {
          "name": "keycloak_id",
          "type": "varchar(36)",
          "primaryKey": false,
          "notNull": true
        },
        "prenom": {
          "name": "prenom",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "contact": {
          "name": "contact",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "adresse": {
          "name": "adresse",
          "type": "varchar(200)",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "fonction_id": {
          "name": "fonction_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "employes_fonction_id_fonction_id_fk": {
          "name": "employes_fonction_id_fonction_id_fk",
          "tableFrom": "employes",
          "tableTo": "fonction",
          "columnsFrom": [
            "fonction_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "employes_keycloak_id_unique": {
          "name": "employes_keycloak_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "keycloak_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.demande": {
      "name": "demande",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date_debut": {
          "name": "date_debut",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "date_fin": {
          "name": "date_fin",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "motif": {
          "name": "motif",
          "type": "varchar(200)",
          "primaryKey": false,
          "notNull": false
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "employe_id": {
          "name": "employe_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "demande_employe_id_employes_id_fk": {
          "name": "demande_employe_id_employes_id_fk",
          "tableFrom": "demande",
          "tableTo": "employes",
          "columnsFrom": [
            "employe_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.type_doc": {
      "name": "type_doc",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.entite": {
      "name": "entite",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "libelle": {
          "name": "libelle",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.produit": {
      "name": "produit",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": false,
          "notNull": true
        },
        "code": {
          "name": "code",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "nom": {
          "name": "nom",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "image": {
          "name": "image",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "quantite": {
          "name": "quantite",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "modele_id": {
          "name": "modele_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "categorie_id": {
          "name": "categorie_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "famille_id": {
          "name": "famille_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "marque_id": {
          "name": "marque_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "produit_modele_id_modele_id_fk": {
          "name": "produit_modele_id_modele_id_fk",
          "tableFrom": "produit",
          "tableTo": "modele",
          "columnsFrom": [
            "modele_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produit_categorie_id_categorie_id_fk": {
          "name": "produit_categorie_id_categorie_id_fk",
          "tableFrom": "produit",
          "tableTo": "categorie",
          "columnsFrom": [
            "categorie_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produit_famille_id_famille_id_fk": {
          "name": "produit_famille_id_famille_id_fk",
          "tableFrom": "produit",
          "tableTo": "famille",
          "columnsFrom": [
            "famille_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "produit_marque_id_marque_id_fk": {
          "name": "produit_marque_id_marque_id_fk",
          "tableFrom": "produit",
          "tableTo": "marque",
          "columnsFrom": [
            "marque_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "produit_id_code_pk": {
          "name": "produit_id_code_pk",
          "columns": [
            "id",
            "code"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.documents": {
      "name": "documents",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "titre": {
          "name": "titre",
          "type": "varchar(200)",
          "primaryKey": false,
          "notNull": false
        },
        "fichier": {
          "name": "fichier",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "date_ajout": {
          "name": "date_ajout",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "employe_id": {
          "name": "employe_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "type_doc_id": {
          "name": "type_doc_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "documents_employe_id_employes_id_fk": {
          "name": "documents_employe_id_employes_id_fk",
          "tableFrom": "documents",
          "tableTo": "employes",
          "columnsFrom": [
            "employe_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "documents_type_doc_id_type_doc_id_fk": {
          "name": "documents_type_doc_id_type_doc_id_fk",
          "tableFrom": "documents",
          "tableTo": "type_doc",
          "columnsFrom": [
            "type_doc_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.partenaire": {
      "name": "partenaire",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom": {
          "name": "nom",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "telephone": {
          "name": "telephone",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "specialite": {
          "name": "specialite",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "localisation": {
          "name": "localisation",
          "type": "varchar(200)",
          "primaryKey": false,
          "notNull": false
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "entite_id": {
          "name": "entite_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "partenaire_entite_id_entite_id_fk": {
          "name": "partenaire_entite_id_entite_id_fk",
          "tableFrom": "partenaire",
          "tableTo": "entite",
          "columnsFrom": [
            "entite_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "partenaire_email_unique": {
          "name": "partenaire_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contrat": {
      "name": "contrat",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom": {
          "name": "nom",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "duree": {
          "name": "duree",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_debut": {
          "name": "date_debut",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "date_fin": {
          "name": "date_fin",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "lien": {
          "name": "lien",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "partenaire_id": {
          "name": "partenaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contrat_partenaire_id_partenaire_id_fk": {
          "name": "contrat_partenaire_id_partenaire_id_fk",
          "tableFrom": "contrat",
          "tableTo": "partenaire",
          "columnsFrom": [
            "partenaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.intervention": {
      "name": "intervention",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "date": {
          "name": "date",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "cause_defaillance": {
          "name": "cause_defaillance",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "rapport": {
          "name": "rapport",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "type_maintenance": {
          "name": "type_maintenance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "type_defaillance": {
          "name": "type_defaillance",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "superviseur": {
          "name": "superviseur",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "duree": {
          "name": "duree",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "numero": {
          "name": "numero",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "contrat_id": {
          "name": "contrat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "intervention_contrat_id_contrat_id_fk": {
          "name": "intervention_contrat_id_contrat_id_fk",
          "tableFrom": "intervention",
          "tableTo": "contrat",
          "columnsFrom": [
            "contrat_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.projet": {
      "name": "projet",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom": {
          "name": "nom",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "type": {
          "name": "type",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "devis": {
          "name": "devis",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_debut": {
          "name": "date_debut",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "date_fin": {
          "name": "date_fin",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "duree": {
          "name": "duree",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "varchar(1000)",
          "primaryKey": false,
          "notNull": false
        },
        "etat": {
          "name": "etat",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "partenaire_id": {
          "name": "partenaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "famille_id": {
          "name": "famille_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "projet_partenaire_id_partenaire_id_fk": {
          "name": "projet_partenaire_id_partenaire_id_fk",
          "tableFrom": "projet",
          "tableTo": "partenaire",
          "columnsFrom": [
            "partenaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "projet_famille_id_famille_id_fk": {
          "name": "projet_famille_id_famille_id_fk",
          "tableFrom": "projet",
          "tableTo": "famille",
          "columnsFrom": [
            "famille_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.livraison": {
      "name": "livraison",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "autres_frais": {
          "name": "autres_frais",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "periode_achat": {
          "name": "periode_achat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_achat": {
          "name": "prix_achat",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "dedouanement": {
          "name": "dedouanement",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "prix_transport": {
          "name": "prix_transport",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "date_livraison": {
          "name": "date_livraison",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "quantite": {
          "name": "quantite",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "partenaire_id": {
          "name": "partenaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "livraison_partenaire_id_partenaire_id_fk": {
          "name": "livraison_partenaire_id_partenaire_id_fk",
          "tableFrom": "livraison",
          "tableTo": "partenaire",
          "columnsFrom": [
            "partenaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.mission": {
      "name": "mission",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom": {
          "name": "nom",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "statut": {
          "name": "statut",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "lieu": {
          "name": "lieu",
          "type": "varchar(200)",
          "primaryKey": false,
          "notNull": false
        },
        "projet_id": {
          "name": "projet_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "mission_projet_id_projet_id_fk": {
          "name": "mission_projet_id_projet_id_fk",
          "tableFrom": "mission",
          "tableTo": "projet",
          "columnsFrom": [
            "projet_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.exemplaire": {
      "name": "exemplaire",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "num_serie": {
          "name": "num_serie",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "prix": {
          "name": "prix",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "etat": {
          "name": "etat",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "livraison_id": {
          "name": "livraison_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "produit_id": {
          "name": "produit_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "produit_code": {
          "name": "produit_code",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "exemplaire_livraison_id_livraison_id_fk": {
          "name": "exemplaire_livraison_id_livraison_id_fk",
          "tableFrom": "exemplaire",
          "tableTo": "livraison",
          "columnsFrom": [
            "livraison_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaire_produit_id_produit_code_produit_id_code_fk": {
          "name": "exemplaire_produit_id_produit_code_produit_id_code_fk",
          "tableFrom": "exemplaire",
          "tableTo": "produit",
          "columnsFrom": [
            "produit_id",
            "produit_code"
          ],
          "columnsTo": [
            "id",
            "code"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.tache": {
      "name": "tache",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "nom": {
          "name": "nom",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "statut": {
          "name": "statut",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "date_debut": {
          "name": "date_debut",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "date_fin": {
          "name": "date_fin",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "responsable": {
          "name": "responsable",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "mission_id": {
          "name": "mission_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "tache_mission_id_mission_id_fk": {
          "name": "tache_mission_id_mission_id_fk",
          "tableFrom": "tache",
          "tableTo": "mission",
          "columnsFrom": [
            "mission_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.projet_exemplaire_employes": {
      "name": "projet_exemplaire_employes",
      "schema": "",
      "columns": {
        "exemplaire_id": {
          "name": "exemplaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "projet_id": {
          "name": "projet_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "employe_id": {
          "name": "employe_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "date_utilisation": {
          "name": "date_utilisation",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "date_fin": {
          "name": "date_fin",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        },
        "date_debut": {
          "name": "date_debut",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "projet_exemplaire_employes_exemplaire_id_exemplaire_id_fk": {
          "name": "projet_exemplaire_employes_exemplaire_id_exemplaire_id_fk",
          "tableFrom": "projet_exemplaire_employes",
          "tableTo": "exemplaire",
          "columnsFrom": [
            "exemplaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "projet_exemplaire_employes_projet_id_projet_id_fk": {
          "name": "projet_exemplaire_employes_projet_id_projet_id_fk",
          "tableFrom": "projet_exemplaire_employes",
          "tableTo": "projet",
          "columnsFrom": [
            "projet_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "projet_exemplaire_employes_employe_id_employes_id_fk": {
          "name": "projet_exemplaire_employes_employe_id_employes_id_fk",
          "tableFrom": "projet_exemplaire_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "employe_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "projet_exemplaire_employes_exemplaire_id_projet_id_employe_id_pk": {
          "name": "projet_exemplaire_employes_exemplaire_id_projet_id_employe_id_pk",
          "columns": [
            "exemplaire_id",
            "projet_id",
            "employe_id"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.exemplaire_acheter": {
      "name": "exemplaire_acheter",
      "schema": "",
      "columns": {
        "exemplaire_id": {
          "name": "exemplaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "partenaire_id": {
          "name": "partenaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "lieu_livraison": {
          "name": "lieu_livraison",
          "type": "varchar(200)",
          "primaryKey": false,
          "notNull": false
        },
        "quantite": {
          "name": "quantite",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "date_achat": {
          "name": "date_achat",
          "type": "varchar(25)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "exemplaire_acheter_exemplaire_id_exemplaire_id_fk": {
          "name": "exemplaire_acheter_exemplaire_id_exemplaire_id_fk",
          "tableFrom": "exemplaire_acheter",
          "tableTo": "exemplaire",
          "columnsFrom": [
            "exemplaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "exemplaire_acheter_partenaire_id_partenaire_id_fk": {
          "name": "exemplaire_acheter_partenaire_id_partenaire_id_fk",
          "tableFrom": "exemplaire_acheter",
          "tableTo": "partenaire",
          "columnsFrom": [
            "partenaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "exemplaire_acheter_exemplaire_id_partenaire_id_pk": {
          "name": "exemplaire_acheter_exemplaire_id_partenaire_id_pk",
          "columns": [
            "exemplaire_id",
            "partenaire_id"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.mission_employes": {
      "name": "mission_employes",
      "schema": "",
      "columns": {
        "employe_id": {
          "name": "employe_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "mission_id": {
          "name": "mission_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "mission_employes_employe_id_employes_id_fk": {
          "name": "mission_employes_employe_id_employes_id_fk",
          "tableFrom": "mission_employes",
          "tableTo": "employes",
          "columnsFrom": [
            "employe_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "mission_employes_mission_id_mission_id_fk": {
          "name": "mission_employes_mission_id_mission_id_fk",
          "tableFrom": "mission_employes",
          "tableTo": "mission",
          "columnsFrom": [
            "mission_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "mission_employes_employe_id_mission_id_pk": {
          "name": "mission_employes_employe_id_mission_id_pk",
          "columns": [
            "employe_id",
            "mission_id"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.Intervention_Produits": {
      "name": "Intervention_Produits",
      "schema": "",
      "columns": {
        "exemplaire_id": {
          "name": "exemplaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "intervention_id": {
          "name": "intervention_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "Intervention_Produits_exemplaire_id_exemplaire_id_fk": {
          "name": "Intervention_Produits_exemplaire_id_exemplaire_id_fk",
          "tableFrom": "Intervention_Produits",
          "tableTo": "exemplaire",
          "columnsFrom": [
            "exemplaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "Intervention_Produits_intervention_id_intervention_id_fk": {
          "name": "Intervention_Produits_intervention_id_intervention_id_fk",
          "tableFrom": "Intervention_Produits",
          "tableTo": "intervention",
          "columnsFrom": [
            "intervention_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "Intervention_Produits_exemplaire_id_intervention_id_pk": {
          "name": "Intervention_Produits_exemplaire_id_intervention_id_pk",
          "columns": [
            "exemplaire_id",
            "intervention_id"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.Intervention_enployer": {
      "name": "Intervention_enployer",
      "schema": "",
      "columns": {
        "employe_id": {
          "name": "employe_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "intervention_id": {
          "name": "intervention_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "Intervention_enployer_employe_id_employes_id_fk": {
          "name": "Intervention_enployer_employe_id_employes_id_fk",
          "tableFrom": "Intervention_enployer",
          "tableTo": "employes",
          "columnsFrom": [
            "employe_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "Intervention_enployer_intervention_id_intervention_id_fk": {
          "name": "Intervention_enployer_intervention_id_intervention_id_fk",
          "tableFrom": "Intervention_enployer",
          "tableTo": "intervention",
          "columnsFrom": [
            "intervention_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "Intervention_enployer_employe_id_intervention_id_pk": {
          "name": "Intervention_enployer_employe_id_intervention_id_pk",
          "columns": [
            "employe_id",
            "intervention_id"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.Sollicitation_Produits": {
      "name": "Sollicitation_Produits",
      "schema": "",
      "columns": {
        "produit_id": {
          "name": "produit_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "produit_code": {
          "name": "produit_code",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "partenaire_id": {
          "name": "partenaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "etat": {
          "name": "etat",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "Sollicitation_Produits_partenaire_id_partenaire_id_fk": {
          "name": "Sollicitation_Produits_partenaire_id_partenaire_id_fk",
          "tableFrom": "Sollicitation_Produits",
          "tableTo": "partenaire",
          "columnsFrom": [
            "partenaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "Sollicitation_Produits_produit_id_produit_code_produit_id_code_fk": {
          "name": "Sollicitation_Produits_produit_id_produit_code_produit_id_code_fk",
          "tableFrom": "Sollicitation_Produits",
          "tableTo": "produit",
          "columnsFrom": [
            "produit_id",
            "produit_code"
          ],
          "columnsTo": [
            "id",
            "code"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "Sollicitation_Produits_produit_id_produit_code_partenaire_id_pk": {
          "name": "Sollicitation_Produits_produit_id_produit_code_partenaire_id_pk",
          "columns": [
            "produit_id",
            "produit_code",
            "partenaire_id"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.Sollicitation_Interventions": {
      "name": "Sollicitation_Interventions",
      "schema": "",
      "columns": {
        "partenaire_id": {
          "name": "partenaire_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "intervention_id": {
          "name": "intervention_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "etat": {
          "name": "etat",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "Sollicitation_Interventions_partenaire_id_partenaire_id_fk": {
          "name": "Sollicitation_Interventions_partenaire_id_partenaire_id_fk",
          "tableFrom": "Sollicitation_Interventions",
          "tableTo": "partenaire",
          "columnsFrom": [
            "partenaire_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "Sollicitation_Interventions_intervention_id_intervention_id_fk": {
          "name": "Sollicitation_Interventions_intervention_id_intervention_id_fk",
          "tableFrom": "Sollicitation_Interventions",
          "tableTo": "intervention",
          "columnsFrom": [
            "intervention_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "Sollicitation_Interventions_partenaire_id_intervention_id_pk": {
          "name": "Sollicitation_Interventions_partenaire_id_intervention_id_pk",
          "columns": [
            "partenaire_id",
            "intervention_id"
          ]
        }
      },
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
File: core/database/migrations/meta/_journal.json
================================================
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1743786352393,
      "tag": "0000_stale_lenny_balinger",
      "breakpoints": true
    }
  ]
}


================================================
File: core/utils/logger.js
================================================
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

// Fonction pour formatter les messages d'erreur
logger.formatError = (error) => {
  if (error instanceof Error) {
    return {
      message: error.message,
      stack: error.stack,
      ...error
    };
  }
  return error;
};

module.exports = logger;



================================================
File: init-db/nit-multiple-dbs.sh
================================================
#!/bin/bash
set -e

# Charge les variables depuis le fichier montÃ©
source /tmp/.env

# Debug: Affiche les variables chargÃ©es
echo "KEYCLOAK_DB_USER: $KEYCLOAK_DB_USER" >&2
echo "APP_DB_USER: $APP_DB_USER" >&2

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
    CREATE USER "$KEYCLOAK_DB_USER" WITH PASSWORD '$KEYCLOAK_DB_PASSWORD';
    CREATE DATABASE "$KEYCLOAK_DB_NAME" OWNER "$KEYCLOAK_DB_USER";
    
    CREATE USER "$APP_DB_USER" WITH PASSWORD '$APP_DB_PASSWORD';
    CREATE DATABASE "$APP_DB_NAME" OWNER "$APP_DB_USER";
EOSQL


================================================
File: keycloak-setup/keycloak-setup-back.js
================================================
require('dotenv').config({ path: '../.env' }); // Charge le fichier .env à la racine

const KeycloakAdminClient = require('@keycloak/keycloak-admin-client').default;
const logger = require('../core/utils/logger');

// Configuration validation
const REQUIRED_ENV_VARS = [
  'KEYCLOAK_URL',
  'KEYCLOAK_ADMIN',
  'KEYCLOAK_ADMIN_PASSWORD',
  'KEYCLOAK_REALM',
  'KEYCLOAK_CLIENT_ID',
  'KEYCLOAK_CLIENT_SECRET'
];

// Verify all required variables are present
for (const envVar of REQUIRED_ENV_VARS) {
  if (!process.env[envVar]) {
    logger.error(`❌ Missing environment variable: ${envVar}`);
    process.exit(1);
  }
}

const keycloakConfig = {
  baseUrl: process.env.KEYCLOAK_URL,
  realmName: 'master'
};

const adminClient = new KeycloakAdminClient(keycloakConfig);

async function setupKeycloak() {
  try {
    logger.info('🔑 Authenticating to Keycloak...');
    
    await adminClient.auth({
      username: process.env.KEYCLOAK_ADMIN,
      password: process.env.KEYCLOAK_ADMIN_PASSWORD,
      grantType: 'password',
      clientId: 'admin-cli'
    });

    logger.info('✅ Successfully authenticated');

    // Realm setup
    logger.info(`🔄 Checking realm ${process.env.KEYCLOAK_REALM}...`);
    const realmExists = (await adminClient.realms.find())
      .some(r => r.realm === process.env.KEYCLOAK_REALM);

    if (!realmExists) {
      await adminClient.realms.create({
        realm: process.env.KEYCLOAK_REALM,
        enabled: true,
        displayName: `${process.env.KEYCLOAK_REALM} Realm`,
        loginTheme: "keycloak",
        accountTheme: "keycloak"
      });
      logger.info(`✨ Created realm: ${process.env.KEYCLOAK_REALM}`);
    } else {
      logger.info(`ℹ️ Realm ${process.env.KEYCLOAK_REALM} already exists`);
    }

    // Client setup
    logger.info(`🔍 Checking client ${process.env.KEYCLOAK_CLIENT_ID}...`);
    const clients = await adminClient.clients.find({
      realm: process.env.KEYCLOAK_REALM,
      clientId: process.env.KEYCLOAK_CLIENT_ID
    });

    if (clients.length === 0) {
      await adminClient.clients.create({
        realm: process.env.KEYCLOAK_REALM,
        clientId: process.env.KEYCLOAK_CLIENT_ID,
        secret: process.env.KEYCLOAK_CLIENT_SECRET,
        redirectUris: [process.env.KEYCLOAK_CALLBACK_URL || 'http://localhost:2000/*'],
        webOrigins: ['*'],
        publicClient: false,
        standardFlowEnabled: true,
        directAccessGrantsEnabled: true,
        serviceAccountsEnabled: true,
        authorizationServicesEnabled: true,
        enabled: true,
        protocol: 'openid-connect',
        attributes: {
          'post.logout.redirect.uris': '+',
          'exclude.session.state.from.auth.response': 'false'
        }
      });
      logger.info(`🎯 Created client: ${process.env.KEYCLOAK_CLIENT_ID}`);
    } else {
      logger.info(`ℹ️ Client ${process.env.KEYCLOAK_CLIENT_ID} already exists`);
    }

    logger.info('🏁 Keycloak setup completed successfully');
  } catch (error) {
    logger.error('💥 Keycloak setup failed:', error);
    process.exit(1);
  }
}

// Execute setup
setupKeycloak();


================================================
File: keycloak-setup/keycloak-setup-front.js
================================================
require('dotenv').config({ path: '../.env' });

const KeycloakAdminClient = require('@keycloak/keycloak-admin-client').default;

// Configuration avec valeurs par défaut
const config = {
  url: process.env.VITE_KEYCLOAK_URL || process.env.KEYCLOAK_URL || 'http://localhost:8080',
  realm: process.env.VITE_KEYCLOAK_REALM || 'dcat_realm', // On utilise le realm existant
  clientId: 'frontend_cli_id',
  adminUser: process.env.KEYCLOAK_ADMIN || 'admin',
  adminPass: process.env.KEYCLOAK_ADMIN_PASSWORD || 'admin',
  appUser: process.env.APP_USER || 'frontend_user',
  appPassword: process.env.APP_PASSWORD || 'frontend_password123',
  appEmail: process.env.APP_EMAIL || 'frontend.user@example.com'
};

console.log('⚙️ Configuration utilisée :');
console.log(config);

const adminClient = new KeycloakAdminClient({
  baseUrl: config.url,
  realmName: 'master',
});

async function setupKeycloak() {
  try {
    // 1. Authentification admin
    console.log('🔐 Connexion à Keycloak...');
    await adminClient.auth({
      username: config.adminUser,
      password: config.adminPass,
      grantType: 'password',
      clientId: 'admin-cli',
    });
    console.log('✅ Connecté avec succès');

    // 2. Vérification/création du realm si nécessaire
    console.log(`🔄 Vérification du realm ${config.realm}...`);
    const realmExists = (await adminClient.realms.find()).some(r => r.realm === config.realm);
    
    if (!realmExists) {
      await adminClient.realms.create({
        realm: config.realm,
        enabled: true,
        sslRequired: process.env.NODE_ENV === 'production' ? 'external' : 'none',
        loginTheme: 'keycloak'
      });
      console.log(`🆕 Realm créé : ${config.realm}`);
    } else {
      console.log(`ℹ️ Realm existant : ${config.realm}`);
    }

    // 3. Création du client frontend
    console.log(`🔍 Vérification du client ${config.clientId}...`);
    const clients = await adminClient.clients.find({
      realm: config.realm,
      clientId: config.clientId
    });

    if (clients.length === 0) {
      await adminClient.clients.create({
        realm: config.realm,
        clientId: config.clientId,
        publicClient: true,
        redirectUris: [
          'http://localhost:2000/*',
          'http://localhost:5173/*',
          `${process.env.APP_URL}/*` || ''
        ].filter(Boolean),
        webOrigins: ['*'],
        standardFlowEnabled: true,
        directAccessGrantsEnabled: true,
        enabled: true,
        attributes: {
          'post.logout.redirect.uris': '+',
          'exclude.session.state.from.auth.response': 'false'
        }
      });
      console.log(`🆕 Client frontend créé : ${config.clientId}`);
    } else {
      console.log(`ℹ️ Client frontend existant : ${config.clientId}`);
    }

    // 4. Création du rôle 'frontend_user' spécifique
    console.log(`👔 Création du rôle 'frontend_user'...`);
    try {
      await adminClient.roles.create({
        realm: config.realm,
        name: 'frontend_user'
      });
      console.log(`🆕 Rôle 'frontend_user' créé`);
    } catch (roleError) {
      if (roleError.response?.status !== 409) {
        throw roleError;
      }
      console.log(`ℹ️ Rôle 'frontend_user' existe déjà`);
    }

    // 5. Création de l'utilisateur frontend spécifique
    console.log(`👤 Création de l'utilisateur ${config.appUser}...`);
    const users = await adminClient.users.find({
      realm: config.realm,
      username: config.appUser
    });

    if (users.length === 0) {
      const newUser = await adminClient.users.create({
        realm: config.realm,
        username: config.appUser,
        email: config.appEmail,
        enabled: true,
        credentials: [{
          type: 'password',
          value: config.appPassword,
          temporary: false
        }]
      });

      // Assignation du rôle spécifique
      const role = await adminClient.roles.findOneByName({
        realm: config.realm,
        name: 'frontend_user'
      });
      
      await adminClient.users.addRealmRoleMappings({
        realm: config.realm,
        id: newUser.id,
        roles: [{
          id: role.id,
          name: role.name
        }]
      });

      console.log(`🆕 Utilisateur frontend créé : ${config.appUser}`);
      console.log(`🔑 Identifiants : ${config.appUser}/${config.appPassword}`);
      console.log(`🎯 Rôle attribué : frontend_user`);
    } else {
      console.log(`ℹ️ Utilisateur existant : ${config.appUser}`);
    }

    console.log('🎉 Configuration frontend terminée avec succès !');
    console.log(`🌐 URL du realm: ${config.url}/realms/${config.realm}`);
    console.log(`🔑 Client ID: ${config.clientId}`);

  } catch (error) {
    console.error('💥 Erreur lors de la configuration:', error.response?.data || error.message);
    process.exit(1);
  }
}

setupKeycloak();


================================================
File: modules/administration/accounting/controllers/accounting.controller.js
================================================
ï»¿


================================================
File: modules/administration/accounting/controllers/partner.controller.js
================================================
import { partenaire } from "../../../../core/database/models";
import logger from "../../../core/logger";

export const createPartner = async (req, res) => {
  const { nom, telephone, email, specialite, localisation, type, entiteId} = req.body;
  try {
    const partner = await partenaire.create({
      nom,
      telephone,
      email,
      specialite,
      localisation,
      type,
      entiteId,
    });
    res.status(201).json(partner);
  } catch (error) {
    logger.error(error);
    res.status(500).json({ message: "Erreur lors de la crÃ©ation du partenaire" });
  }
};


export const getPartners = async (req, res) => {
  try {
    const partners = await partenaire.findMany();
    res.json(partners);
  } catch (error) {
    logger.error(error);
    res.status(500).json({ message: "Erreur lors de la rÃ©cupÃ©ration des partenaires" });
  }
}; 


export const getPartnerById = async (req, res) => {
  const { id } = req.params;
  try {
    const partner = await partenaire.findUnique({ where: { id } });
    res.json(partner);
  } catch (error) {
    logger.error(error);
    res.status(500).json({ message: "Erreur lors de la rÃ©cupÃ©ration du partenaire" });
  }
};     


export const updatePartner = async (req, res) => {
  const { id } = req.params;
  const { nom, telephone, email, specialite, localisation, type, entiteId } = req.body;
  try {
    const partner = await partenaire.update({ where: { id }, data: { nom, telephone, email, specialite, localisation, type, entiteId } });
    res.json(partner);
  } catch (error) {
    logger.error(error);
    res.status(500).json({ message: "Erreur lors de la mise Ã  jour du partenaire" });
  }
};


export const deletePartner = async (req, res) => {
  const { id } = req.params;
  try {
    await partenaire.delete({ where: { id } });
    res.json({ message: "Partenaire supprimÃ© avec succÃ¨s" });
  } catch (error) {
    logger.error(error);
    res.status(500).json({ message: "Erreur lors de la suppression du partenaire" });
  }
};

module.exports = {
  createPartner,
  getPartners,
  getPartnerById,
  updatePartner,
  deletePartner,
};



================================================
File: modules/administration/accounting/routes/accounting.routes.js
================================================
ï»¿


================================================
File: modules/administration/accounting/routes/partner.route.js
================================================
import { express } from "express";
import { createPartner,
         getPartners, 
         getPartnerById, 
         updatePartner, 
         deletePartner } from "../controllers/partner.controller";


const router = express.Router();

router.post('/', createPartner);
router.get('/', getPartners); 
router.get('/:id', getPartnerById);
router.put('/:id', updatePartner);
router.delete('/:id', deletePartner); 

export default router;







================================================
File: modules/clients/controllers/clients.controller.js
================================================
ï»¿const db = require('../../core/database');
const Model = db.models.Clients;

exports.getAll = async (req, res) => {
    try {
        const data = await Model.findAll();
        res.json(data);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.create = async (req, res) => {
    try {
        const newItem = await Model.create(req.body);
        res.status(201).json(newItem);
    } catch (error) {
        res.status(400).json({ message: error.message });
    }
};

// Ajoutez ici les autres mÃƒÂ©thodes CRUD...



================================================
File: modules/clients/routes/clients.routes.js
================================================
ï»¿



================================================
File: modules/dashboard/controllers/dashboard.controller.js
================================================
ï»¿


================================================
File: modules/dashboard/routes/dashboard.routes.js
================================================
ï»¿




================================================
File: modules/interventions/controllers/interventions.controller.js
================================================
ï»¿const interventionService = require('../services/interventions.service');

module.exports = {
  getAll: (req, res, next) => {
    try {
      const interventions = interventionService.getAllInterventions();
      res.json(interventions);
    } catch (err) {
      next(err);
    }
  },
  create: (req, res, next) => {
    try {
      const newIntervention = interventionService.createIntervention(req.body);
      res.status(201).json(newIntervention);
    } catch (err) {
      next(err);
    }
  }
};


================================================
File: modules/interventions/routes/interventions.routes.js
================================================
ï»¿const express = require('express');
const router = express.Router();
const controller = require('../controllers/interventions.controller');
const { protect } = require('../../../core/auth/middleware');

// Route publique
router.get('/', controller.getAll);

// Route protÃ©gÃ©e
router.post('/', protect(), controller.create);

module.exports = router;


================================================
File: modules/interventions/services/interventions.service.js
================================================
const { interventions } = require('../tests/interventions.mock');



module.exports = {
  getAllInterventions: () => {
    return interventions;
  },
  createIntervention: (interventionData) => {
    const newIntervention = {
      id: interventions.length + 1,
      ...interventionData,
      status: "nouveau",
      createdAt: new Date()
    };
    interventions.push(newIntervention);
    return newIntervention;
  }
};


================================================
File: modules/interventions/tests/interventions.mock.js
================================================
module.exports = {
  interventions: [
    {
      id: 1,
      title: "Panne Ã©lectrique",
      client: "Client A",
      status: "en cours",
      technician: "Jean Dupont",
      createdAt: "2025-03-10T09:15:00Z"
    },
    {
      id: 2,
      title: "Installation logiciel",
      client: "Client B",
      status: "terminÃ©",
      technician: "Marie Martin",
      createdAt: "2025-03-05T14:45:00Z"
    }
  ]
};


================================================
File: modules/projects/controllers/projects.controller.js
================================================
ï»¿


================================================
File: modules/projects/models/projects.model.js
================================================
ï»¿


================================================
File: modules/projects/routes/projects.routes.js
================================================
ï»¿



================================================
File: modules/stocks/controllers/categorie.controller.js
================================================
const categorieService = require("../services/categorie.service");

const createCategorie = async (req, res) => {
  try {
    const result = await categorieService.createCategorie(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getCategories = async (req, res) => {
  try {
    const result = await categorieService.getCategories();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getCategorieById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await categorieService.getCategorieById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateCategorie = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await categorieService.updateCategorie(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteCategorie = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await categorieService.deleteCategorie(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createCategorie,
  getCategories,
  getCategorieById,
  updateCategorie,
  deleteCategorie,
};



================================================
File: modules/stocks/controllers/entite.controller.js
================================================
const entiteService = require("../services/entite.service");

const createEntite = async (req, res) => {
  try {
    const result = await entiteService.createEntite(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getEntites = async (req, res) => {
  try {
    const result = await entiteService.getEntites();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getEntiteById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await entiteService.getEntiteById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateEntite = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await entiteService.updateEntite(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteEntite = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await entiteService.deleteEntite(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createEntite,
  getEntites,
  getEntiteById,
  updateEntite,
  deleteEntite,
};



================================================
File: modules/stocks/controllers/famille.controller.js
================================================
const familleService = require("../services/famille.service");

// CREATE
const createFamille = async (req, res) => {
  try {
    if (!req.body.libelle) {
      return res.status(400).json({ error: "Le libellÃ© est requis" });
    }
    const result = await familleService.createFamille(req.body);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la crÃ©ation",
      details: error.message 
    });
  }
};

// READ ALL
const getFamilles = async (req, res) => {
  try {
    const result = await familleService.getFamilles();
    res.json(result || []);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// READ ONE
const getFamilleById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await familleService.getFamilleById(id);
    if (!result) {
      return res.status(404).json({ error: "Famille non trouvÃ©e" });
    }
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la rÃ©cupÃ©ration",
      details: error.message 
    });
  }
};

// UPDATE
const updateFamille = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await familleService.updateFamille(id, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la mise Ã  jour",
      details: error.message 
    });
  }
};

// DELETE
const deleteFamille = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    await familleService.deleteFamille(id);
    res.json({ message: "Famille supprimÃ©e avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ 
      error: "Erreur lors de la suppression",
      details: error.message 
    });
  }
};

module.exports = {
  createFamille,
  getFamilles,
  getFamilleById,
  updateFamille,
  deleteFamille
};


================================================
File: modules/stocks/controllers/marque.controller.js
================================================
const marqueService = require("../services/marque.service");

const createMarque = async (req, res) => {
  try {
    const result = await marqueService.createMarque(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getMarques = async (req, res) => {
  try {
    const result = await marqueService.getMarques();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getMarqueById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.getMarqueById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateMarque = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.updateMarque(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteMarque = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await marqueService.deleteMarque(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createMarque,
  getMarques,
  getMarqueById,
  updateMarque,
  deleteMarque,
};



================================================
File: modules/stocks/controllers/modele.controller.js
================================================
const modeleService = require("../services/modele.service");

const createModele = async (req, res) => {
  try {
    const result = await modeleService.createModele(req.body);
    return res.status(201).json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getModeles = async (req, res) => {
  try {
    const result = await modeleService.getModeles();
    return res.status(200).json(result || []);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const getModeleById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.getModeleById(Number(id));
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const updateModele = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.updateModele(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

const deleteModele = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: "ID invalide" });
    }
    const result = await modeleService.deleteModele(id);
    return res.json(result);
  } catch (error) {
    res
      .status(500)
      .json({ error: "une erreur est survenue", details: error.message });
  }
};

module.exports = {
  createModele,
  getModeles,
  getModeleById,
  updateModele,
  deleteModele,
};



================================================
File: modules/stocks/controllers/stocks.controller.js
================================================
ï»¿// const stockService = require('../services/stocks.service');

// module.exports = {
//   getAll: (req, res, next) => {
//     try {
//       const stockItems = stockService.getAllStockItems();
//       res.json(stockItems);
//     } catch (err) {
//       next(err);
//     }
//   },
//   create: (req, res, next) => {
//     try {
//       const newItem = stockService.createStockItem(req.body);
//       res.status(201).json(newItem);
//     } catch (err) {
//       next(err);
//     }
//   }
// };


================================================
File: modules/stocks/routes/categorie.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/categorie.controller");

// CRUD Routes
router.post("/", controller.createCategorie);
router.get("/", controller.getCategories);
router.get("/:id", controller.getCategorieById);
router.put("/:id", controller.updateCategorie);
router.delete("/:id", controller.deleteCategorie);

module.exports = router;



================================================
File: modules/stocks/routes/entite.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/entite.controller");

// CRUD Routes
router.post("/", controller.createEntite);
router.get("/", controller.getEntites);
router.get("/:id", controller.getEntiteById);
router.put("/:id", controller.updateEntite);
router.delete("/:id", controller.deleteEntite);

module.exports = router;



================================================
File: modules/stocks/routes/famille.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/famille.controller");

// CRUD Routes
router.post("/", controller.createFamille);
router.get("/", controller.getFamilles);
router.get("/:id", controller.getFamilleById);
router.put("/:id", controller.updateFamille);
router.delete("/:id", controller.deleteFamille);

module.exports = router;


================================================
File: modules/stocks/routes/marque.routes.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/marque.controller");

// CRUD Routes
router.post("/", controller.createMarque);
router.get("/", controller.getMarques);
router.get("/:id", controller.getMarqueById);
router.put("/:id", controller.updateMarque);
router.delete("/:id", controller.deleteMarque);

module.exports = router;



================================================
File: modules/stocks/routes/modele.route.js
================================================
const express = require("express");
const router = express.Router();
const controller = require("../controllers/modele.controller");

// CRUD Routes
router.post("/", controller.createModele);
router.get("/", controller.getModeles);
router.get("/:id", controller.getModeleById);
router.put("/:id", controller.updateModele);
router.delete("/:id", controller.deleteModele);

module.exports = router;



================================================
File: modules/stocks/routes/stocks.routes.js
================================================
ï»¿const express = require("express");
const router = express.Router();

// Import des sous-routes
const familleRoutes = require("./famille.routes");
const categorieRoutes = require("./categorie.routes");
const marqueRoutes = require("./marque.routes");
const modeleRoutes = require("./modele.route");
const entiteRoutes = require("./entite.routes");

// Montage des routes
router.use("/familles", familleRoutes);
router.use("/categories", categorieRoutes);
router.use("/marques", marqueRoutes);
router.use("/modeles", modeleRoutes);
router.use("/entites", entiteRoutes);

module.exports = router;



================================================
File: modules/stocks/services/categorie.service.js
================================================
const { eq } = require("drizzle-orm");
const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { categorie } = require("../../../core/database/models");

const createCategorie=async(data)=>{
    const [result]=await db.insert(categorie).values(data).returning()
    return result
}

const getCategories=async()=>{
    return await db.select().from(categorie);

}

const getCategorieById=async(id)=>{
    const [result]=await db.select().from(categorie).where(eq(categorie.id,id))
    return result
}

const updateCategorie=async(id,data)=>{
    const [result]=await db.update(categorie).set(data).where(eq(categorie.id,id)).returning()
    return result
}

const deleteCategorie=async(id)=>{
    const [result]=await db.delete(categorie).where(eq(categorie.id,id)).returning()
    return result
}

module.exports={
    createCategorie,
    getCategories, 
    getCategorieById,
    updateCategorie,
    deleteCategorie
}


================================================
File: modules/stocks/services/entite.service.js
================================================
const { eq } = require("drizzle-orm");
const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { entite } = require("../../../core/database/models");

const createEntite=async(data)=>{
    const [result]=await db.insert(entite).values(data).returning()
    return result
}

const getEntites=async()=>{
    return await db.select().from(entite);

}

const getEntiteById=async(id)=>{
    const [result]=await db.select().from(entite).where(eq(entite.id,id))
    return result
}

const updateEntite=async(id,data)=>{
    const [result]=await db.update(entite).set(data).where(eq(entite.id,id)).returning()
    return result
}

const deleteEntite=async(id)=>{
    const [result]=await db.delete(entite).where(eq(entite.id,id)).returning()
    return result
}

module.exports={
    createEntite,
    getEntites, 
    getEntiteById,
    updateEntite,
    deleteEntite
}


================================================
File: modules/stocks/services/famille.service.js
================================================
// const { eq } = require("drizzle-orm");
// const dbConfig = require("../../../core/database/config");
// const { famille } = require("../../../core/database/models");

// // Solution robuste pour rÃ©cupÃ©rer db correctement
// const db = dbConfig.db || dbConfig.default;

// // Debug crucial
// console.log("MÃ©thodes Drizzle disponibles:", {
//   insert: typeof db.insert,
//   select: typeof db.select,
//   update: typeof db.update,
//   delete: typeof db.delete
// });

const { eq } = require("drizzle-orm");
const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { famille } = require("../../../core/database/models");

// CRUD complet avec Drizzle
const createFamille = async (data) => {
  const [result] = await db.insert(famille).values(data).returning();
  return result;
};

const getFamilles = async () => {
  return await db.select().from(famille);
};

const getFamilleById = async (id) => {
  const [result] = await db.select().from(famille).where(eq(famille.id, id));
  return result;
};

const updateFamille = async (id, data) => {
  const [result] = await db
    .update(famille)
    .set(data)
    .where(eq(famille.id, id))
    .returning();
  return result;
};

const deleteFamille = async (id) => {
  const [result] = await db
    .delete(famille)
    .where(eq(famille.id, id))
    .returning();
  return result;
};

module.exports = {
  createFamille,
  getFamilles,
  getFamilleById,
  updateFamille,
  deleteFamille,
};



================================================
File: modules/stocks/services/marque.service.js
================================================
const { eq } = require("drizzle-orm");
const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { marque } = require("../../../core/database/models");

const createMarque=async(data)=>{
    const [result]=await db.insert(marque).values(data).returning()
    return result
}

const getMarques=async()=>{
    return await db.select().from(marque);

}

const getMarqueById=async(id)=>{
    const [result]=await db.select().from(marque).where(eq(marque.id,id))
    return result
}

const updateMarque=async(id,data)=>{
    const [result]=await db.update(marque).set(data).where(eq(marque.id,id)).returning()
    return result
}

const deleteMarque=async(id)=>{
    const [result]=await db.delete(marque).where(eq(marque.id,id)).returning()
    return result
}

module.exports={
    createMarque,
    getMarques, 
    getMarqueById,
    updateMarque,
    deleteMarque
}


================================================
File: modules/stocks/services/modele.service.js
================================================
const { eq } = require("drizzle-orm");
const db = require("../utils/drizzle-wrapper"); // <- Votre wrapper local
const { modele } = require("../../../core/database/models");

const createModele=async(data)=>{
    const [result]=await db.insert(modele).values(data).returning()
    return result
}

const getModeles=async()=>{
    return await db.select().from(modele);

}

const getModeleById=async(id)=>{
    const [result]=await db.select().from(modele).where(eq(modele.id,id))
    return result
}

const updateModele=async(id,data)=>{
    const [result]=await db.update(modele).set(data).where(eq(modele.id,id)).returning()
    return result
}

const deleteModele=async(id)=>{
    const [result]=await db.delete(modele).where(eq(modele.id,id)).returning()
    return result
}

module.exports={
    createModele,
    getModeles, 
    getModeleById,
    updateModele,
    deleteModele
}


================================================
File: modules/stocks/services/stocks.service.js
================================================
// const { stocks } = require('../tests/stocks.mock');

// module.exports = {
//   getAllStockItems: () => {
//     return stocks;
//   },
//   createStockItem: (itemData) => {
//     const newItem = {
//       id: stocks.length + 1,
//       ...itemData,
//       last_updated: new Date()
//     };
//     stocks.push(newItem);
//     return newItem;
//   }
// };


================================================
File: modules/stocks/tests/stocks.mock.js
================================================
module.exports = {
  stocks: [
    {
      id: 1,
      item_name: "CÃ¢ble HDMI",
      quantity: 25,
      location: "EntrepÃ´t A",
      last_updated: "2025-03-01T10:00:00Z"
    },
    {
      id: 2,
      item_name: "Clavier sans fil",
      quantity: 12,
      location: "EntrepÃ´t B",
      last_updated: "2025-03-15T14:30:00Z"
    }
  ]
};


================================================
File: modules/stocks/utils/drizzle-wrapper.js
================================================
/**
 * ⚠️ [ARCHITECTURE - SOLUTION DE CONTOURNEMENT] ⚠️
 *
 * Problème initial :
 * - Le fichier central config.js utilise des ES Modules (import/export)
 * - Le reste du projet utilise CommonJS (require/module.exports)
 * - Résultat : db.insert() non reconnu dans famille.service.js
 *
 * Pourquoi ce fichier existe :
 * 1. Évite de modifier config.js (fichier partagé avec d'autres modules)
 * 2. Contourne l'incompatibilité des systèmes de modules
 * 3. Garantit une instance Drizzle fonctionnelle avec :
 *    - Les mêmes paramètres de connexion
 *    - Le même schéma de base de données
 *
 * Solution technique :
 * - Crée une nouvelle instance Drizzle locale
 * - Réutilise les variables d'environnement existantes
 * - Maintient l'isolation du module
 *
 * Risques à connaître :
 * - Double instance de Pool PostgreSQL (augmente légèrement les connexions)
 * - Nécessite de synchroniser les changements de schéma manuellement
 *
 * Alternatives envisagées et rejetées :
 * - Convertir tout le projet en ES Modules (trop intrusif)
 * - Modifier config.js (risque pour les autres modules)
 */

// [Mon module stocks] → [drizzle-wrapper local] → PostgreSQL
//             ↑
//             └─ [N'utilise PAS config.js]

// modules/stocks/utils/drizzle-wrapper.js
const { drizzle } = require("drizzle-orm/node-postgres");
const { Pool } = require("pg");
const schema = require("../../../core/database/models");

// Config locale (utilise les mêmes variables d'environnement de .env)
const pool = new Pool({
  // host: process.env.DB_HOST,
  host: "172.31.3.7",
  port: process.env.DB_PORT,
  user: process.env.APP_DB_USER,
  password: process.env.APP_DB_PASSWORD,
  database: process.env.APP_DB_NAME,
});

module.exports = drizzle(pool, { schema });



================================================
File: modules/users/digest.txt
================================================
Directory structure:
â””â”€â”€ users/
    â”œâ”€â”€ controllers/
    â”‚   â”œâ”€â”€ sync.controller.js
    â”‚   â””â”€â”€ users.controller.js
    â”œâ”€â”€ routes/
    â”‚   â””â”€â”€ users.routes.js
    â”œâ”€â”€ services/
    â”‚   â””â”€â”€ users.service.js
    â””â”€â”€ tests/

================================================
File: controllers/sync.controller.js
================================================
const { db } = require('../../../core/database/config');
const { employes } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');
const logger = require('../../../core/utils/logger');

module.exports = {
  syncUser: async (req, res) => {
    const token = req.kauth.grant.access_token;
    const { email } = req.body; // On ne reÃƒÂ§oit plus que l'email (le reste est en BD mÃƒÂ©tier)

    // Validation email cohÃƒÂ©rent
    if (token.content.email !== email) {
      logger.warn('IncohÃƒÂ©rence email/token', {
        tokenEmail: token.content.email,
        providedEmail: email
      });
      return res.status(400).json({ error: "Email ne correspond pas au token" });
    }

    try {
      // Upsert : CrÃƒÂ©e ou met ÃƒÂ  jour UNIQUEMENT l'ID Keycloak + email
      await db.insert(employes)
        .values({
          keycloak_id: token.content.sub, // Lien avec Keycloak
          email: token.content.email,
          status: 'actif' // Valeur par dÃƒÂ©faut
        })
        .onConflictDoUpdate({
          target: employes.keycloak_id,
          set: { email: token.content.email } // MAJ email si changÃƒÂ© dans Keycloak
        });

      res.status(204).end();
    } catch (error) {
      logger.error('Erreur de synchronisation', error);
      res.status(500).json({ error: "Ãƒâ€°chec de la synchronisation" });
    }
  }
};


================================================
File: controllers/users.controller.js
================================================
const logger = require('../../../core/utils/logger');
const userService = require('../services/users.service');

module.exports = {
  /**
   * RÃƒÂ©cupÃƒÂ¨re tous les utilisateurs (pour admin)
   */
  getAllUsers: async (req, res, next) => {
    try {
      const { page = 1, limit = 10 } = req.query;
      const users = await userService.getAllUsers(parseInt(page), parseInt(limit));
      logger.info(`RÃƒÂ©cupÃƒÂ©ration de ${users.length} utilisateurs`);
      res.json(users);
    } catch (error) {
      logger.error('Ãƒâ€°chec de rÃƒÂ©cupÃƒÂ©ration des utilisateurs:', error);
      next(error);
    }
  },

  /**
   * RÃƒÂ©cupÃƒÂ¨re le profil de l'utilisateur connectÃƒÂ©
   */
  getMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content; // ID Keycloak

    try {
      const user = await userService.getUserByKeycloakId(sub);
      if (!user) return res.status(404).json({ error: "Utilisateur non trouvÃƒÂ©" });

      // Ne renvoie que les donnÃƒÂ©es autorisÃƒÂ©es
      res.json({
        email: user.email,
        nom: user.nom,
        prenom: user.prenom,
        service: user.service // Champ mÃƒÂ©tier
      });
    } catch (error) {
      logger.error('Erreur lors de la rÃƒÂ©cupÃƒÂ©ration du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Erreur serveur" });
    }
  },

  /**
   * Met ÃƒÂ  jour le profil de l'utilisateur connectÃƒÂ©
   */
  updateMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content;
    const updates = req.body;

    try {
      // Liste des champs autorisÃƒÂ©s ÃƒÂ  ÃƒÂªtre modifiÃƒÂ©s
      const allowedFields = ["tel", "adresse"];
      const filteredUpdates = Object.keys(updates)
        .filter(key => allowedFields.includes(key))
        .reduce((obj, key) => ({ ...obj, [key]: updates[key] }), {});

      if (Object.keys(filteredUpdates).length === 0) {
        return res.status(400).json({ error: "Aucun champ modifiable fourni" });
      }

      await userService.updateUserProfile(sub, filteredUpdates);
      res.status(204).end();
    } catch (error) {
      logger.error('Ãƒâ€°chec de la mise ÃƒÂ  jour du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Ãƒâ€°chec de la mise ÃƒÂ  jour" });
    }
  }
};


================================================
File: routes/users.routes.js
================================================
Ã¯Â»Â¿//


const express = require('express');
const router = express.Router();
const { protect } = require('../../../core/auth/middleware');
const UsersController = require('../controllers/users.controller');
const SyncController = require('../controllers/sync.controller');

// Synchronisation Keycloak Ã¢â€ â€™ BD MÃƒÂ©tier
router.post('/sync', protect(), SyncController.syncUser);

// RÃƒÂ©cupÃƒÂ©ration du profil utilisateur
router.get('/me', protect(), UsersController.getMyProfile);

// Mise ÃƒÂ  jour du profil (ex: tÃƒÂ©lÃƒÂ©phone)
router.patch('/me', protect(), UsersController.updateMyProfile);

// RÃƒÂ©cupÃƒÂ©ration de tous les utilisateurs (avec pagination)
// router.get('/', protect(['admin']), UsersController.getAllUsers);
router.get('/', protect(), UsersController.getAllUsers);


module.exports = router;


================================================
File: services/users.service.js
================================================
const { db } = require('../../../core/database/config');
const { employes } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');

module.exports = {
  // RÃƒÂ©cupÃƒÂ¨re un utilisateur par son ID Keycloak
  getUserByKeycloakId: async (keycloakId) => {
    return await db.query.employes.findFirst({
      where: eq(employes.keycloak_id, keycloakId)
    });
  },

  // Met ÃƒÂ  jour les donnÃƒÂ©es modifiables (ex: tÃƒÂ©lÃƒÂ©phone)
  updateUserProfile: async (keycloakId, data) => {
    const allowedFields = ["tel", "adresse"]; // Champs autorisÃƒÂ©s
    const updates = Object.keys(data)
      .filter(key => allowedFields.includes(key))
      .reduce((obj, key) => ({ ...obj, [key]: data[key] }), {});

    await db.update(employes)
      .set(updates)
      .where(eq(employes.keycloak_id, keycloakId));
  },

  getAllUsers: async (page = 1, limit = 10) => {
    try {
      return await db.select({
        id: employes.id,
        email: employes.email,
        prenom: employes.prenom,
        nom: employes.nom,
        status: employes.status,
        // service: employes.service
      })
      .from(employes)
      .orderBy(employes.nom)
      .limit(limit)
      .offset((page - 1) * limit)
      .execute();
    } catch (error) {
      throw new Error(`Ãƒâ€°chec de rÃƒÂ©cupÃƒÂ©ration des utilisateurs: ${error.message}`);
    }
  },
};





================================================
File: modules/users/controllers/sync.controller.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonctions } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');
const logger = require('../../../core/utils/logger');

module.exports = {
  syncUser: async (req, res) => {
    const token = req.kauth.grant.access_token;
    const { email, firstName, lastName } = req.body;

    // Validation email/token
    if (!token?.content?.email || !email) {
      logger.warn('Token ou email manquant', { token, email });
      return res.status(400).json({ error: "Token ou email invalide" });
    }

    if (token.content.email !== email) {
      logger.warn('IncohÃ©rence email/token', {
        tokenEmail: token.content.email,
        providedEmail: email,
        userId: token.content.sub
      });
      return res.status(400).json({ error: "Email ne correspond pas au token" });
    }

    try {
      // RÃ©cupÃ©ration de l'ID de la fonction Technicien
      const technicien = await db.select()
        .from(fonctions)
        .where(eq(fonctions.nom, 'Technicien'))
        .limit(1);

      if (!technicien || technicien.length === 0) {
        throw new Error('La fonction Technicien n\'existe pas en base');
      }

      const fonctionId = technicien[0].id;

      // DonnÃ©es utilisateur
      const userData = {
        keycloak_id: token.content.sub,
        email: token.content.email,
        nom: lastName || token.content.family_name || 'Non spÃ©cifiÃ©',
        prenom: firstName || token.content.given_name || 'Non spÃ©cifiÃ©',
        status: 'actif',
        fonction_id: fonctionId,
        created_at: new Date(),
        updated_at: new Date()
      };

      // Upsert
      await db.insert(employes)
        .values(userData)
        .onConflictDoUpdate({
          target: employes.keycloak_id,
          set: {
            email: userData.email,
            nom: userData.nom,
            prenom: userData.prenom,
            fonction_id: fonctionId,
            updated_at: userData.updated_at
          }
        });

      res.status(204).end();
    } catch (error) {
      logger.error('Erreur de synchronisation', {
        error: error.message,
        userId: token.content.sub,
        email: token.content.email
      });

      if (error.message.includes('Technicien')) {
        res.status(400).json({ 
          error: "Configuration manquante",
          details: "La fonction Technicien doit Ãªtre crÃ©Ã©e en base de donnÃ©es"
        });
      } else {
        res.status(500).json({ 
          error: "Ã‰chec de la synchronisation",
          details: error.message
        });
      }
    }
  }
};


================================================
File: modules/users/controllers/users.controller.js
================================================
ï»¿const logger = require('../../../core/utils/logger');
const userService = require('../services/users.service');

module.exports = {
  getAllUsers: async (req, res, next) => {
    try {
      const { page = 1, limit = 10 } = req.query;
      const users = await userService.getAllUsers(parseInt(page), parseInt(limit));
      
      logger.info(`RÃ©cupÃ©ration de ${users.length} utilisateurs`);
      res.json(users.map(user => ({
        ...user,
        fonction: user.fonction?.nom || 'Non dÃ©fini'
      })));
    } catch (error) {
      logger.error('Ã‰chec de rÃ©cupÃ©ration des utilisateurs:', error);
      next(error);
    }
  },

  getMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content;

    try {
      const user = await userService.getUserByKeycloakId(sub);
      if (!user) return res.status(404).json({ error: "Utilisateur non trouvÃ©" });

      res.json({
        email: user.email,
        nom: user.nom,
        prenom: user.prenom,
        service: user.service,
        fonction: user.fonction?.nom || 'Non dÃ©fini'
      });
    } catch (error) {
      logger.error('Erreur lors de la rÃ©cupÃ©ration du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Erreur serveur" });
    }
  },

  updateMyProfile: async (req, res) => {
    const { sub } = req.kauth.grant.access_token.content;
    const updates = req.body;

    try {
      const allowedFields = ["tel", "adresse"];
      const filteredUpdates = Object.keys(updates)
        .filter(key => allowedFields.includes(key))
        .reduce((obj, key) => ({ ...obj, [key]: updates[key] }), {});

      if (Object.keys(filteredUpdates).length === 0) {
        return res.status(400).json({ error: "Aucun champ modifiable fourni" });
      }

      await userService.updateUserProfile(sub, filteredUpdates);
      res.status(204).end();
    } catch (error) {
      logger.error('Ã‰chec de la mise Ã  jour du profil', {
        error: error.message,
        userId: sub
      });
      res.status(500).json({ error: "Ã‰chec de la mise Ã  jour" });
    }
  }
};


================================================
File: modules/users/routes/users.routes.js
================================================
ï»¿//


const express = require('express');
const router = express.Router();
const { protect } = require('../../../core/auth/middleware');
const UsersController = require('../controllers/users.controller');
const SyncController = require('../controllers/sync.controller');

// Synchronisation Keycloak â†’ BD MÃ©tier
router.post('/sync', protect(), SyncController.syncUser);

// RÃ©cupÃ©ration du profil utilisateur
router.get('/me', protect(), UsersController.getMyProfile);

// Mise Ã  jour du profil (ex: tÃ©lÃ©phone)
router.patch('/me', protect(), UsersController.updateMyProfile);

// RÃ©cupÃ©ration de tous les utilisateurs (avec pagination)
// router.get('/', protect(['admin']), UsersController.getAllUsers);
router.get('/', protect(), UsersController.getAllUsers);


module.exports = router;


================================================
File: modules/users/services/users.service.js
================================================
const { db } = require('../../../core/database/config');
const { employes, fonctions } = require('../../../core/database/models');
const { eq } = require('drizzle-orm');

module.exports = {
  getUserByKeycloakId: async (keycloakId) => {
    return await db.query.employes.findFirst({
      where: eq(employes.keycloak_id, keycloakId),
      with: {
        fonction: true // Jointure avec la table fonctions
      }
    });
  },

  updateUserProfile: async (keycloakId, data) => {
    const allowedFields = ["tel", "adresse"];
    const updates = Object.keys(data)
      .filter(key => allowedFields.includes(key))
      .reduce((obj, key) => ({ ...obj, [key]: data[key] }), {});

    await db.update(employes)
      .set(updates)
      .where(eq(employes.keycloak_id, keycloakId));
  },

  getAllUsers: async (page = 1, limit = 10) => {
    try {
      return await db.query.employes.findMany({
        columns: {
          id: true,
          email: true,
          prenom: true,
          nom: true,
          status: true
        },
        with: {
          fonction: {
            columns: {
              nom: true
            }
          }
        },
        orderBy: [employes.nom],
        limit: limit,
        offset: (page - 1) * limit
      });
    } catch (error) {
      throw new Error(`Ã‰chec de rÃ©cupÃ©ration des utilisateurs: ${error.message}`);
    }
  }
};


